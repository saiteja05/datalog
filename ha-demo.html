<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MongoDB | High Availability Demo</title>
    <link rel="icon" href="https://www.mongodb.com/assets/images/global/favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --mongo-green: #00ED64;
            --mongo-dark-green: #00a854;
            --mongo-forest: #001E2B;
            --mongo-slate: #1C2D38;
            --node-primary: #00ED64;
            --node-secondary: #00b4d8;
            --node-down: #ef476f;
            --node-recovering: #ffd166;
            --op-insert: #00ED64;
            --op-update: #ffd166;
            --op-delete: #ef476f;
            --region-1: #00b4d8;
            --region-2: #00c853;
            --region-3: #ff9100;
            /* Legacy region vars for compatibility */
            --region-a: var(--region-1);
            --region-b: var(--region-2);
            --region-c: var(--region-3);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: linear-gradient(135deg, var(--mongo-forest) 0%, #002a3a 50%, var(--mongo-forest) 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(0, 30, 43, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 237, 100, 0.2);
            padding: 14px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 38px;
            height: 38px;
            background: var(--mongo-green);
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--mongo-forest);
            font-size: 1.2rem;
        }

        .logo-text {
            font-size: 1.3rem;
            font-weight: 600;
        }

        .logo-text span { color: var(--mongo-green); }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .cluster-status {
            display: flex;
            align-items: center;
            gap: 7px;
            font-size: 0.9rem;
            padding: 6px 14px;
            background: rgba(0, 237, 100, 0.1);
            border-radius: 18px;
            border: 1px solid rgba(0, 237, 100, 0.3);
        }

        .cluster-status.healthy { color: var(--mongo-green); }
        .cluster-status.degraded { background: rgba(255, 209, 102, 0.1); border-color: rgba(255, 209, 102, 0.3); color: var(--node-recovering); }
        .cluster-status.critical { background: rgba(239, 71, 111, 0.1); border-color: rgba(239, 71, 111, 0.3); color: var(--node-down); }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

        /* Main Layout */
        .main-layout {
            padding: 20px 28px;
            max-width: 1900px;
            margin: 0 auto;
        }

        /* Topology Toggle */
        .topology-toggle {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }
        .topology-btn {
            padding: 10px 24px;
            background: rgba(0, 30, 43, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .topology-btn:hover {
            border-color: rgba(255, 255, 255, 0.3);
            color: white;
        }
        .topology-btn.selected {
            background: rgba(0, 237, 100, 0.15);
            border-color: var(--mongo-green);
            color: var(--mongo-green);
        }

        /* Cluster Selector */
        .cluster-selector {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .cluster-option {
            flex: 1;
            min-width: 300px;
            padding: 16px 20px;
            background: rgba(0, 30, 43, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cluster-option:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .cluster-option.selected {
            border-color: var(--mongo-green);
            background: rgba(0, 237, 100, 0.05);
        }

        .cluster-option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .cluster-option-title {
            font-weight: 600;
            font-size: 1.05rem;
        }

        .cluster-option-badge {
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .cluster-option-badge.single { background: rgba(255, 255, 255, 0.1); }
        .cluster-option-badge.multi { background: rgba(0, 237, 100, 0.2); color: var(--mongo-green); }

        .cluster-option-desc {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 12px;
        }

        .cluster-option-regions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .region-chip {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .region-chip.region-a, .region-chip.region-1 { background: rgba(0, 180, 216, 0.2); color: var(--region-1); }
        .region-chip.region-b, .region-chip.region-2 { background: rgba(0, 200, 83, 0.2); color: var(--region-2); }
        .region-chip.region-c, .region-chip.region-3 { background: rgba(255, 145, 0, 0.2); color: var(--region-3); }

        /* Top Controls */
        .top-section {
            display: flex;
            gap: 14px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-card {
            background: rgba(0, 30, 43, 0.7);
            border-radius: 10px;
            border: 1px solid rgba(0, 237, 100, 0.15);
            padding: 14px 16px;
        }

        .control-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

        .action-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 7px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .action-btn.primary { background: var(--mongo-green); color: var(--mongo-forest); }
        .action-btn.primary:hover { background: var(--mongo-dark-green); }
        .action-btn.secondary { background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.2); }
        .action-btn.secondary:hover { background: rgba(255, 255, 255, 0.15); }
        .action-btn.danger { background: rgba(239, 71, 111, 0.2); color: var(--node-down); border: 1px solid rgba(239, 71, 111, 0.3); }
        .action-btn.danger:hover { background: rgba(239, 71, 111, 0.3); }
        .action-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Region Failure Buttons */
        .region-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 7px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .region-btn.region-a, .region-btn.region-1 { background: rgba(0, 180, 216, 0.2); color: var(--region-1); border: 1px solid var(--region-1); }
        .region-btn.region-b, .region-btn.region-2 { background: rgba(0, 200, 83, 0.2); color: var(--region-2); border: 1px solid var(--region-2); }
        .region-btn.region-c, .region-btn.region-3 { background: rgba(255, 145, 0, 0.2); color: var(--region-3); border: 1px solid var(--region-3); }
        .region-btn:hover { filter: brightness(1.2); }
        .region-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .wc-pills { display: flex; gap: 6px; }

        .wc-pill {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .wc-pill:hover { background: rgba(255, 255, 255, 0.1); }
        .wc-pill.selected { background: rgba(0, 237, 100, 0.15); border-color: var(--mongo-green); color: var(--mongo-green); }

        .read-pref-select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 7px;
            color: white;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .read-pref-select option { background: var(--mongo-slate); }

        /* Regions Container */
        .regions-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .region-panel {
            flex: 1;
            min-width: 360px;
            background: rgba(0, 30, 43, 0.5);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .region-panel.region-a, .region-panel.region-1 { border-color: rgba(0, 180, 216, 0.3); }
        .region-panel.region-b, .region-panel.region-2 { border-color: rgba(0, 200, 83, 0.3); }
        .region-panel.region-c, .region-panel.region-3 { border-color: rgba(255, 145, 0, 0.3); }

        .region-panel.down { opacity: 0.5; border-style: dashed; }

        .region-header {
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .region-panel.region-a .region-header, .region-panel.region-1 .region-header { background: rgba(0, 180, 216, 0.1); }
        .region-panel.region-b .region-header, .region-panel.region-2 .region-header { background: rgba(0, 200, 83, 0.1); }
        .region-panel.region-c .region-header, .region-panel.region-3 .region-header { background: rgba(255, 145, 0, 0.1); }

        .region-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1rem;
        }

        .region-icon {
            width: 30px;
            height: 30px;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .region-panel.region-a .region-icon, .region-panel.region-1 .region-icon { background: rgba(0, 180, 216, 0.2); }
        .region-panel.region-b .region-icon, .region-panel.region-2 .region-icon { background: rgba(0, 200, 83, 0.2); }
        .region-panel.region-c .region-icon, .region-panel.region-3 .region-icon { background: rgba(255, 145, 0, 0.2); }

        .region-status {
            font-size: 0.8rem;
            padding: 4px 10px;
            border-radius: 10px;
            background: rgba(0, 237, 100, 0.2);
            color: var(--mongo-green);
        }

        .region-status.down {
            background: rgba(239, 71, 111, 0.2);
            color: var(--node-down);
        }

        .region-nodes {
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Node Card */
        .node-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.3s;
        }

        .node-card.primary { border-color: var(--node-primary); box-shadow: 0 0 16px rgba(0, 237, 100, 0.15); }
        .node-card.secondary { border-color: var(--node-secondary); }
        .node-card.down { border-color: var(--node-down); opacity: 0.6; }
        .node-card.recovering { border-color: var(--node-recovering); }
        .node-card.syncing { 
            border-color: #00b4d8; 
            animation: syncPulse 1s ease-in-out infinite;
        }
        
        @keyframes syncPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 180, 216, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 180, 216, 0.6); }
        }

        .node-header {
            padding: 12px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
        }

        .node-info { display: flex; align-items: center; gap: 12px; }

        .node-icon {
            width: 38px;
            height: 38px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .node-card.primary .node-icon { background: rgba(0, 237, 100, 0.15); }
        .node-card.secondary .node-icon { background: rgba(0, 180, 216, 0.15); }
        .node-card.down .node-icon { background: rgba(239, 71, 111, 0.15); }

        .node-details h4 { font-size: 0.95rem; font-weight: 600; margin-bottom: 2px; }
        .node-details .port { font-family: 'Source Code Pro', monospace; font-size: 0.8rem; color: rgba(255, 255, 255, 0.5); }

        .node-role-badge {
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .node-card.primary .node-role-badge { background: var(--node-primary); color: var(--mongo-forest); }
        .node-card.secondary .node-role-badge { background: var(--node-secondary); color: var(--mongo-forest); }
        .node-card.down .node-role-badge { background: var(--node-down); color: white; }
        .node-card.recovering .node-role-badge { background: var(--node-recovering); color: var(--mongo-forest); }
        .node-card.syncing .node-role-badge { background: #00b4d8; color: var(--mongo-forest); }

        .node-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .node-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .node-btn.kill { background: rgba(239, 71, 111, 0.2); color: var(--node-down); }
        .node-btn.start { background: rgba(0, 237, 100, 0.2); color: var(--mongo-green); }

        /* Oplog Section */
        .oplog-section { padding: 12px 14px; }

        .oplog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .oplog-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--mongo-green);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .oplog-title code {
            background: rgba(0, 237, 100, 0.1);
            padding: 3px 8px;
            border-radius: 5px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
        }

        .oplog-stats { font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); }

        .replication-lag {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }

        .lag-bar { flex: 1; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden; }
        .lag-fill { height: 100%; background: var(--mongo-green); transition: width 0.3s; }
        .lag-fill.warning { background: var(--node-recovering); }
        .lag-fill.critical { background: var(--node-down); }
        .lag-value { font-family: 'Source Code Pro', monospace; min-width: 45px; text-align: right; }

        .oplog-entries {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            max-height: 160px;
            overflow-y: auto;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
        }

        .oplog-entries::-webkit-scrollbar { width: 5px; }
        .oplog-entries::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }

        .oplog-entry {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .oplog-entry.new { animation: flashNew 1s ease-out; }
        @keyframes flashNew { 0% { background: rgba(0, 237, 100, 0.3); } 100% { background: transparent; } }

        .oplog-entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .oplog-op { display: flex; align-items: center; gap: 6px; }

        .op-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .op-badge.insert { background: var(--op-insert); color: var(--mongo-forest); }
        .op-badge.update { background: var(--op-update); color: var(--mongo-forest); }
        .op-badge.delete { background: var(--op-delete); color: white; }
        .op-badge.noop { background: #6c757d; color: white; }

        .oplog-ns { color: var(--node-secondary); font-size: 0.7rem; }
        .oplog-ts { color: rgba(255, 255, 255, 0.3); font-size: 0.65rem; }

        .oplog-doc {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 8px;
            border-radius: 5px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .oplog-empty {
            padding: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
        }

        /* Event Log */
        .event-log-panel {
            background: rgba(0, 30, 43, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(0, 237, 100, 0.15);
            padding: 14px;
            margin-top: 20px;
        }

        .event-log-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 10px;
        }

        .event-log {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 6px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            flex-shrink: 0;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
        }

        .log-entry.info { border-color: var(--node-secondary); }
        .log-entry.success { border-color: var(--mongo-green); }
        .log-entry.warning { border-color: var(--node-recovering); }
        .log-entry.error { border-color: var(--node-down); }

        .log-time { color: rgba(255, 255, 255, 0.4); font-size: 0.7rem; margin-bottom: 3px; }
        .log-msg { color: rgba(255, 255, 255, 0.9); }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.visible { opacity: 1; visibility: visible; }

        .modal {
            background: var(--mongo-slate);
            border-radius: 20px;
            border: 1px solid rgba(0, 237, 100, 0.3);
            padding: 35px;
            max-width: 550px;
            width: 90%;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.visible .modal { transform: scale(1); }
        .modal-icon { font-size: 2.8rem; margin-bottom: 14px; }
        .modal-title { font-size: 1.3rem; font-weight: 600; margin-bottom: 10px; }
        .modal-text { color: rgba(255, 255, 255, 0.7); margin-bottom: 16px; line-height: 1.5; font-size: 1rem; }

        .election-progress {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 16px 0;
        }

        .election-progress-bar {
            height: 100%;
            background: var(--mongo-green);
            width: 0%;
            transition: width 0.3s;
        }

        #election-status { font-size: 0.95rem; color: rgba(255, 255, 255, 0.6); }

        /* Info Panel */
        .info-panel {
            background: rgba(0, 237, 100, 0.05);
            border: 1px solid rgba(0, 237, 100, 0.2);
            border-radius: 12px;
            padding: 14px 18px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .info-icon { font-size: 1.6rem; }
        .info-content { flex: 1; }
        .info-title { font-weight: 600; font-size: 1rem; margin-bottom: 4px; }
        .info-desc { font-size: 0.9rem; color: rgba(255, 255, 255, 0.7); }

        /* Replication Flow Visualization */
        .replication-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .flow-particle {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 51;
        }

        .flow-particle.write {
            background: #ff6b6b;
            box-shadow: 0 0 16px #ff6b6b, 0 0 32px #ff6b6b;
        }

        .flow-particle.replication {
            background: var(--mongo-green);
            box-shadow: 0 0 16px var(--mongo-green), 0 0 32px var(--mongo-green);
        }

        .flow-particle.ack {
            background: #ffd166;
            box-shadow: 0 0 16px #ffd166;
        }

        .flow-particle.read {
            background: #4ECDC4;
            box-shadow: 0 0 16px #4ECDC4, 0 0 32px #4ECDC4;
        }

        .node-card.reading {
            animation: readingPulse 0.4s ease-in-out 2;
        }

        @keyframes readingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        /* Node highlight states */
        .node-card.receiving {
            animation: receiveFlash 0.5s ease-out;
        }

        .node-card.acknowledged {
            position: relative;
        }

        .node-card.acknowledged::after {
            content: 'âœ“';
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: var(--mongo-green);
            color: var(--mongo-forest);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            animation: ackPop 0.3s ease-out;
            z-index: 10;
        }

        @keyframes receiveFlash {
            0% { box-shadow: 0 0 30px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: none; }
        }

        @keyframes ackPop {
            0% { transform: scale(0); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Write Flow Status Panel */
        .write-flow-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 360px;
            background: rgba(0, 30, 43, 0.95);
            border: 2px solid var(--mongo-green);
            border-radius: 14px;
            padding: 16px;
            z-index: 100;
            display: none;
            animation: slideUp 0.3s ease-out;
        }

        .write-flow-panel.visible {
            display: block;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .write-flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .write-flow-title {
            font-weight: 600;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .write-flow-wc {
            font-size: 0.85rem;
            padding: 4px 10px;
            background: rgba(0, 237, 100, 0.2);
            border-radius: 10px;
            color: var(--mongo-green);
        }

        .write-flow-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .write-flow-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0.4;
            transition: all 0.3s;
        }

        .write-flow-step.active {
            opacity: 1;
            background: rgba(0, 237, 100, 0.1);
            border-left: 3px solid var(--mongo-green);
        }

        .write-flow-step.complete {
            opacity: 1;
        }

        .write-flow-step.complete .step-icon {
            color: var(--mongo-green);
        }

        .step-icon {
            font-size: 1rem;
            width: 26px;
            text-align: center;
        }

        .step-content {
            flex: 1;
        }

        .step-label {
            font-weight: 500;
            font-size: 0.85rem;
        }

        .step-detail {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
        }

        .step-nodes {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .step-node-badge {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
        }

        .step-node-badge.primary {
            background: rgba(0, 237, 100, 0.2);
            color: var(--mongo-green);
        }

        .step-node-badge.acked {
            background: rgba(0, 237, 100, 0.3);
            color: var(--mongo-green);
        }

        .step-node-badge.pending {
            background: rgba(255, 209, 102, 0.2);
            color: var(--node-recovering);
        }

        .step-node-badge.majority-reached {
            background: rgba(0, 237, 100, 0.5);
            color: white;
            font-weight: 600;
            animation: majorityPulse 0.5s ease-out;
        }

        @keyframes majorityPulse {
            0% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .majority-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(0, 237, 100, 0.2);
            border: 1px solid var(--mongo-green);
            border-radius: 5px;
            font-size: 0.75rem;
            color: var(--mongo-green);
            margin-left: 6px;
        }

        .write-flow-result {
            margin-top: 12px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            display: none;
        }

        .write-flow-result.success {
            display: block;
            background: rgba(0, 237, 100, 0.15);
            color: var(--mongo-green);
            border: 1px solid var(--mongo-green);
        }

        .write-flow-result.failed {
            display: block;
            background: rgba(239, 71, 111, 0.15);
            color: var(--node-down);
            border: 1px solid var(--node-down);
        }

        /* Read Flow Status Panel */
        .read-flow-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 400px;
            background: rgba(0, 30, 43, 0.95);
            border: 2px solid #4ECDC4;
            border-radius: 14px;
            padding: 16px;
            z-index: 100;
            display: none;
            animation: slideUp 0.3s ease-out;
        }

        .read-flow-panel.visible {
            display: block;
        }

        .read-flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .read-flow-title {
            font-weight: 600;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .read-flow-pref {
            font-size: 0.85rem;
            padding: 4px 10px;
            background: rgba(78, 205, 196, 0.2);
            border-radius: 10px;
            color: #4ECDC4;
            font-family: 'Source Code Pro', monospace;
        }

        .read-flow-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .read-flow-nodes {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .read-node-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .read-node-row.eligible {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .read-node-row.selected {
            background: rgba(78, 205, 196, 0.25);
            border: 2px solid #4ECDC4;
            animation: readPulse 0.5s ease-out;
        }

        .read-node-row.not-eligible {
            opacity: 0.4;
        }

        @keyframes readPulse {
            0% { transform: scale(1.02); box-shadow: 0 0 20px rgba(78, 205, 196, 0.5); }
            100% { transform: scale(1); box-shadow: none; }
        }

        .read-node-icon {
            font-size: 1.2rem;
        }

        .read-node-info {
            flex: 1;
        }

        .read-node-name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .read-node-meta {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
        }

        .read-node-status {
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 10px;
        }

        .read-node-status.primary {
            background: rgba(255, 209, 102, 0.2);
            color: #FFD166;
        }

        .read-node-status.secondary {
            background: rgba(78, 205, 196, 0.2);
            color: #4ECDC4;
        }

        .read-node-status.down {
            background: rgba(239, 71, 111, 0.2);
            color: #EF476F;
        }

        .read-flow-selection {
            padding: 12px;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            border: 1px dashed rgba(78, 205, 196, 0.3);
        }

        .read-selection-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .read-selection-target {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .read-selection-arrow {
            font-size: 1.6rem;
            color: #4ECDC4;
            animation: arrowBounce 0.8s ease-in-out infinite;
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(6px); }
        }

        .read-selection-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(78, 205, 196, 0.2);
            border-radius: 8px;
            border: 1px solid #4ECDC4;
            font-size: 0.9rem;
        }

        .read-selection-reason {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.6);
            margin-top: 10px;
            font-style: italic;
        }

        .read-node-badge {
            display: inline-block;
            padding: 4px 10px;
            margin: 2px;
            border-radius: 12px;
            font-size: 0.8rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .read-node-badge.eligible {
            background: rgba(78, 205, 196, 0.1);
            border-color: rgba(78, 205, 196, 0.3);
        }
        .read-node-badge.target {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ECDC4;
            color: #4ECDC4;
            font-weight: 600;
        }
        
        .selection-detail {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .selection-detail:last-child { border-bottom: none; }
        .selection-label { color: rgba(255,255,255,0.5); font-size: 0.8rem; }
        .selection-value { font-weight: 600; font-size: 0.85rem; }
        .selection-value.primary { color: var(--node-primary); }
        .selection-value.secondary { color: var(--node-secondary); }

        .read-flow-result {
            margin-top: 12px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            display: none;
        }

        .read-flow-result.success {
            display: block;
            background: rgba(78, 205, 196, 0.15);
            color: #4ECDC4;
            border: 1px solid #4ECDC4;
        }

        .read-flow-result.failed {
            display: block;
            background: rgba(239, 71, 111, 0.15);
            color: var(--node-down);
            border: 1px solid var(--node-down);
        }

        /* Mongos Layer */
        .mongos-layer {
            background: rgba(0, 237, 100, 0.05);
            border: 1px solid rgba(0, 237, 100, 0.2);
            border-radius: 12px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }

        .layer-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mongos-grid {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mongos-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(0, 237, 100, 0.1);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .mongos-node:hover { background: rgba(0, 237, 100, 0.2); }
        .mongos-node.down { opacity: 0.4; border-style: dashed; }
        .mongos-icon { font-size: 1.1rem; }
        .mongos-info { font-size: 0.85rem; }
        .mongos-region { font-size: 0.7rem; color: rgba(255,255,255,0.5); }

        /* Config Servers Layer */
        .config-layer {
            background: rgba(255, 193, 7, 0.05);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 12px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }

        .config-layer .layer-title { color: #ffc107; }

        .config-grid {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .config-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .config-node.primary {
            border-color: rgba(255, 193, 7, 0.6);
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.2);
        }

        .config-node.down { opacity: 0.4; border-style: dashed; }
        .config-icon { font-size: 1.1rem; }
        .config-info { font-size: 0.85rem; }
        .config-region { font-size: 0.7rem; color: rgba(255,255,255,0.5); }
        .config-role {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,193,7,0.2);
            color: #ffc107;
        }

        /* Shards Container */
        .shards-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .shard-panel {
            flex: 1;
            min-width: 380px;
            background: rgba(0, 30, 43, 0.6);
            border-radius: 14px;
            border: 2px solid rgba(0, 237, 100, 0.3);
            overflow: hidden;
        }

        .shard-header {
            padding: 12px 16px;
            background: rgba(0, 237, 100, 0.1);
            border-bottom: 1px solid rgba(0, 237, 100, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shard-icon {
            width: 30px;
            height: 30px;
            background: rgba(0, 237, 100, 0.15);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .shard-title { font-weight: 600; font-size: 1rem; }

        .shard-status {
            margin-left: auto;
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 10px;
        }

        .shard-status.healthy { background: rgba(0, 237, 100, 0.2); color: var(--mongo-green); }
        .shard-status.degraded { background: rgba(255, 209, 102, 0.2); color: var(--node-recovering); }
        .shard-status.critical { background: rgba(239, 71, 111, 0.2); color: var(--node-down); }

        .shard-body { padding: 12px; }

        /* Replica Set Container */
        .rs-container {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
        }
        .rs-region-group {
            background: rgba(0, 30, 43, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px;
            min-width: 280px;
        }
        .rs-region-group.region-a, .rs-region-group.region-1 { border-left: 4px solid var(--region-1); }
        .rs-region-group.region-b, .rs-region-group.region-2 { border-left: 4px solid var(--region-2); }
        .rs-region-group.region-c, .rs-region-group.region-3 { border-left: 4px solid var(--region-3); }
        .rs-region-group.down { opacity: 0.5; }
        .rs-region-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .rs-region-icon { font-size: 1.2rem; }
        .rs-region-name { font-weight: 600; font-size: 1rem; }
        .rs-region-latency { 
            font-size: 0.75rem; 
            color: rgba(255,255,255,0.5);
            margin-left: auto;
            background: rgba(255,255,255,0.05);
            padding: 2px 8px;
            border-radius: 10px;
        }
        .rs-nodes { display: flex; flex-direction: column; gap: 10px; }

        /* Region Row */
        .region-row {
            display: flex;
            align-items: stretch;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border-left: 3px solid;
        }

        .region-row.region-a, .region-row.region-1 { border-color: var(--region-1); }
        .region-row.region-b, .region-row.region-2 { border-color: var(--region-2); }
        .region-row.region-c, .region-row.region-3 { border-color: var(--region-3); }
        .region-row.down { opacity: 0.5; }

        .region-label {
            min-width: 85px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px;
        }

        .region-name {
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .region-latency {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
        }

        .region-nodes {
            display: flex;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        /* Shard Node Card */
        .node-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
            min-width: 110px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .node-card:hover { transform: translateY(-2px); }
        .node-card.primary { border-color: var(--node-primary); box-shadow: 0 0 12px rgba(0, 237, 100, 0.2); }
        .node-card.secondary { border-color: var(--node-secondary); }
        .node-card.priority-zero { border-color: #9d4edd; border-style: dashed; }
        .node-card.read-replica { border-color: #ff6b6b; border-style: dashed; background: rgba(255, 107, 107, 0.05); }
        .node-card.down { border-color: var(--node-down); opacity: 0.5; }
        .node-card.recovering { border-color: var(--node-recovering); }
        .node-card.syncing { 
            border-color: #00b4d8; 
            animation: syncPulse 1s ease-in-out infinite;
        }

        @keyframes syncPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 180, 216, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 180, 216, 0.6); }
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .node-icon { font-size: 0.9rem; }
        .node-name { font-size: 0.75rem; font-weight: 600; flex: 1; }

        .node-role-badge {
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 6px;
        }

        .node-card.primary .node-role-badge { background: var(--node-primary); color: var(--mongo-forest); }
        .node-card.secondary .node-role-badge { background: var(--node-secondary); color: var(--mongo-forest); }
        .node-card.priority-zero .node-role-badge { background: #9d4edd; color: white; }
        .node-card.read-replica .node-role-badge { background: #ff6b6b; color: white; }
        .node-card.down .node-role-badge { background: var(--node-down); color: white; }
        .node-card.recovering .node-role-badge { background: var(--node-recovering); color: var(--mongo-forest); }
        .node-card.syncing .node-role-badge { background: #00b4d8; color: white; }

        .node-oplog {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            font-family: 'Source Code Pro', monospace;
        }

        .node-card.receiving {
            animation: receiveFlash 0.5s ease-out;
        }

        @keyframes receiveFlash {
            0% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: none; }
        }

        .node-card.acknowledged::after {
            content: 'âœ“';
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: var(--mongo-green);
            color: var(--mongo-forest);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            animation: ackPop 0.3s ease-out;
        }

        @keyframes ackPop {
            0% { transform: scale(0); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Statistics Dashboard */
        .stats-dashboard {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .stat-card {
            background: rgba(0, 30, 43, 0.7);
            border: 1px solid rgba(0, 237, 100, 0.15);
            border-radius: 10px;
            padding: 12px 16px;
            min-width: 120px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--mongo-green);
            font-family: 'Source Code Pro', monospace;
        }
        .stat-value.warning { color: var(--op-update); }
        .stat-value.error { color: var(--node-down); }
        .stat-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        /* Connection String Panel */
        .conn-string-panel {
            background: rgba(0, 30, 43, 0.8);
            border: 1px solid rgba(0, 237, 100, 0.2);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 15px;
        }
        .conn-string-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .conn-string-code {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 12px;
            border-radius: 6px;
            overflow-x: auto;
            white-space: nowrap;
            color: #4ECDC4;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .conn-string-code:hover {
            background: rgba(0, 0, 0, 0.5);
        }
        .conn-string-code::after {
            content: 'ðŸ“‹ Click to copy';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
            font-family: 'Space Grotesk', sans-serif;
        }
        .conn-string-code.copied::after {
            content: 'âœ“ Copied!';
            color: var(--mongo-green);
        }

        /* Animation Controls */
        .anim-controls {
            position: fixed;
            top: 80px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 50;
        }
        .anim-btn {
            background: rgba(0, 30, 43, 0.9);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 8px;
            padding: 8px 14px;
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--mongo-green);
            transition: all 0.2s ease;
            min-width: 90px;
            text-align: center;
        }
        .anim-btn:hover {
            background: rgba(0, 237, 100, 0.1);
            border-color: var(--mongo-green);
        }
        .anim-btn.paused {
            background: rgba(255, 193, 7, 0.15);
            border-color: #ffc107;
            color: #ffc107;
        }
        
        /* Keyboard Shortcuts Toggle Button */
        .shortcuts-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 30, 43, 0.9);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.75rem;
            z-index: 50;
            cursor: pointer;
            color: var(--mongo-green);
            transition: all 0.2s ease;
        }
        .shortcuts-toggle:hover {
            background: rgba(0, 237, 100, 0.1);
            border-color: var(--mongo-green);
        }
        
        /* Keyboard Shortcuts Help Panel */
        .shortcuts-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 30, 43, 0.95);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 12px;
            padding: 14px 18px;
            padding-top: 28px;
            font-size: 0.75rem;
            z-index: 51;
            max-width: 200px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.2s ease;
        }
        .shortcuts-help.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .shortcuts-close {
            position: absolute;
            top: 6px;
            right: 10px;
            cursor: pointer;
            color: rgba(255,255,255,0.5);
            font-size: 1.1rem;
            line-height: 1;
        }
        .shortcuts-close:hover { color: #fff; }
        .shortcuts-title {
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 8px;
            font-size: 0.8rem;
        }
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            color: rgba(255,255,255,0.7);
        }
        .shortcut-key {
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
        }

        /* Auto Demo Button */
        .auto-demo-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #9d4edd 0%, #7b2cbf 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        .auto-demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.4);
        }
        .auto-demo-btn.running {
            background: linear-gradient(135deg, #ef476f 0%, #d62839 100%);
        }
        .auto-demo-btn .demo-icon {
            font-size: 1.1rem;
        }

        /* Demo Narration */
        .demo-narration {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 30, 43, 0.95);
            border: 2px solid var(--mongo-green);
            border-radius: 12px;
            padding: 16px 24px;
            max-width: 500px;
            text-align: center;
            z-index: 200;
            display: none;
            animation: narrateIn 0.3s ease-out;
        }
        .demo-narration.visible { display: block; }
        .demo-narration-text {
            font-size: 1rem;
            line-height: 1.5;
        }
        .demo-narration-step {
            font-size: 0.75rem;
            color: var(--mongo-green);
            margin-top: 8px;
        }
        @keyframes narrateIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* ========== STANDBY CLUSTER STYLES (BETA) ========== */
        .standby-cluster-container {
            background: rgba(0, 30, 43, 0.6);
            border-radius: 16px;
            border: 1px solid rgba(255, 145, 0, 0.3);
            padding: 24px;
            margin-bottom: 20px;
        }

        .standby-cluster-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .standby-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .beta-badge {
            font-size: 0.65rem;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            padding: 3px 8px;
            border-radius: 8px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .standby-subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.95rem;
            margin: 0;
        }

        .standby-note {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            background: rgba(0, 180, 216, 0.1);
            border: 1px solid rgba(0, 180, 216, 0.3);
            border-left: 4px solid var(--region-1);
            border-radius: 8px;
            padding: 14px 18px;
            margin-bottom: 20px;
        }

        .standby-note .note-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .standby-note .note-content {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.5;
        }

        .standby-note .note-content strong {
            color: var(--region-1);
        }

        .standby-benefits {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .benefit-card {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 237, 100, 0.1);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 12px;
            padding: 12px 18px;
        }

        .benefit-card.warning {
            background: rgba(255, 145, 0, 0.1);
            border-color: rgba(255, 145, 0, 0.4);
        }

        .benefit-icon {
            font-size: 1.5rem;
        }

        .benefit-text {
            display: flex;
            flex-direction: column;
        }

        .benefit-text strong {
            color: #fff;
            font-size: 0.9rem;
        }

        .benefit-text span {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
        }

        .standby-diagram {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: stretch;
            margin-bottom: 30px;
        }

        .standby-region {
            flex: 1;
            max-width: 380px;
            background: rgba(0, 30, 43, 0.8);
            border-radius: 12px;
            overflow: hidden;
        }

        .region-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .region-header.active {
            background: linear-gradient(135deg, rgba(0, 180, 216, 0.3), rgba(0, 180, 216, 0.1));
            border-bottom: 2px solid var(--region-1);
        }

        .region-header.standby {
            background: linear-gradient(135deg, rgba(0, 200, 83, 0.3), rgba(0, 200, 83, 0.1));
            border-bottom: 2px solid var(--region-2);
        }

        .region-icon {
            font-size: 1.2rem;
        }

        .region-name {
            flex: 1;
            letter-spacing: 1px;
        }

        .region-status {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .region-components {
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .region-top-row {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }

        .cloud-storage {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.25);
            border-radius: 10px;
            padding: 10px;
        }

        .storage-icon {
            font-size: 1.6rem;
        }

        .storage-details {
            flex: 1;
        }

        .storage-name {
            font-weight: 600;
            font-size: 0.8rem;
            color: #fff;
            margin-bottom: 4px;
        }

        .storage-items {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .storage-item {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.6);
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .control-plane {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            background: rgba(157, 78, 221, 0.15);
            border: 1px solid rgba(157, 78, 221, 0.3);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            min-width: 80px;
        }

        .control-icon {
            font-size: 1rem;
        }

        /* Vertical Flow Arrows */
        .vertical-flow-section {
            display: flex;
            justify-content: center;
            padding: 4px 0;
        }

        .flow-arrow-vertical {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .flow-arrow-vertical .arrow-line {
            width: 3px;
            height: 20px;
            background: linear-gradient(180deg, var(--mongo-green), rgba(0, 237, 100, 0.3));
            border-radius: 2px;
            position: relative;
        }

        .flow-arrow-vertical.up .arrow-line {
            background: linear-gradient(0deg, var(--mongo-green), rgba(0, 237, 100, 0.3));
        }

        .flow-arrow-vertical .arrow-line::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            border: 2px solid var(--mongo-green);
            border-top: none;
            border-left: none;
            transform: rotate(45deg);
            bottom: -4px;
            left: -2.5px;
        }

        .flow-arrow-vertical.up .arrow-line::after {
            transform: rotate(-135deg);
            top: -4px;
            bottom: auto;
        }

        .flow-arrow-vertical .arrow-label {
            font-size: 0.7rem;
            color: var(--mongo-green);
            font-weight: 600;
            white-space: nowrap;
        }

        .flow-arrow-vertical.small .arrow-line {
            height: 14px;
        }

        .flow-arrow-vertical .arrow-label-small {
            font-size: 0.6rem;
            color: rgba(255, 209, 102, 0.9);
            font-weight: 500;
        }

        /* Shippers Layer */
        .shippers-layer, .injectors-layer {
            background: rgba(255, 209, 102, 0.08);
            border: 1px dashed rgba(255, 209, 102, 0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .shippers-layer .layer-label,
        .injectors-layer .layer-label {
            font-size: 0.6rem;
            font-weight: 700;
            color: rgba(255, 209, 102, 0.7);
            text-align: center;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .shippers-row, .injectors-row {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .shipper-unit, .injector-unit {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .shipper-box, .injector-box {
            background: rgba(255, 209, 102, 0.2);
            border: 1px solid rgba(255, 209, 102, 0.4);
            border-radius: 6px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .shipper-output-arrow {
            text-align: right;
            padding: 6px 4px 0 0;
        }

        .shipper-output-arrow .output-label {
            font-size: 0.7rem;
            color: var(--mongo-green);
            font-weight: 600;
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        .region-top-row.active-top {
            justify-content: flex-end;
        }

        .blob-input-arrow {
            padding: 0 0 6px 4px;
        }

        .blob-input-arrow .input-label {
            font-size: 0.7rem;
            color: var(--mongo-green);
            font-weight: 600;
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        .blob-output-arrow {
            padding: 0 0 6px 4px;
            text-align: right;
        }

        .blob-output-arrow .output-label {
            font-size: 0.7rem;
            color: var(--region-1);
            font-weight: 600;
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        .coordinator-box {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 200, 0, 0.15);
            border: 1px solid rgba(255, 200, 0, 0.4);
            border-radius: 8px;
            padding: 8px 12px;
            margin: 6px 0;
        }

        .coordinator-icon {
            font-size: 1.1rem;
        }

        .coordinator-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #ffc800;
        }

        .injector-flow-label {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            margin-bottom: 4px;
        }

        .cloud-storage.receiving {
            border-color: var(--mongo-green);
            border-style: solid;
            background: rgba(0, 237, 100, 0.08);
        }

        .shipper-icon, .injector-icon {
            font-size: 0.9rem;
        }

        .shipper-label, .injector-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--node-recovering);
        }

        /* Coordinator Layer */
        .coordinator-layer {
            display: flex;
            justify-content: center;
        }

        .coordinator-box {
            background: rgba(255, 145, 0, 0.15);
            border: 2px solid rgba(255, 145, 0, 0.4);
            border-radius: 8px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .coordinator-icon {
            font-size: 1rem;
        }

        .coordinator-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--region-3);
        }

        /* Cluster Boxes */
        .cluster-box {
            border-radius: 10px;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .cluster-box.active-cluster {
            background: rgba(0, 237, 100, 0.15);
            border-color: var(--mongo-green);
            border-width: 2px;
        }

        .cluster-box.standby-cluster {
            background: rgba(0, 30, 43, 0.6);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .cluster-label {
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 2px;
            text-align: center;
        }

        .cluster-sublabel {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            margin-bottom: 8px;
            font-style: italic;
        }

        .shards-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .shard-box {
            background: rgba(0, 30, 43, 0.9);
            border-radius: 8px;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            min-width: 100px;
        }

        .shard-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            margin-bottom: 6px;
        }

        .shard-nodes {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .mini-node {
            width: 28px;
            height: 28px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 700;
        }

        .mini-node.primary {
            background: var(--mongo-green);
            color: var(--mongo-forest);
        }

        .mini-node.secondary {
            background: var(--node-secondary);
            color: var(--mongo-forest);
        }

        .mini-node.standby-node {
            opacity: 0.6;
            filter: brightness(0.8);
        }

        .cluster-box.active-cluster .mini-node:not(.standby-node):not(.down) {
            box-shadow: 0 0 10px rgba(0, 237, 100, 0.5);
        }

        .mini-node.clickable {
            cursor: pointer;
            transition: all 0.2s;
        }

        .mini-node.clickable:hover {
            transform: scale(1.15);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .mini-node.down {
            background: var(--node-down) !important;
            opacity: 0.6;
        }

        .mini-node.recovering {
            background: var(--node-recovering) !important;
            animation: recoveringPulse 1s ease-in-out infinite;
        }

        @keyframes recoveringPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .mini-node.write-target {
            animation: writeFlash 0.5s ease-out;
            box-shadow: 0 0 15px var(--mongo-green);
        }

        .mini-node.write-failed {
            animation: writeFailFlash 0.5s ease-out;
            box-shadow: 0 0 15px #e63946;
        }

        @keyframes writeFailFlash {
            0% { background: #e63946; transform: scale(1.2); }
            50% { background: #ff6b6b; }
            100% { background: rgba(239, 71, 111, 0.3); transform: scale(1); }
        }

        .mini-node.read-target {
            animation: readFlash 0.5s ease-out;
            box-shadow: 0 0 15px var(--node-secondary);
        }

        .mini-node.replicating {
            animation: replicateFlash 0.3s ease-out;
        }

        @keyframes writeFlash {
            0% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        @keyframes readFlash {
            0% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        @keyframes replicateFlash {
            0% { box-shadow: 0 0 0 rgba(0, 237, 100, 0); }
            50% { box-shadow: 0 0 12px rgba(0, 237, 100, 0.8); }
            100% { box-shadow: 0 0 0 rgba(0, 237, 100, 0); }
        }

        .node-letter {
            font-family: 'Source Code Pro', monospace;
        }

        /* Cross-Region Flow (Center) */
        .cross-region-flow {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px 8px;
            min-width: 100px;
        }

        .cross-region-label {
            font-size: 0.65rem;
            font-weight: 700;
            color: rgba(255, 145, 0, 0.8);
            text-align: center;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .flow-lines-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .flow-line-horizontal {
            width: 80px;
            height: 4px;
            background: rgba(255, 145, 0, 0.2);
            border-radius: 2px;
            position: relative;
            display: flex;
            align-items: center;
            overflow: visible;
        }

        .flow-dot {
            width: 8px;
            height: 8px;
            background: var(--region-3);
            border-radius: 50%;
            position: absolute;
            animation: flowDotMove 2s ease-in-out infinite;
            box-shadow: 0 0 6px var(--region-3);
        }

        .flow-dot.delay-1 { animation-delay: 0.6s; }
        .flow-dot.delay-2 { animation-delay: 1.2s; }

        @keyframes flowDotMove {
            0% { left: -8px; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { left: calc(100% + 8px); opacity: 0; }
        }

        .flow-direction-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .flow-direction-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .flow-direction-label .flow-desc {
            font-size: 0.6rem;
            color: rgba(255, 145, 0, 0.9);
            font-weight: 600;
            text-align: center;
            line-height: 1.3;
        }

        .flow-direction-label .arrow-right {
            font-size: 1rem;
            color: var(--region-3);
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        @keyframes arrowPulse {
            0%, 100% { opacity: 0.5; transform: translateX(0); }
            50% { opacity: 1; transform: translateX(3px); }
        }

        /* Reversed flow direction (after failover) */
        .cross-region-flow.reversed .arrow-right {
            animation: arrowPulseLeft 1.5s ease-in-out infinite;
        }

        @keyframes arrowPulseLeft {
            0%, 100% { opacity: 0.5; transform: translateX(0); }
            50% { opacity: 1; transform: translateX(-3px); }
        }

        /* Flow Explanation */
        .standby-flow-explanation {
            background: rgba(0, 30, 43, 0.6);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .standby-flow-explanation h3 {
            font-size: 1rem;
            margin: 0 0 16px 0;
            color: var(--mongo-green);
        }

        .flow-steps {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .flow-step {
            flex: 1;
            min-width: 180px;
            display: flex;
            gap: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 12px;
        }

        .step-number {
            width: 28px;
            height: 28px;
            background: var(--mongo-green);
            color: var(--mongo-forest);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .step-content strong {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }

        .step-content p {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            margin: 0;
            line-height: 1.4;
        }

        .failover-callout {
            display: flex;
            gap: 16px;
            background: rgba(255, 145, 0, 0.1);
            border: 1px solid rgba(255, 145, 0, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
        }

        .callout-icon {
            font-size: 1.8rem;
            flex-shrink: 0;
        }

        .callout-content strong {
            display: block;
            font-size: 0.95rem;
            color: var(--region-3);
            margin-bottom: 6px;
        }

        .callout-content p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
            line-height: 1.5;
        }

        /* Standby Controls */
        .standby-controls {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .standby-control-group {
            background: rgba(0, 30, 43, 0.8);
            border-radius: 10px;
            padding: 14px 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .standby-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .standby-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: none;
            border-radius: 8px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .standby-btn .btn-icon {
            font-size: 1rem;
        }

        .standby-btn.region-active {
            background: rgba(0, 180, 216, 0.2);
            color: var(--region-1);
            border: 1px solid var(--region-1);
        }

        .standby-btn.region-active:hover {
            background: rgba(0, 180, 216, 0.3);
        }

        .standby-btn.region-standby {
            background: rgba(0, 200, 83, 0.2);
            color: var(--region-2);
            border: 1px solid var(--region-2);
        }

        .standby-btn.region-standby:hover {
            background: rgba(0, 200, 83, 0.3);
        }

        .standby-btn.reset {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .standby-btn.reset:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .standby-btn.restore {
            background: rgba(0, 237, 100, 0.2);
            color: var(--mongo-green);
            border: 1px solid var(--mongo-green);
        }

        .standby-btn.restore:hover {
            background: rgba(0, 237, 100, 0.3);
        }

        .standby-btn.switchover {
            background: linear-gradient(135deg, #00b4d8, #0077b6);
            color: white;
            border: none;
        }

        .standby-btn.switchover:hover {
            background: linear-gradient(135deg, #0096c7, #005f8f);
        }

        .standby-btn.switchover:disabled {
            background: rgba(0, 180, 216, 0.3);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }

        .standby-btn.failover {
            background: linear-gradient(135deg, #ff9100, #ff6b00);
            color: white;
            border: none;
        }

        .standby-btn.failover:hover {
            background: linear-gradient(135deg, #ff7b00, #e65c00);
        }

        .standby-btn.failover:disabled {
            background: rgba(255, 145, 0, 0.3);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }

        .standby-btn.splitover {
            background: linear-gradient(135deg, #e63946, #d62839);
            color: white;
            border: none;
        }

        .standby-btn.splitover:hover {
            background: linear-gradient(135deg, #d62839, #c11e2b);
        }

        .standby-btn.setup-standby {
            background: linear-gradient(135deg, #00ed64, #00c853);
            color: var(--mongo-forest);
            border: none;
            font-weight: 600;
        }

        .standby-btn.setup-standby:hover {
            background: linear-gradient(135deg, #00c853, #00a844);
        }

        .standby-btn.setup-standby:disabled {
            background: rgba(0, 237, 100, 0.3);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }

        .failover-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .failover-hints {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            font-size: 0.7rem;
        }

        .failover-hints .hint {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }

        .failover-hints .hint.switchover-hint {
            color: rgba(0, 180, 216, 0.8);
        }

        .failover-hints .hint.splitover-hint {
            color: rgba(230, 57, 70, 0.8);
        }

        .split-mode .standby-region {
            border: 2px solid #e63946 !important;
        }

        .split-mode .cross-region-flow {
            opacity: 0.3;
        }

        .split-mode .flow-line-horizontal .flow-dot {
            animation: none !important;
            opacity: 0.2;
        }

        .cluster-box.independent {
            border-color: #e63946 !important;
            background: rgba(230, 57, 70, 0.1) !important;
        }

        .cluster-box.independent::after {
            content: 'INDEPENDENT';
            position: absolute;
            top: -10px;
            right: 10px;
            background: #e63946;
            color: white;
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }

        .standby-btn.primary-op {
            background: var(--mongo-green);
            color: var(--mongo-forest);
            border: none;
        }

        .standby-btn.primary-op:hover {
            background: var(--mongo-dark-green);
        }

        .standby-btn.secondary-op {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .standby-btn.secondary-op:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .standby-operations {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .standby-wc .wc-pill {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .standby-wc .wc-pill:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .standby-wc .wc-pill.selected {
            background: rgba(0, 237, 100, 0.2);
            border-color: var(--mongo-green);
            color: var(--mongo-green);
        }

        .standby-select {
            background: rgba(0, 30, 43, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            padding: 6px 10px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .standby-node-tip {
            text-align: center;
            margin-bottom: 16px;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
            background: rgba(0,237,100,0.1);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px dashed rgba(0,237,100,0.3);
            display: inline-block;
            width: 100%;
        }

        .standby-btn.switchover {
            background: linear-gradient(135deg, rgba(0, 200, 83, 0.3), rgba(0, 150, 60, 0.3));
            color: var(--mongo-green);
            border: 2px solid var(--mongo-green);
            font-weight: 600;
        }

        .standby-btn.switchover:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 200, 83, 0.5), rgba(0, 150, 60, 0.5));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 237, 100, 0.3);
        }

        .standby-btn.failover {
            background: linear-gradient(135deg, rgba(255, 145, 0, 0.3), rgba(255, 100, 0, 0.3));
            color: var(--region-3);
            border: 2px solid var(--region-3);
            font-weight: 600;
        }

        .standby-btn.failover:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(255, 145, 0, 0.5), rgba(255, 100, 0, 0.5));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 145, 0, 0.3);
        }

        .standby-btn.splitover {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.3), rgba(200, 50, 50, 0.3));
            color: #ff6b6b;
            border: 2px solid #ff6b6b;
            font-weight: 600;
        }

        .standby-btn.splitover:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.5), rgba(200, 50, 50, 0.5));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 100, 100, 0.3);
        }

        .standby-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .failover-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .failover-hints {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            font-size: 0.7rem;
        }

        .failover-hints .hint {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }

        .failover-hints .switchover-hint {
            color: rgba(0, 237, 100, 0.6);
        }

        .failover-hints .failover-hint {
            color: rgba(255, 200, 0, 0.6);
        }

        .failover-hints .splitover-hint {
            color: rgba(255, 107, 107, 0.6);
        }

        .standby-btn.active-failure {
            background: rgba(239, 71, 111, 0.3) !important;
            border-color: var(--node-down) !important;
            color: var(--node-down) !important;
        }

        .standby-status-panel {
            background: rgba(0, 30, 43, 0.8);
            border-radius: 10px;
            padding: 14px 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .status-value {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .status-value.healthy {
            color: var(--mongo-green);
        }

        .status-value.down {
            color: var(--node-down);
        }

        .status-value.syncing {
            color: var(--node-recovering);
        }

        .status-value.paused {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Region failure visual states */
        .standby-region.region-down {
            opacity: 0.5;
            filter: grayscale(0.5);
        }

        .standby-region.region-down .region-header {
            background: rgba(239, 71, 111, 0.3) !important;
            border-color: var(--node-down) !important;
        }

        .standby-region.region-down .region-status {
            color: var(--node-down);
        }

        .standby-region.region-down::after {
            content: 'âŒ REGION DOWN';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 71, 111, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 1rem;
            z-index: 10;
            animation: pulseDown 1.5s ease-in-out infinite;
        }

        .standby-region {
            position: relative;
        }

        @keyframes pulseDown {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Failover animation */
        .standby-region.failover-in-progress {
            animation: failoverPulse 0.5s ease-in-out;
        }

        @keyframes failoverPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .cross-region-flow.paused .flow-dot {
            animation-play-state: paused;
            opacity: 0.3;
        }

        .cross-region-flow.reversed .flow-direction-label .arrow-right {
            transform: scaleX(-1);
        }

        .cross-region-flow.reversed .flow-dot {
            animation-direction: reverse;
        }

        /* Failover modal */
        .failover-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 30, 43, 0.98);
            border: 2px solid var(--region-3);
            border-radius: 16px;
            padding: 30px 40px;
            z-index: 1000;
            text-align: center;
            display: none;
            animation: modalIn 0.3s ease-out;
        }

        .failover-modal.visible {
            display: block;
        }

        @keyframes modalIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .failover-modal h3 {
            color: var(--region-3);
            margin: 0 0 16px 0;
            font-size: 1.3rem;
        }

        .failover-modal p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0 0 20px 0;
        }

        .failover-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .failover-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--region-3), var(--mongo-green));
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .failover-steps {
            text-align: left;
            font-size: 0.85rem;
        }

        .failover-step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 0;
            color: rgba(255, 255, 255, 0.5);
        }

        .failover-step.active {
            color: var(--region-3);
        }

        .failover-step.complete {
            color: var(--mongo-green);
        }

        .failover-step-icon {
            width: 20px;
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .shards-container { flex-direction: column; }
            .shard-panel { min-width: 100%; }
            .write-flow-panel { width: 320px; right: 10px; bottom: 10px; }
            .read-flow-panel { width: 340px; left: 10px; bottom: 10px; }
            .shortcuts-help, .shortcuts-toggle, .anim-controls { display: none !important; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon">M</div>
            <div class="logo-text">MongoDB <span>HA Demo</span></div>
        </div>
        <div class="header-controls">
            <code id="header-config" style="background: rgba(0,237,100,0.1); padding: 3px 10px; border-radius: 5px; font-family: 'Source Code Pro', monospace; font-size: 0.75rem;">2 Shards Ã— 3 Nodes</code>
            <div class="cluster-status healthy" id="cluster-status">
                <span class="status-dot"></span>
                <span id="status-text">Healthy</span>
            </div>
        </div>
    </header>

    <main class="main-layout">
        <!-- Topology Type Toggle -->
        <div class="topology-toggle" id="topology-toggle">
            <button class="topology-btn selected" data-type="replica-set">ðŸ“š Replica Set</button>
            <button class="topology-btn" data-type="sharded">ðŸ“¦ Sharded Cluster</button>
            <button class="topology-btn" data-type="standby">ðŸ”„ Standby Cluster <span style="font-size: 0.7rem; background: linear-gradient(135deg, #ff6b6b, #ee5a24); padding: 2px 6px; border-radius: 8px; margin-left: 4px;">BETA</span></button>
        </div>

        <!-- Cluster Configuration Selector -->
        <div class="cluster-selector" id="cluster-selector">
            <!-- Replica Set Options -->
            <div class="cluster-option selected" data-config="rs-single-region" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Single Region RS</span>
                    <span class="cluster-option-badge single">3 Nodes</span>
                </div>
                <div class="cluster-option-desc">Simple 3-node replica set in Region 1. ~1ms latency. Region failure = cluster down.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 3 nodes</span>
                </div>
            </div>
            <div class="cluster-option" data-config="rs-two-region" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Two Region RS</span>
                    <span class="cluster-option-badge multi">3 Nodes</span>
                </div>
                <div class="cluster-option-desc">3-node replica set (2+1) across Region 1/2. ~10ms cross-region latency.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 nodes</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 1 node</span>
                </div>
            </div>
            <div class="cluster-option" data-config="rs-three-region" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Three Region RS</span>
                    <span class="cluster-option-badge multi">5 Nodes</span>
                </div>
                <div class="cluster-option-desc">5-node replica set (2-2-1). Region 3 = P:0 (DR). Survives any single region failure!</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 nodes</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 2 nodes</span>
                    <span class="region-chip region-3">ðŸŸ  Region 3: 1 P:0</span>
                </div>
            </div>
            <div class="cluster-option" data-config="rs-ha-misconception" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">âš ï¸ HA Misconception</span>
                    <span class="cluster-option-badge" style="background: linear-gradient(135deg, #ff6b6b, #ee5a24);">4 Nodes</span>
                </div>
                <div class="cluster-option-desc">Common pitfall: 2+1+read-only (p:0, v:0). If Region 1 fails, no majority! Needs manual promotion.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 nodes</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 1 node + 1 read-only</span>
                </div>
            </div>
            <!-- Sharded Cluster Options (hidden by default) -->
            <div class="cluster-option" data-config="sharded-single-region" data-type="sharded" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Single Region Sharded</span>
                    <span class="cluster-option-badge single">2Ã—3 Nodes</span>
                </div>
                <div class="cluster-option-desc">2 shards Ã— 3 nodes + config servers + mongos in Region 1. No regional redundancy.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: All infrastructure</span>
                </div>
            </div>
            <div class="cluster-option" data-config="sharded-two-region" data-type="sharded" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Two Region Sharded</span>
                    <span class="cluster-option-badge multi">2Ã—3 Nodes</span>
                </div>
                <div class="cluster-option-desc">2 shards Ã— 3 nodes (2+1) + config servers across Region 1/2. ~10ms latency.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 per shard</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 1 per shard</span>
                </div>
            </div>
            <div class="cluster-option" data-config="sharded-three-region" data-type="sharded" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Three Region Sharded</span>
                    <span class="cluster-option-badge multi">2Ã—5 Nodes</span>
                </div>
                <div class="cluster-option-desc">2 shards Ã— 5 nodes (2-2-1). Region 3 = P:0 (DR only). Survives any region failure!</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 per shard</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 2 per shard</span>
                    <span class="region-chip region-3">ðŸŸ  Region 3: 1 P:0</span>
                </div>
            </div>
            <!-- Standby Cluster Option -->
            <div class="cluster-option" data-config="standby-cluster" data-type="standby" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Active-Standby Cluster</span>
                    <span class="cluster-option-badge" style="background: linear-gradient(135deg, #ff9100, #ffd166); color: #001E2B;">Manual Failover</span>
                </div>
                <div class="cluster-option-desc">Two independent clusters with async oplog replication. Local reads & writes in both regions. Manual failover required.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Active: Full R/W</span>
                    <span class="region-chip region-2">ðŸŸ¢ Standby: Local R/W + Sync</span>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel" id="info-panel">
            <div class="info-icon">ðŸ’¡</div>
            <div class="info-content">
                <div class="info-title">Single Region Configuration</div>
                <div class="info-desc">All 3 nodes in Virginia (~1ms latency). If the region fails, the entire cluster goes down. Majority required: 2 nodes.</div>
            </div>
        </div>
        <div id="node-click-tip" style="text-align: center; margin-bottom: 16px; font-size: 0.8rem; color: rgba(255,255,255,0.5);">
            <span style="background: rgba(0,237,100,0.1); padding: 4px 12px; border-radius: 12px; border: 1px dashed rgba(0,237,100,0.3);">
                ðŸ‘† <strong>Tip:</strong> Click on any node to simulate failure/recovery
            </span>
        </div>

        <!-- Top Controls -->
        <div class="top-section">
            <div class="control-card">
                <div class="control-title">âš¡ Operations</div>
                <div class="action-buttons">
                    <button class="action-btn primary" onclick="simulateInsert()">âž• Insert</button>
                    <button class="action-btn primary" onclick="simulateUpdate()">âœï¸ Update</button>
                    <button class="action-btn secondary" onclick="simulateRead()">ðŸ“– Read</button>
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸ‡ºðŸ‡¸ Region Failure</div>
                <div class="action-buttons" id="region-buttons">
                    <!-- Dynamically populated -->
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸ“ Write Concern</div>
                <div class="wc-pills" id="wc-pills">
                    <div class="wc-pill" data-value="1" title="Primary only">w:1</div>
                    <div class="wc-pill selected" data-value="majority" title="n/2+1 nodes">w:majority</div>
                    <div class="wc-pill" data-value="all" title="All nodes">w:all</div>
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸ“š Read Preference</div>
                <select class="read-pref-select" id="read-preference">
                    <option value="primary">primary</option>
                    <option value="primaryPreferred">primaryPreferred</option>
                    <option value="secondary">secondary</option>
                    <option value="secondaryPreferred" selected>secondaryPreferred</option>
                    <option value="nearest">nearest</option>
                </select>
            </div>
            <div class="control-card sharded-only" id="target-shard-card" style="display: none;">
                <div class="control-title">ðŸ“¦ Target Shard</div>
                <select class="read-pref-select" id="target-shard">
                    <option value="auto" selected>Auto (random)</option>
                    <!-- Populated dynamically -->
                </select>
            </div>
            <div class="control-card sharded-only" id="request-region-card" style="display: none;">
                <div class="control-title">ðŸ“ Request Region</div>
                <select class="read-pref-select" id="request-region">
                    <option value="auto" selected>Auto (any available)</option>
                    <!-- Populated dynamically -->
                </select>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸŽ® Cluster</div>
                <div class="action-buttons">
                    <button class="action-btn danger" onclick="killRandomPrimary()">ðŸ’¥ Kill Primary</button>
                    <button class="action-btn secondary" onclick="resetCluster()">ðŸ”„ Reset</button>
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸŽ¬ Demo</div>
                <button class="auto-demo-btn" id="auto-demo-btn" onclick="toggleAutoDemo()">
                    <span class="demo-icon">â–¶ï¸</span>
                    <span id="demo-btn-text">Auto Demo</span>
                </button>
            </div>
        </div>

        <!-- Statistics Dashboard -->
        <div class="stats-dashboard" id="stats-dashboard">
            <div class="stat-card">
                <div class="stat-value" id="stat-writes">0</div>
                <div class="stat-label">Writes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-reads">0</div>
                <div class="stat-label">Reads</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-failed">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-elections">0</div>
                <div class="stat-label">Elections</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-avg-latency">0<span style="font-size: 0.8rem;">ms</span></div>
                <div class="stat-label">Avg Latency</div>
            </div>
        </div>

        <!-- Connection String Panel -->
        <div class="conn-string-panel" id="conn-string-panel">
            <div class="conn-string-title">ðŸ”— Connection String</div>
            <div class="conn-string-code" id="conn-string" onclick="copyConnectionString()">
                mongodb+srv://&lt;username&gt;:&lt;password&gt;@rs0-single.mongodb.net/?retryWrites=true&w=majority&readPreference=secondaryPreferred
            </div>
        </div>

        <!-- Mongos Layer -->
        <div class="mongos-layer">
            <div class="layer-title">ðŸ”€ Query Routers (mongos)</div>
            <div class="mongos-grid" id="mongos-container"></div>
        </div>

        <!-- Config Servers Layer -->
        <div class="config-layer">
            <div class="layer-title">âš™ï¸ Config Servers (CSRS)</div>
            <div class="config-grid" id="config-container"></div>
        </div>

        <!-- Shards Container (Sharded Cluster) -->
        <div class="shards-container" id="shards-container">
            <!-- Dynamically populated -->
        </div>

        <!-- Replica Set Container (Non-Sharded) -->
        <div class="rs-container" id="rs-container" style="display: none;">
            <!-- Dynamically populated -->
        </div>

        <!-- Standby Cluster Container (Beta) -->
        <div class="standby-cluster-container" id="standby-cluster-container" style="display: none;">
            <div class="standby-cluster-header">
                <h2 class="standby-title">ðŸ”„ Active-Standby Cluster Architecture <span class="beta-badge">BETA</span></h2>
                <p class="standby-subtitle">Async oplog replication via cloud storage â€¢ Local reads & writes â€¢ <strong>Manual failover</strong></p>
            </div>

            <div class="standby-note">
                <span class="note-icon">ðŸ“‹</span>
                <div class="note-content">
                    <strong>NOTE:</strong> This is for deployments in regions or on-prem where 3-region deployments are not possible, or where cross-region latency is not acceptable to achieve consistency and durability.
                </div>
            </div>
            
            <div class="standby-benefits">
                <div class="benefit-card">
                    <div class="benefit-icon">âš¡</div>
                    <div class="benefit-text">
                        <strong>Local Writes & Reads</strong>
                        <span>Low latency operations in both regions</span>
                    </div>
                </div>
                <div class="benefit-card">
                    <div class="benefit-icon">ðŸŒ</div>
                    <div class="benefit-text">
                        <strong>Multi-Region DR</strong>
                        <span>Full cluster standby in separate region</span>
                    </div>
                </div>
                <div class="benefit-card warning">
                    <div class="benefit-icon">âš ï¸</div>
                    <div class="benefit-text">
                        <strong>Manual Failover</strong>
                        <span>Requires operator intervention to switch</span>
                    </div>
                </div>
            </div>

            <!-- Active Cluster Operations -->
            <div class="standby-operations">
                <div class="standby-control-group">
                    <div class="control-label">âš¡ Operations (Active Cluster)</div>
                    <div class="standby-buttons">
                        <button class="standby-btn primary-op" onclick="standbyInsert()">âž• Insert</button>
                        <button class="standby-btn primary-op" onclick="standbyUpdate()">âœï¸ Update</button>
                        <button class="standby-btn secondary-op" onclick="standbyRead()">ðŸ“– Read</button>
                    </div>
                </div>
                <div class="standby-control-group">
                    <div class="control-label">ðŸ“ Write Concern</div>
                    <div class="wc-pills standby-wc" id="standby-wc-pills">
                        <div class="wc-pill" data-value="1">w:1</div>
                        <div class="wc-pill selected" data-value="majority">w:majority</div>
                        <div class="wc-pill" data-value="all">w:all</div>
                    </div>
                </div>
                <div class="standby-control-group">
                    <div class="control-label">ðŸ“š Read Preference</div>
                    <select class="standby-select" id="standby-read-pref">
                        <option value="primary">primary</option>
                        <option value="primaryPreferred">primaryPreferred</option>
                        <option value="secondary">secondary</option>
                        <option value="secondaryPreferred" selected>secondaryPreferred</option>
                        <option value="nearest">nearest</option>
                    </select>
                </div>
            </div>

            <div class="standby-node-tip">
                ðŸ‘† <strong>Tip:</strong> Click on any node in the active cluster to simulate failure/recovery
            </div>

            <!-- Standby Controls -->
            <div class="standby-controls">
                <div class="standby-control-group">
                    <div class="control-label">ðŸ’¥ Region Actions</div>
                    <div class="standby-buttons">
                        <button class="standby-btn region-active" id="kill-left-btn" onclick="killRegion('left')">
                            <span class="btn-icon">ðŸ’¥</span>
                            <span id="kill-left-label">Kill Left Region</span>
                        </button>
                        <button class="standby-btn restore" id="restore-left-btn" onclick="restoreRegion('left')" style="display: none;">
                            <span class="btn-icon">ðŸ”§</span>
                            <span>Restore Left</span>
                        </button>
                        <button class="standby-btn region-standby" id="kill-right-btn" onclick="killRegion('right')">
                            <span class="btn-icon">ðŸ’¥</span>
                            <span id="kill-right-label">Kill Right Region</span>
                        </button>
                        <button class="standby-btn restore" id="restore-right-btn" onclick="restoreRegion('right')" style="display: none;">
                            <span class="btn-icon">ðŸ”§</span>
                            <span>Restore Right</span>
                        </button>
                        <button class="standby-btn reset" id="reset-standby-btn" onclick="resetStandbyRegions()">
                            <span class="btn-icon">ðŸ”„</span>
                            <span>Reset All</span>
                        </button>
                    </div>
                </div>
                <div class="standby-control-group failover-controls">
                    <div class="control-label">ðŸ”„ Cluster Operations</div>
                    <div class="standby-buttons failover-buttons">
                        <button class="standby-btn switchover" id="switchover-btn" onclick="initiateSwitchover()" title="Planned switch - locks active, syncs, then switches roles">
                            <span class="btn-icon">ðŸ”„</span>
                            <span>Switch Active Region</span>
                        </button>
                        <button class="standby-btn failover" id="failover-btn" onclick="initiateFailover()" title="Emergency failover - promotes standby immediately">
                            <span class="btn-icon">âš¡</span>
                            <span>Failover</span>
                        </button>
                        <button class="standby-btn splitover" id="splitover-btn" onclick="initiateSplitover()" title="Split clusters - both become independent">
                            <span class="btn-icon">âœ‚ï¸</span>
                            <span>Split Clusters</span>
                        </button>
                        <button class="standby-btn setup-standby" id="setup-standby-btn" onclick="setupStandby()" title="Re-establish standby relationship" style="display: none;">
                            <span class="btn-icon">ðŸ”—</span>
                            <span>Setup Standby</span>
                        </button>
                    </div>
                    <div class="failover-hints">
                        <span class="hint switchover-hint" id="switchover-hint">Switch Active Region: Both regions must be healthy</span>
                        <span class="hint failover-hint" id="failover-hint">Failover: Requires one region to be down</span>
                        <span class="hint splitover-hint" id="splitover-hint">Split Clusters: Both become independent</span>
                    </div>
                </div>
                <div class="standby-status-panel" id="standby-status-panel">
                    <div class="status-item">
                        <span class="status-label">Left Region:</span>
                        <span class="status-value healthy" id="left-region-status">â— Active</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Right Region:</span>
                        <span class="status-value healthy" id="right-region-status">â— Standby</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Replication:</span>
                        <span class="status-value syncing" id="replication-status">âŸ³ Syncing</span>
                    </div>
                </div>
            </div>

            <div class="standby-diagram">
                <!-- Active Region -->
                <div class="standby-region active-region">
                    <div class="region-header active">
                        <span class="region-icon">ðŸ”µ</span>
                        <span class="region-name">ACTIVE REGION</span>
                        <span class="region-status">â— Primary</span>
                    </div>
                    
                    <div class="region-components">
                        <!-- Outgoing oplog indicator (shown when this is active) -->
                        <div class="blob-output-arrow" id="left-blob-output">
                            <span class="output-label">push oplog â†’</span>
                        </div>
                        
                        <!-- Top Row: Storage + Control Plane -->
                        <div class="region-top-row">
                            <div class="cloud-storage receiving" id="left-cloud-storage">
                                <div class="storage-icon">â˜ï¸</div>
                                <div class="storage-details">
                                    <div class="storage-name">S3 / Azure Blob / GCS</div>
                                    <div class="storage-items">
                                        <span class="storage-item">ðŸ“„ Oplog Store</span>
                                        <span class="storage-item">ðŸ”— Cluster Link State</span>
                                    </div>
                                </div>
                            </div>
                            <div class="control-plane">
                                <div class="control-icon">ðŸŽ›ï¸</div>
                                <span>Failover Control API</span>
                            </div>
                        </div>
                        
                        <!-- Incoming oplog indicator (shown when this is standby) -->
                        <div class="blob-input-arrow" id="left-blob-input" style="display: none;">
                            <span class="input-label">â† receives oplog</span>
                        </div>
                        
                        <!-- Pull from Storage Arrow (shown when standby) -->
                        <div class="vertical-flow-section" id="left-storage-pull" style="display: none;">
                            <div class="flow-arrow-vertical down">
                                <span class="arrow-label">pull oplog â†“</span>
                                <span class="arrow-line"></span>
                            </div>
                        </div>
                        
                        <!-- Coordinator (shown when standby) -->
                        <div class="coordinator-box" id="left-coordinator" style="display: none;">
                            <span class="coordinator-icon">ðŸŽ¯</span>
                            <span class="coordinator-label">Injection Coordinator</span>
                        </div>
                        
                        <!-- Injectors Layer (shown when standby) -->
                        <div class="injectors-layer" id="left-injectors" style="display: none;">
                            <div class="layer-label">INJECTORS</div>
                            <div class="injectors-row">
                                <div class="injector-unit">
                                    <span class="injector-flow-label">pull oplog</span>
                                    <div class="injector-box">
                                        <span class="injector-icon">ðŸ“¥</span>
                                        <span class="injector-label">Injector</span>
                                    </div>
                                </div>
                                <div class="injector-unit">
                                    <span class="injector-flow-label">pull oplog</span>
                                    <div class="injector-box">
                                        <span class="injector-icon">ðŸ“¥</span>
                                        <span class="injector-label">Injector</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Push to Cluster Arrow (shown when standby) -->
                        <div class="vertical-flow-section" id="left-injector-push" style="display: none;">
                            <div class="flow-arrow-vertical down">
                                <span class="arrow-line"></span>
                                <span class="arrow-label">push oplog â†“</span>
                            </div>
                        </div>

                        <!-- Active Cluster at top -->
                        <div class="cluster-box active-cluster" id="left-cluster">
                            <div class="cluster-label">ACTIVE CLUSTER</div>
                            <div class="shards-row">
                                <div class="shard-box" data-shard="0">
                                    <div class="shard-label">Shard 0</div>
                                    <div class="shard-nodes" id="left-shard-0-nodes">
                                        <div class="mini-node primary clickable" id="left-s0-n0" data-shard="0" data-node="0" onclick="toggleStandbyNode('left', 0, 0)" title="Click to fail/recover">
                                            <span class="node-letter">P</span>
                                        </div>
                                        <div class="mini-node secondary clickable" id="left-s0-n1" data-shard="0" data-node="1" onclick="toggleStandbyNode('left', 0, 1)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                        <div class="mini-node secondary clickable" id="left-s0-n2" data-shard="0" data-node="2" onclick="toggleStandbyNode('left', 0, 2)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="shard-box" data-shard="1">
                                    <div class="shard-label">Shard 1</div>
                                    <div class="shard-nodes" id="left-shard-1-nodes">
                                        <div class="mini-node primary clickable" id="left-s1-n0" data-shard="1" data-node="0" onclick="toggleStandbyNode('left', 1, 0)" title="Click to fail/recover">
                                            <span class="node-letter">P</span>
                                        </div>
                                        <div class="mini-node secondary clickable" id="left-s1-n1" data-shard="1" data-node="1" onclick="toggleStandbyNode('left', 1, 1)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                        <div class="mini-node secondary clickable" id="left-s1-n2" data-shard="1" data-node="2" onclick="toggleStandbyNode('left', 1, 2)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Pull from Cluster Arrow (shown when active) -->
                        <div class="vertical-flow-section" id="left-cluster-pull">
                            <div class="flow-arrow-vertical down">
                                <span class="arrow-label">pull oplog â†“</span>
                                <span class="arrow-line"></span>
                            </div>
                        </div>

                        <!-- Shippers Layer - pushes to standby blob -->
                        <div class="shippers-layer" id="left-shippers">
                            <div class="layer-label">SHIPPERS</div>
                            <div class="shippers-row">
                                <div class="shipper-unit">
                                    <div class="shipper-box">
                                        <span class="shipper-icon">ðŸ“¤</span>
                                        <span class="shipper-label">Shipper</span>
                                    </div>
                                </div>
                                <div class="shipper-unit">
                                    <div class="shipper-box">
                                        <span class="shipper-icon">ðŸ“¤</span>
                                        <span class="shipper-label">Shipper</span>
                                    </div>
                                </div>
                            </div>
                            <div class="shipper-output-arrow">
                                <span class="output-label">push oplog â†’</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Cross-Region Data Flow (Center) -->
                <div class="cross-region-flow" id="cross-region-flow">
                    <div class="cross-region-label">CROSS-REGION<br/>OPLOG SYNC</div>
                    <div class="flow-lines-container">
                        <div class="flow-line-horizontal">
                            <span class="flow-dot"></span>
                            <span class="flow-dot delay-1"></span>
                            <span class="flow-dot delay-2"></span>
                        </div>
                        <div class="flow-direction-label" id="flow-direction-label">
                            <span class="flow-desc" id="flow-desc">push oplog to<br/>standby blob store</span>
                            <span class="arrow-right" id="arrow-direction">â†’â†’â†’</span>
                        </div>
                    </div>
                </div>

                <!-- Standby Region -->
                <div class="standby-region standby-region-box">
                    <div class="region-header standby">
                        <span class="region-icon">ðŸŸ¢</span>
                        <span class="region-name">STANDBY REGION</span>
                        <span class="region-status">â—‹ Standby</span>
                    </div>
                    
                    <div class="region-components">
                        <!-- Outgoing oplog indicator (shown when this is active) -->
                        <div class="blob-output-arrow" id="right-blob-output" style="display: none;">
                            <span class="output-label">â† push oplog</span>
                        </div>
                        
                        <!-- Incoming oplog indicator (shown when this is standby) -->
                        <div class="blob-input-arrow" id="right-blob-input">
                            <span class="input-label">â† receives oplog</span>
                        </div>
                        
                        <!-- Top Row: Storage + Control Plane -->
                        <div class="region-top-row">
                            <div class="cloud-storage receiving" id="right-cloud-storage">
                                <div class="storage-icon">â˜ï¸</div>
                                <div class="storage-details">
                                    <div class="storage-name">S3 / Azure Blob / GCS</div>
                                    <div class="storage-items">
                                        <span class="storage-item">ðŸ“„ Oplog Store</span>
                                        <span class="storage-item">ðŸ”— Cluster Link State</span>
                                    </div>
                                </div>
                            </div>
                            <div class="control-plane">
                                <div class="control-icon">ðŸŽ›ï¸</div>
                                <span>Failover Control API</span>
                            </div>
                        </div>

                        <!-- Pull from Storage Arrow (shown when standby) -->
                        <div class="vertical-flow-section" id="right-storage-pull">
                            <div class="flow-arrow-vertical down">
                                <span class="arrow-label">pull oplog â†“</span>
                                <span class="arrow-line"></span>
                            </div>
                        </div>

                        <!-- Injection Coordinator (shown when standby) -->
                        <div class="coordinator-box" id="right-coordinator">
                            <span class="coordinator-icon">ðŸŽ¯</span>
                            <span class="coordinator-label">Injection Coordinator</span>
                        </div>

                        <!-- Injectors Layer (shown when standby) -->
                        <div class="injectors-layer" id="right-injectors">
                            <div class="layer-label">INJECTORS</div>
                            <div class="injectors-row">
                                <div class="injector-unit">
                                    <span class="injector-flow-label">pull oplog</span>
                                    <div class="injector-box">
                                        <span class="injector-icon">ðŸ“¥</span>
                                        <span class="injector-label">Injector</span>
                                    </div>
                                </div>
                                <div class="injector-unit">
                                    <span class="injector-flow-label">pull oplog</span>
                                    <div class="injector-box">
                                        <span class="injector-icon">ðŸ“¥</span>
                                        <span class="injector-label">Injector</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Push to Cluster Arrow (shown when standby) -->
                        <div class="vertical-flow-section" id="right-injector-push">
                            <div class="flow-arrow-vertical down">
                                <span class="arrow-line"></span>
                                <span class="arrow-label">push oplog â†“</span>
                            </div>
                        </div>

                        <!-- Cluster -->
                        <div class="cluster-box standby-cluster" id="right-cluster">
                            <div class="cluster-label">STANDBY CLUSTER</div>
                            <div class="cluster-sublabel">(All Secondaries)</div>
                            <div class="shards-row">
                                <div class="shard-box" data-shard="0">
                                    <div class="shard-label">Shard 0</div>
                                    <div class="shard-nodes" id="right-shard-0-nodes">
                                        <div class="mini-node secondary standby-node clickable" id="right-s0-n0" data-shard="0" data-node="0" onclick="toggleStandbyNode('right', 0, 0)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                        <div class="mini-node secondary standby-node clickable" id="right-s0-n1" data-shard="0" data-node="1" onclick="toggleStandbyNode('right', 0, 1)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                        <div class="mini-node secondary standby-node clickable" id="right-s0-n2" data-shard="0" data-node="2" onclick="toggleStandbyNode('right', 0, 2)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="shard-box" data-shard="1">
                                    <div class="shard-label">Shard 1</div>
                                    <div class="shard-nodes" id="right-shard-1-nodes">
                                        <div class="mini-node secondary standby-node clickable" id="right-s1-n0" data-shard="1" data-node="0" onclick="toggleStandbyNode('right', 1, 0)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                        <div class="mini-node secondary standby-node clickable" id="right-s1-n1" data-shard="1" data-node="1" onclick="toggleStandbyNode('right', 1, 1)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                        <div class="mini-node secondary standby-node clickable" id="right-s1-n2" data-shard="1" data-node="2" onclick="toggleStandbyNode('right', 1, 2)" title="Click to fail/recover">
                                            <span class="node-letter">S</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Pull from Cluster Arrow (shown when active) -->
                        <div class="vertical-flow-section" id="right-cluster-pull" style="display: none;">
                            <div class="flow-arrow-vertical down">
                                <span class="arrow-label">pull oplog â†“</span>
                                <span class="arrow-line"></span>
                            </div>
                        </div>

                        <!-- Shippers Layer (shown when active) -->
                        <div class="shippers-layer" id="right-shippers" style="display: none;">
                            <div class="layer-label">SHIPPERS</div>
                            <div class="shippers-row">
                                <div class="shipper-unit">
                                    <div class="shipper-box">
                                        <span class="shipper-icon">ðŸ“¤</span>
                                        <span class="shipper-label">Shipper</span>
                                    </div>
                                </div>
                                <div class="shipper-unit">
                                    <div class="shipper-box">
                                        <span class="shipper-icon">ðŸ“¤</span>
                                        <span class="shipper-label">Shipper</span>
                                    </div>
                                </div>
                            </div>
                            <div class="shipper-output-arrow">
                                <span class="output-label">â† push oplog</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="standby-flow-explanation">
                <h3>ðŸ“Š How Data Flows</h3>
                <div class="flow-steps">
                    <div class="flow-step">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <strong>Writes to Active Cluster</strong>
                            <p>Applications write to the active cluster with full local latency benefits</p>
                        </div>
                    </div>
                    <div class="flow-step">
                        <div class="step-number">2</div>
                        <div class="step-content">
                            <strong>Shipper Pulls Oplog</strong>
                            <p>Shippers continuously pull oplog entries from each shard's primary</p>
                        </div>
                    </div>
                    <div class="flow-step">
                        <div class="step-number">3</div>
                        <div class="step-content">
                            <strong>Push to Cloud Storage</strong>
                            <p>Oplog data is pushed to cloud storage (S3/Azure Blob/GCS) for durability</p>
                        </div>
                    </div>
                    <div class="flow-step">
                        <div class="step-number">4</div>
                        <div class="step-content">
                            <strong>Coordinator Pulls Oplog</strong>
                            <p>Injection Coordinator in standby region pulls oplog from cloud storage</p>
                        </div>
                    </div>
                    <div class="flow-step">
                        <div class="step-number">5</div>
                        <div class="step-content">
                            <strong>Injectors Apply to Standby</strong>
                            <p>Injectors apply oplog entries to standby cluster nodes asynchronously</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="failover-callout">
                <div class="callout-icon">âš ï¸</div>
                <div class="callout-content">
                    <strong>Manual Failover Required</strong>
                    <p>Unlike traditional replica sets, failover between active and standby clusters requires manual intervention through the Regional Failover Control API. This is intentional to prevent split-brain scenarios and ensure data consistency during region failures.</p>
                </div>
            </div>

            <!-- Failover Modal -->
            <div class="failover-modal" id="failover-modal">
                <h3>ðŸ”„ Manual Failover in Progress</h3>
                <p id="failover-modal-text">Switching from Active to Standby region...</p>
                <div class="failover-progress">
                    <div class="failover-progress-bar" id="failover-progress-bar" style="width: 0%"></div>
                </div>
                <div class="failover-steps" id="failover-steps">
                    <div class="failover-step" data-step="1">
                        <span class="failover-step-icon">â³</span>
                        <span>Stop writes to active cluster</span>
                    </div>
                    <div class="failover-step" data-step="2">
                        <span class="failover-step-icon">â³</span>
                        <span>Drain oplog queue</span>
                    </div>
                    <div class="failover-step" data-step="3">
                        <span class="failover-step-icon">â³</span>
                        <span>Apply remaining oplogs to standby</span>
                    </div>
                    <div class="failover-step" data-step="4">
                        <span class="failover-step-icon">â³</span>
                        <span>Promote standby to active</span>
                    </div>
                    <div class="failover-step" data-step="5">
                        <span class="failover-step-icon">â³</span>
                        <span>Update DNS / connection strings</span>
                    </div>
                    <div class="failover-step" data-step="6" style="display: none;">
                        <span class="failover-step-icon">â³</span>
                        <span>Reconfigure DNS settings</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Event Log -->
        <div class="event-log-panel">
            <div class="event-log-title">ðŸ“‹ Event Log</div>
            <div class="event-log" id="event-log"></div>
        </div>
    </main>

    <!-- Replication Flow Overlay -->
    <div class="replication-overlay" id="replication-overlay"></div>

    <!-- Write Flow Status Panel -->
    <div class="write-flow-panel" id="write-flow-panel">
        <div class="write-flow-header">
            <div class="write-flow-title">âœï¸ Write Operation</div>
            <div class="write-flow-wc" id="flow-wc">w:majority</div>
        </div>
        <div class="write-flow-steps" id="write-flow-steps">
            <!-- Steps populated dynamically -->
        </div>
        <div class="write-flow-result" id="write-flow-result"></div>
    </div>

    <!-- Read Flow Status Panel -->
    <div class="read-flow-panel" id="read-flow-panel">
        <div class="read-flow-header">
            <div class="read-flow-title">ðŸ“– Read Operation</div>
            <div class="read-flow-pref" id="flow-read-pref">secondaryPreferred</div>
        </div>
        <div class="read-flow-content">
            <div class="read-flow-nodes" id="read-flow-nodes">
                <!-- Available nodes populated dynamically -->
            </div>
            <div class="read-flow-selection" id="read-flow-selection">
                <!-- Selected node shown here -->
            </div>
        </div>
        <div class="read-flow-result" id="read-flow-result"></div>
    </div>

    <!-- Election Modal -->
    <div class="modal-overlay" id="election-modal">
        <div class="modal">
            <div class="modal-icon">ðŸ—³ï¸</div>
            <div class="modal-title">Election in Progress</div>
            <div class="modal-text" id="election-text">Primary node is down. Initiating automatic failover...</div>
            <div class="election-progress">
                <div class="election-progress-bar" id="election-progress"></div>
            </div>
            <div id="election-status">Detecting failure...</div>
        </div>
    </div>

    <script>
        // ============ CLUSTER CONFIGURATIONS ============
        const CLUSTER_CONFIGS = {
            // ========== REPLICA SET CONFIGURATIONS ==========
            'rs-single-region': {
                name: 'Single Region Replica Set',
                description: 'Simple 3-node replica set in Region 1 (~1ms latency). If region fails, entire cluster goes down. Majority required: 2 nodes.',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' }
                ],
                nodes: [
                    { id: 'rs-n1', name: 'mongo-1', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-n2', name: 'mongo-2', region: 'region-1', priority: 1, votes: 1 },
                    { id: 'rs-n3', name: 'mongo-3', region: 'region-1', priority: 1, votes: 1 }
                ]
            },
            'rs-two-region': {
                name: 'Two Region Replica Set',
                description: '3-node replica set (2+1) across Region 1 and Region 2. ~10ms cross-region latency.',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' }
                ],
                nodes: [
                    { id: 'rs-r1-1', name: 'mongo-r1-1', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-r1-2', name: 'mongo-r1-2', region: 'region-1', priority: 1, votes: 1 },
                    { id: 'rs-r2', name: 'mongo-r2', region: 'region-2', priority: 1, votes: 1 }
                ]
            },
            'rs-three-region': {
                name: 'Three Region Replica Set',
                description: '5-node replica set (2-2-1). Region 1 â†” Region 2 ~10ms, Region 1/2 â†” Region 3 ~70ms. Region 3 = P:0 (DR).',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' },
                    { id: 'region-3', name: 'Region 3', icon: 'ðŸŸ ', latency: '~70ms' }
                ],
                nodes: [
                    { id: 'rs-r1-1', name: 'mongo-r1-1', region: 'region-1', priority: 3, votes: 1 },
                    { id: 'rs-r1-2', name: 'mongo-r1-2', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-r2-1', name: 'mongo-r2-1', region: 'region-2', priority: 1, votes: 1 },
                    { id: 'rs-r2-2', name: 'mongo-r2-2', region: 'region-2', priority: 1, votes: 1 },
                    { id: 'rs-r3', name: 'mongo-r3', region: 'region-3', priority: 0, votes: 1 }
                ]
            },
            'rs-ha-misconception': {
                name: 'âš ï¸ HA Misconception',
                description: 'Common pitfall: 4 nodes (2+1+read-only) but read-only node has votes:0. If Region 1 fails, only 1 vote remains - no majority (need 2)! Read-only nodes do NOT help with HA.',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' }
                ],
                nodes: [
                    { id: 'rs-r1-1', name: 'mongo-r1-1', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-r1-2', name: 'mongo-r1-2', region: 'region-1', priority: 1, votes: 1 },
                    { id: 'rs-r2-1', name: 'mongo-r2-1', region: 'region-2', priority: 1, votes: 1 },
                    { id: 'rs-r2-read', name: 'read-only', region: 'region-2', priority: 0, votes: 0, isReadReplica: true }
                ]
            },
            // ========== SHARDED CLUSTER CONFIGURATIONS ==========
            'sharded-single-region': {
                name: 'Single Region Sharded',
                description: 'All nodes in Region 1 (~1ms latency). 2 shards Ã— 3 nodes + config servers + mongos. If region fails, entire cluster is down.',
                isSharded: true,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' }
                ],
                mongos: [
                    { id: 'mongos-r1-1', region: 'region-1' },
                    { id: 'mongos-r1-2', region: 'region-1' },
                    { id: 'mongos-r1-3', region: 'region-1' }
                ],
                configServers: [
                    { id: 'cfg-1', name: 'config-1', region: 'region-1', priority: 2 },
                    { id: 'cfg-2', name: 'config-2', region: 'region-1', priority: 1 },
                    { id: 'cfg-3', name: 'config-3', region: 'region-1', priority: 1 }
                ],
                shards: [
                    {
                        id: 'shard0', name: 'shard0',
                        nodes: [
                            { id: 's0-n1', name: 's0-r1-1', region: 'region-1', priority: 2 },
                            { id: 's0-n2', name: 's0-r1-2', region: 'region-1', priority: 1 },
                            { id: 's0-n3', name: 's0-r1-3', region: 'region-1', priority: 1 }
                        ]
                    },
                    {
                        id: 'shard1', name: 'shard1',
                        nodes: [
                            { id: 's1-n1', name: 's1-r1-1', region: 'region-1', priority: 2 },
                            { id: 's1-n2', name: 's1-r1-2', region: 'region-1', priority: 1 },
                            { id: 's1-n3', name: 's1-r1-3', region: 'region-1', priority: 1 }
                        ]
                    }
                ]
            },
            'sharded-two-region': {
                name: 'Two Region Sharded',
                description: 'Region 1 â†” Region 2 (~10ms latency). 2 shards Ã— 3 nodes (2+1) + 3 mongos + config servers.',
                isSharded: true,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' }
                ],
                mongos: [
                    { id: 'mongos-r1-1', region: 'region-1' },
                    { id: 'mongos-r1-2', region: 'region-1' },
                    { id: 'mongos-r2', region: 'region-2' }
                ],
                configServers: [
                    { id: 'cfg-r1-1', name: 'config-r1-1', region: 'region-1', priority: 2 },
                    { id: 'cfg-r1-2', name: 'config-r1-2', region: 'region-1', priority: 1 },
                    { id: 'cfg-r2', name: 'config-r2', region: 'region-2', priority: 1 }
                ],
                shards: [
                    {
                        id: 'shard0', name: 'shard0', preferredRegion: 'region-1',
                        nodes: [
                            { id: 's0-r1-1', name: 's0-r1-1', region: 'region-1', priority: 2 },
                            { id: 's0-r1-2', name: 's0-r1-2', region: 'region-1', priority: 1 },
                            { id: 's0-r2', name: 's0-r2', region: 'region-2', priority: 1 }
                        ]
                    },
                    {
                        id: 'shard1', name: 'shard1', preferredRegion: 'region-2',
                        nodes: [
                            { id: 's1-r2-1', name: 's1-r2-1', region: 'region-2', priority: 2 },
                            { id: 's1-r2-2', name: 's1-r2-2', region: 'region-2', priority: 1 },
                            { id: 's1-r1', name: 's1-r1', region: 'region-1', priority: 1 }
                        ]
                    }
                ]
            },
            'sharded-three-region': {
                name: 'Three Region Sharded',
                description: 'Region 1 â†” Region 2 (~10ms), Region 1/2 â†” Region 3 (~70ms). 2 shards Ã— 5 nodes (2-2-1). Region 3 = Priority 0 (DR).',
                isSharded: true,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' },
                    { id: 'region-3', name: 'Region 3', icon: 'ðŸŸ ', latency: '~70ms' }
                ],
                mongos: [
                    { id: 'mongos-r1', region: 'region-1' },
                    { id: 'mongos-r2', region: 'region-2' },
                    { id: 'mongos-r3', region: 'region-3' }
                ],
                configServers: [
                    { id: 'cfg-r1', name: 'config-r1', region: 'region-1', priority: 2 },
                    { id: 'cfg-r2', name: 'config-r2', region: 'region-2', priority: 1 },
                    { id: 'cfg-r3', name: 'config-r3', region: 'region-3', priority: 0 }
                ],
                shards: [
                    {
                        id: 'shard0', name: 'shard0', preferredRegion: 'region-1',
                        nodes: [
                            { id: 's0-r1-1', name: 's0-r1-1', region: 'region-1', priority: 3 },
                            { id: 's0-r1-2', name: 's0-r1-2', region: 'region-1', priority: 2 },
                            { id: 's0-r2-1', name: 's0-r2-1', region: 'region-2', priority: 1 },
                            { id: 's0-r2-2', name: 's0-r2-2', region: 'region-2', priority: 1 },
                            { id: 's0-r3', name: 's0-r3', region: 'region-3', priority: 0 }
                        ]
                    },
                    {
                        id: 'shard1', name: 'shard1', preferredRegion: 'region-2',
                        nodes: [
                            { id: 's1-r2-1', name: 's1-r2-1', region: 'region-2', priority: 3 },
                            { id: 's1-r2-2', name: 's1-r2-2', region: 'region-2', priority: 2 },
                            { id: 's1-r1-1', name: 's1-r1-1', region: 'region-1', priority: 1 },
                            { id: 's1-r1-2', name: 's1-r1-2', region: 'region-1', priority: 1 },
                            { id: 's1-r3', name: 's1-r3', region: 'region-3', priority: 0 }
                        ]
                    }
                ]
            },
            // ========== STANDBY CLUSTER CONFIGURATION (BETA) ==========
            'standby-cluster': {
                name: 'Active-Standby Cluster',
                description: 'Two independent clusters with async oplog replication via cloud storage. Local reads & writes in both regions. Manual failover provides multi-region DR capability.',
                isSharded: true,
                isStandby: true,
                regions: [
                    { id: 'region-1', name: 'Active Region', icon: 'ðŸ”µ', latency: '~1ms', role: 'active' },
                    { id: 'region-2', name: 'Standby Region', icon: 'ðŸŸ¢', latency: '~10ms', role: 'standby' }
                ],
                activeCluster: {
                    shards: [
                        {
                            id: 'active-shard0', name: 'Shard 0',
                            nodes: [
                                { id: 'a-s0-n1', name: 'Primary', role: 'primary', priority: 2 },
                                { id: 'a-s0-n2', name: 'Secondary', role: 'secondary', priority: 1 },
                                { id: 'a-s0-n3', name: 'Secondary', role: 'secondary', priority: 1 }
                            ]
                        },
                        {
                            id: 'active-shard1', name: 'Shard 1',
                            nodes: [
                                { id: 'a-s1-n1', name: 'Primary', role: 'primary', priority: 2 },
                                { id: 'a-s1-n2', name: 'Secondary', role: 'secondary', priority: 1 },
                                { id: 'a-s1-n3', name: 'Secondary', role: 'secondary', priority: 1 }
                            ]
                        }
                    ]
                },
                standbyCluster: {
                    shards: [
                        {
                            id: 'standby-shard0', name: 'Shard 0',
                            nodes: [
                                { id: 's-s0-n1', name: 'Primary', role: 'primary', priority: 2 },
                                { id: 's-s0-n2', name: 'Secondary', role: 'secondary', priority: 1 },
                                { id: 's-s0-n3', name: 'Secondary', role: 'secondary', priority: 1 }
                            ]
                        },
                        {
                            id: 'standby-shard1', name: 'Shard 1',
                            nodes: [
                                { id: 's-s1-n1', name: 'Primary', role: 'primary', priority: 2 },
                                { id: 's-s1-n2', name: 'Secondary', role: 'secondary', priority: 1 },
                                { id: 's-s1-n3', name: 'Secondary', role: 'secondary', priority: 1 }
                            ]
                        }
                    ]
                }
            }
        };

        // ============ STATE ============
        const state = {
            currentConfig: 'rs-single-region',
            isSharded: false,
            isStandby: false,
            regions: [],
            regionStatus: {},
            // Replica Set state
            nodes: [],
            // Sharded state
            mongos: [],
            configServers: [],
            shards: [],
            // Routing options (for sharded)
            targetShard: 'auto',
            requestRegion: 'auto',
            // Common
            writeConcern: 'majority',
            readPreference: 'secondaryPreferred',
            oplogCounter: 0,
            isElecting: {},
            electionTerm: 1,
            writeAcknowledged: false,
            // Statistics
            stats: {
                writes: 0,
                reads: 0,
                failed: 0,
                elections: 0,
                latencies: [],
                avgLatency: 0
            },
            // Auto Demo
            demoRunning: false,
            demoStep: 0
        };
        
        // Latency map (in ms) between regions
        const LATENCY_MAP = {
            'region-1': { 'region-1': 1, 'region-2': 10, 'region-3': 70 },
            'region-2': { 'region-1': 10, 'region-2': 1, 'region-3': 70 },
            'region-3': { 'region-1': 70, 'region-2': 70, 'region-3': 1 }
        };

        // ============ HELPERS ============
        function generateObjectId() {
            return [...Array(24)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
        }

        function generateTimestamp() {
            return { t: Math.floor(Date.now() / 1000), i: state.oplogCounter++ };
        }

        function formatTimestamp(ts) {
            return `Timestamp(${ts.t}, ${ts.i})`;
        }

        function getVotingMembers(shardOrNodes) {
            const nodes = shardOrNodes.nodes || shardOrNodes;
            return nodes.filter(n => n.votes !== 0); // votes: 0 means non-voting
        }

        function getMajorityRequired(shardOrNodes) {
            const votingNodes = getVotingMembers(shardOrNodes);
            return Math.floor(votingNodes.length / 2) + 1;
        }

        function getHealthyNodes(shardOrNodes) {
            const nodes = shardOrNodes.nodes || shardOrNodes;
            return nodes.filter(n => n.status === 'healthy' || n.status === 'syncing');
        }

        function getHealthyVoters(shardOrNodes) {
            const nodes = shardOrNodes.nodes || shardOrNodes;
            return nodes.filter(n => (n.status === 'healthy' || n.status === 'syncing') && n.votes !== 0);
        }

        function hasMajority(shardOrNodes) {
            return getHealthyVoters(shardOrNodes).length >= getMajorityRequired(shardOrNodes);
        }

        function getRegionInfo(regionId) {
            return state.regions.find(r => r.id === regionId) || { name: 'Unknown', icon: 'â“' };
        }

        function getRandomCollection() {
            return ['test.users', 'test.orders', 'test.products'][Math.floor(Math.random() * 3)];
        }
        
        // Animation speed multiplier (higher = slower animations)
        let ANIM_SPEED = 2.0;
        const ANIM_SPEEDS = [1.0, 2.0, 3.5]; // Fast, Slow, Slowest
        const SPEED_LABELS = ['âš¡ Fast', 'ðŸ¢ Slow', 'ðŸ¦¥ Slowest'];
        let currentSpeedIndex = 1; // Start at "Slow"
        let isPaused = false;
        let pauseResolvers = [];
        
        function cycleAnimSpeed() {
            currentSpeedIndex = (currentSpeedIndex + 1) % ANIM_SPEEDS.length;
            ANIM_SPEED = ANIM_SPEEDS[currentSpeedIndex];
            updateSpeedDisplay();
            log(`Animation speed: ${SPEED_LABELS[currentSpeedIndex]}`, 'info');
        }
        
        function updateSpeedDisplay() {
            const btn = document.getElementById('speed-btn');
            if (btn) {
                btn.textContent = SPEED_LABELS[currentSpeedIndex];
            }
        }
        
        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pause-btn');
            if (btn) {
                btn.textContent = isPaused ? 'â–¶ï¸ Resume' : 'â¸ï¸ Pause';
                btn.classList.toggle('paused', isPaused);
            }
            log(isPaused ? 'â¸ï¸ Animations PAUSED' : 'â–¶ï¸ Animations RESUMED', 'info');
            
            // Resume any waiting animations
            if (!isPaused) {
                pauseResolvers.forEach(resolve => resolve());
                pauseResolvers = [];
            }
        }
        
        // Check for pause before continuing animations
        async function checkPause() {
            if (isPaused) {
                await new Promise(resolve => pauseResolvers.push(resolve));
            }
        }
        
        function toggleShortcutsPanel() {
            const panel = document.getElementById('shortcuts-help');
            const toggle = document.getElementById('shortcuts-toggle');
            const isVisible = panel.classList.contains('visible');
            
            if (isVisible) {
                panel.classList.remove('visible');
                toggle.style.display = 'block';
            } else {
                panel.classList.add('visible');
                toggle.style.display = 'none';
            }
        }
        
        async function sleep(ms) {
            await checkPause();
            return new Promise(resolve => setTimeout(resolve, ms * ANIM_SPEED));
        }
        
        // For timeouts that should also be slowed
        function animDelay(ms) {
            return ms * ANIM_SPEED;
        }
        
        // Legacy function name for keyboard shortcut
        function toggleAnimSpeed() { cycleAnimSpeed(); }

        // ============ CLUSTER MANAGEMENT ============
        function loadConfig(configId) {
            const config = CLUSTER_CONFIGS[configId];
            state.currentConfig = configId;
            state.isSharded = config.isSharded;
            state.isStandby = config.isStandby || false;
            
            // Initialize regions
            state.regions = config.regions.map(r => ({ ...r, status: 'healthy' }));
            state.regionStatus = {};
            state.regions.forEach(r => state.regionStatus[r.id] = 'healthy');
            
            state.oplogCounter = 0;
            state.isElecting = {};
            state.electionTerm = 1;

            // Handle Standby Cluster (Beta) - special case
            if (config.isStandby) {
                // Clear other state
                state.nodes = [];
                state.mongos = [];
                state.configServers = [];
                state.shards = [];
                
                // Reset standby state
                standbyState.leftRegionDown = false;
                standbyState.rightRegionDown = false;
                standbyState.activePosition = 'left';
                standbyState.failoverInProgress = false;
                
                // Update header
                const headerConfig = document.getElementById('header-config');
                if (headerConfig) {
                    headerConfig.textContent = 'Active-Standby (Beta)';
                }
                
                // Hide all other containers, show standby visualization
                document.querySelector('.mongos-layer').style.display = 'none';
                document.querySelector('.config-layer').style.display = 'none';
                document.getElementById('shards-container').style.display = 'none';
                document.getElementById('rs-container').style.display = 'none';
                document.getElementById('standby-cluster-container').style.display = '';
                
                // Hide interactive controls (standby is visualization-only for now)
                document.getElementById('target-shard-card').style.display = 'none';
                document.getElementById('request-region-card').style.display = 'none';
                
                // Hide the top control sections that don't apply to standby
                document.querySelector('.top-section').style.display = 'none';
                document.getElementById('stats-dashboard').style.display = 'none';
                document.getElementById('conn-string-panel').style.display = 'none';
                document.getElementById('info-panel').style.display = 'none';
                
                // Show event log for standby mode
                document.querySelector('.event-log-panel').style.display = '';
                document.getElementById('event-log').innerHTML = '';
                
                // Reset standby UI to initial state
                resetStandbyUI();
                resetNodeStates();
                initStandbyWcPills();
                document.getElementById('node-click-tip').style.display = 'none';
                
                log(`Loaded: ${config.name}`, 'success');
                log(`Active-Standby architecture with manual failover`, 'info');
                log(`Click nodes in active cluster to simulate failures. Use operations to see read/write flows.`, 'info');
                return;
            }
            
            // Show controls that may have been hidden by standby mode
            document.querySelector('.top-section').style.display = '';
            document.getElementById('stats-dashboard').style.display = '';
            document.getElementById('conn-string-panel').style.display = '';
            document.querySelector('.event-log-panel').style.display = '';
            document.getElementById('info-panel').style.display = '';
            document.getElementById('node-click-tip').style.display = '';
            document.getElementById('standby-cluster-container').style.display = 'none';

            if (config.isSharded) {
                // Sharded cluster initialization
                state.nodes = [];
                state.mongos = config.mongos.map(m => ({ ...m, status: 'healthy' }));
                state.configServers = config.configServers.map((c, i) => ({
                    ...c,
                    role: i === 0 ? 'primary' : 'secondary',
                    status: 'healthy',
                    oplogCount: 0
                }));
                state.shards = config.shards.map(shard => {
                    const shardNodes = shard.nodes.map(n => {
                        const maxPriority = Math.max(...shard.nodes.filter(x => x.priority > 0).map(x => x.priority));
                        const isHighestPriority = n.priority === maxPriority && 
                            shard.nodes.filter(x => x.priority === maxPriority).indexOf(n) === 0;
                        return {
                            ...n,
                            role: isHighestPriority ? 'primary' : 'secondary',
                            status: 'healthy',
                            oplog: [],
                            oplogCount: 0
                        };
                    });
                    return { ...shard, nodes: shardNodes };
                });
                
                // Update header
                const headerConfig = document.getElementById('header-config');
                if (headerConfig) {
                    headerConfig.textContent = `${state.shards.length} Shards Ã— ${state.shards[0].nodes.length} Nodes`;
                }
                
                // Show sharded layers, hide RS container
                document.querySelector('.mongos-layer').style.display = '';
                document.querySelector('.config-layer').style.display = '';
                document.getElementById('shards-container').style.display = '';
                document.getElementById('rs-container').style.display = 'none';
                
                // Show sharded-only controls and populate dropdowns
                document.getElementById('target-shard-card').style.display = '';
                document.getElementById('request-region-card').style.display = '';
                populateShardedDropdowns();
                
                renderCluster();
                log(`Loaded: ${config.name}`, 'success');
                log(`${state.shards.length} shards Ã— ${state.shards[0].nodes.length} nodes each`, 'info');
                log(`${state.mongos.length} mongos + ${state.configServers.length} config servers`, 'info');
            } else {
                // Replica set initialization
                state.mongos = [];
                state.configServers = [];
                state.shards = [];
                
                const maxPriority = Math.max(...config.nodes.filter(x => x.priority > 0).map(x => x.priority));
                state.nodes = config.nodes.map(n => {
                    const isHighestPriority = n.priority === maxPriority && 
                        config.nodes.filter(x => x.priority === maxPriority).indexOf(n) === 0;
                    return {
                        ...n,
                        role: isHighestPriority ? 'primary' : 'secondary',
                        status: 'healthy',
                        oplog: [],
                        oplogCount: 0
                    };
                });
                
                // Update header
                const headerConfig = document.getElementById('header-config');
                if (headerConfig) {
                    headerConfig.textContent = `rs0 (${state.nodes.length} nodes)`;
                }
                
                // Hide sharded layers, show RS container
                document.querySelector('.mongos-layer').style.display = 'none';
                document.querySelector('.config-layer').style.display = 'none';
                document.getElementById('shards-container').style.display = 'none';
                document.getElementById('rs-container').style.display = '';
                
                // Hide sharded-only controls
                document.getElementById('target-shard-card').style.display = 'none';
                document.getElementById('request-region-card').style.display = 'none';
                
                renderReplicaSet();
                log(`Loaded: ${config.name}`, 'success');
                const votingCount = getVotingMembers(state.nodes).length;
                const nonVotingCount = state.nodes.length - votingCount;
                const votingInfo = nonVotingCount > 0 ? ` (${votingCount} voting, ${nonVotingCount} non-voting)` : '';
                log(`${state.nodes.length}-node replica set${votingInfo}, majority: ${getMajorityRequired(state.nodes)}`, 'info');
            }

            updateInfoPanel(config);
            renderRegionButtons();
            updateClusterStatus();
            document.getElementById('event-log').innerHTML = '';
            resetStats();
            updateConnectionString();
        }

        function updateInfoPanel(config) {
            const panel = document.getElementById('info-panel');
            const isWarning = config.name.includes('Misconception');
            panel.style.borderColor = isWarning ? 'rgba(255, 107, 107, 0.5)' : 'rgba(0, 237, 100, 0.3)';
            panel.innerHTML = `
                <div class="info-icon">${isWarning ? 'âš ï¸' : 'ðŸ’¡'}</div>
                <div class="info-content">
                    <div class="info-title" style="${isWarning ? 'color: #ff6b6b;' : ''}">${config.name}</div>
                    <div class="info-desc">${config.description} <span style="opacity: 0.7;">â€¢ ðŸ‘† Click nodes to simulate failure/recovery</span></div>
                    ${isWarning ? `
                        <div style="margin-top: 8px; padding: 8px 12px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; font-size: 0.8rem; color: #ff6b6b;">
                            <strong>âš¡ Test it:</strong> Kill Region 1 and watch the cluster lose majority despite having 2 nodes in Region 2!
                        </div>
                        <div style="margin-top: 8px; padding: 8px 12px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; font-size: 0.8rem; color: #ffc107;">
                            <strong>ðŸ“ Note:</strong> To recover, you must <u>manually</u> promote the read-only node by changing its priority and votes via rs.reconfig(). This requires human intervention!
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderRegionButtons() {
            const container = document.getElementById('region-buttons');
            container.innerHTML = state.regions.map(r => {
                const regionClass = r.id.replace('region-', 'region-');
                const isDown = state.regionStatus[r.id] === 'down';
                return `
                    <button class="region-btn ${regionClass}" onclick="toggleRegion('${r.id}')">
                        ${isDown ? 'âœ“ Restore' : 'ðŸ’¥ Kill'} ${r.name}
                    </button>
                `;
            }).join('');
        }

        // ============ REGION CONTROL ============
        function toggleRegion(regionId) {
            if (state.isSharded) {
                toggleShardedRegion(regionId);
            } else {
                toggleRSRegion(regionId);
            }
        }

        function toggleRSRegion(regionId) {
            const isDown = state.regionStatus[regionId] === 'down';
            const regionInfo = getRegionInfo(regionId);
            
            if (isDown) {
                state.regionStatus[regionId] = 'healthy';
                state.nodes.filter(n => n.region === regionId).forEach(n => {
                    n.status = 'recovering';
                });
                
                log(`${regionInfo.name} coming back online...`, 'warning');
                renderReplicaSet();
                renderRegionButtons();
                
                setTimeout(() => {
                    state.nodes.filter(n => n.region === regionId).forEach(n => {
                        n.status = 'healthy';
                    });
                    
                    if (!state.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(state.nodes)) {
                        triggerRSElection();
                    }
                    
                    log(`${regionInfo.name} restored`, 'success');
                    renderReplicaSet();
                    updateClusterStatus();
                }, 2000);
            } else {
                state.regionStatus[regionId] = 'down';
                let hadPrimary = false;
                
                state.nodes.filter(n => n.region === regionId).forEach(n => {
                    if (n.role === 'primary') hadPrimary = true;
                    n.status = 'down';
                    n.role = 'secondary';
                    n.oplog = [];
                });
                
                const currentPrimary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                if (currentPrimary && !hasMajority(state.nodes)) {
                    log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                    currentPrimary.role = 'secondary';
                }
                
                log(`âš ï¸ ${regionInfo.name} FAILED`, 'error');
                renderReplicaSet();
                renderRegionButtons();
                updateClusterStatus();
                
                // Only trigger election if we have majority AND lost the primary
                if (hadPrimary) {
                    if (hasMajority(state.nodes)) {
                        triggerRSElection();
                    } else {
                        const healthyVoters = getHealthyVoters(state.nodes);
                        const majorityRequired = getMajorityRequired(state.nodes);
                        log(`âš ï¸ NO MAJORITY: ${healthyVoters.length} voters < ${majorityRequired} required. Cluster is READ-ONLY!`, 'error');
                    }
                }
            }
        }

        function toggleShardedRegion(regionId) {
            const isDown = state.regionStatus[regionId] === 'down';
            const regionInfo = getRegionInfo(regionId);
            
            if (isDown) {
                state.regionStatus[regionId] = 'healthy';
                
                state.mongos.filter(m => m.region === regionId).forEach(m => m.status = 'healthy');
                state.configServers.filter(c => c.region === regionId).forEach(c => {
                    c.status = 'recovering';
                });
                state.shards.forEach(shard => {
                    shard.nodes.filter(n => n.region === regionId).forEach(n => {
                        n.status = 'recovering';
                    });
                });
                
                log(`${regionInfo.name} coming back online...`, 'warning');
                renderCluster();
                renderRegionButtons();
                
                setTimeout(() => {
                    state.configServers.filter(c => c.region === regionId).forEach(c => {
                        c.status = 'healthy';
                    });
                    if (!state.configServers.some(c => c.role === 'primary' && c.status === 'healthy')) {
                        const candidate = state.configServers.filter(c => c.status === 'healthy').sort((a, b) => b.priority - a.priority)[0];
                        if (candidate) {
                            candidate.role = 'primary';
                            log(`Config server ${candidate.name} elected PRIMARY`, 'success');
                        }
                    }
                    
                    state.shards.forEach(shard => {
                        shard.nodes.filter(n => n.region === regionId).forEach(n => {
                            n.status = 'healthy';
                        });
                        if (!shard.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(shard)) {
                            triggerElection(shard);
                        }
                    });
                    
                    log(`${regionInfo.name} restored`, 'success');
                    renderCluster();
                    updateClusterStatus();
                }, 2000);
            } else {
                state.regionStatus[regionId] = 'down';
                
                state.mongos.filter(m => m.region === regionId).forEach(m => m.status = 'down');
                
                state.configServers.filter(c => c.region === regionId).forEach(c => {
                    const wasPrimary = c.role === 'primary';
                    c.status = 'down';
                    c.role = 'secondary';
                    if (wasPrimary) {
                        const newPrimary = state.configServers.filter(x => x.status === 'healthy').sort((a, b) => b.priority - a.priority)[0];
                        if (newPrimary) {
                            newPrimary.role = 'primary';
                            log(`Config server ${newPrimary.name} elected PRIMARY`, 'success');
                        }
                    }
                });
                
                const affectedShards = [];
                state.shards.forEach(shard => {
                    const regionNodes = shard.nodes.filter(n => n.region === regionId);
                    const hadPrimary = regionNodes.some(n => n.role === 'primary');
                    
                    regionNodes.forEach(n => {
                        n.status = 'down';
                        n.role = 'secondary';
                        n.oplog = [];
                    });
                    
                    const currentPrimary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                    if (currentPrimary && !hasMajority(shard)) {
                        log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                        currentPrimary.role = 'secondary';
                    }
                    
                    if (hadPrimary) affectedShards.push(shard);
                });
                
                log(`âš ï¸ ${regionInfo.name} FAILED`, 'error');
                renderCluster();
                renderRegionButtons();
                updateClusterStatus();
                
                // Only trigger election for shards that have majority
                affectedShards.forEach(shard => {
                    if (hasMajority(shard)) {
                        triggerElection(shard);
                    } else {
                        const healthyVoters = getHealthyVoters(shard);
                        const majorityRequired = getMajorityRequired(shard);
                        log(`âš ï¸ ${shard.name}: NO MAJORITY (${healthyVoters.length}/${majorityRequired}). Shard is READ-ONLY!`, 'error');
                    }
                });
            }
        }

        // ============ NODE CONTROL (SHARDED) ============
        function toggleNode(shardId, nodeId) {
            const shard = state.shards.find(s => s.id === shardId);
            const node = shard.nodes.find(n => n.id === nodeId);
            
            if (node.status === 'down') {
                node.status = 'recovering';
                log(`${node.name} recovering...`, 'warning');
                renderCluster();
                
                setTimeout(() => {
                    node.status = 'syncing';
                    log(`${node.name} syncing oplog...`, 'info');
                    renderCluster();
                    
                    const syncTime = 3000 + Math.random() * 2000;
                    setTimeout(() => {
                        node.status = 'healthy';
                        log(`${node.name} is healthy (priority ${node.priority})`, 'success');
                        renderCluster();
                        updateClusterStatus();
                        
                        if (!shard.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(shard)) {
                            triggerElection(shard);
                        }
                    }, syncTime);
                }, 1500);
            } else {
                const wasPrimary = node.role === 'primary';
                node.status = 'down';
                node.role = 'secondary';
                node.oplog = [];
                log(`${node.name} is DOWN`, 'error');
                renderCluster();
                updateClusterStatus();
                
                // Check if current primary lost majority
                const currentPrimary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                if (currentPrimary && !hasMajority(shard)) {
                    log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                    currentPrimary.role = 'secondary';
                    renderCluster();
                    updateClusterStatus();
                }
                
                // Only trigger election if we have majority AND lost the primary
                if (wasPrimary) {
                    if (hasMajority(shard)) {
                        triggerElection(shard);
                    } else {
                        const healthyVoters = getHealthyVoters(shard);
                        const majorityRequired = getMajorityRequired(shard);
                        log(`âš ï¸ ${shard.name}: NO MAJORITY (${healthyVoters.length}/${majorityRequired}). Shard is READ-ONLY!`, 'error');
                    }
                }
            }
        }

        function killRandomPrimary() {
            if (state.isSharded) {
                const shardsWithPrimary = state.shards.filter(s => s.nodes.some(n => n.role === 'primary' && n.status === 'healthy'));
                if (shardsWithPrimary.length === 0) {
                    log('No healthy primary to kill', 'warning');
                    return;
                }
                const shard = shardsWithPrimary[Math.floor(Math.random() * shardsWithPrimary.length)];
                const primary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                log(`Killing ${shard.name} primary: ${primary.name}`, 'warning');
                toggleNode(shard.id, primary.id);
            } else {
                killRSPrimary();
            }
        }

        // ============ ELECTION (SHARDED) ============
        function triggerElection(shard) {
            if (state.isElecting[shard.id]) return;
            state.isElecting[shard.id] = true;
            
            const majorityRequired = getMajorityRequired(shard);
            const healthyNodes = getHealthyNodes(shard);
            const eligibleCandidates = healthyNodes.filter(n => n.priority > 0);
            
            const modal = document.getElementById('election-modal');
            const progressBar = document.getElementById('election-progress');
            const electionStatus = document.getElementById('election-status');
            const electionText = document.getElementById('election-text');
            const modalTitle = modal.querySelector('.modal-title');
            const modalIcon = modal.querySelector('.modal-icon');
            
            modal.classList.add('visible');
            
            const healthyVoters = getHealthyVoters(shard);
            if (healthyVoters.length < majorityRequired) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                const hasNonVoting = shard.nodes.some(n => n.votes === 0);
                const nonVotingNote = hasNonVoting ? '<br><span style="font-size: 0.75rem; color: #ff6b6b;">Read-only nodes (v:0) cannot vote!</span>' : '';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">${shard.name}: No majority!</strong><br><br>
                    Healthy voters: <strong>${healthyVoters.length}</strong><br>
                    Majority required: <strong>${majorityRequired}</strong>${nonVotingNote}<br><br>
                    <span style="font-size: 0.8rem;">âš ï¸ ${shard.name} is READ-ONLY</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = 'var(--node-down)';
                electionStatus.textContent = `${shard.name}: Writes blocked`;
                
                log(`${shard.name} election FAILED: no majority (${healthyVoters.length} voters / ${majorityRequired} needed)`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting[shard.id] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 4000);
                return;
            }
            
            if (eligibleCandidates.length === 0) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">${shard.name}: No eligible candidates!</strong><br><br>
                    Only Priority 0 nodes available<br><br>
                    <span style="font-size: 0.8rem;">â³ Priority 0 nodes cannot become primary</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = '#00b4d8';
                electionStatus.textContent = 'P:0 nodes are DR-only';
                
                log(`${shard.name} election FAILED: only P:0 nodes available`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting[shard.id] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 3000);
                return;
            }
            
            const sortedCandidates = eligibleCandidates.sort((a, b) => b.priority - a.priority);
            const newPrimary = sortedCandidates[0];
            
            electionText.textContent = `${shard.name}: Initiating failover...`;
            
            const steps = [
                { progress: 20, text: 'Detecting primary failure...' },
                { progress: 40, text: `Checking quorum: ${healthyNodes.length}/${majorityRequired} âœ“` },
                { progress: 60, text: `Highest priority: ${newPrimary.name} (p:${newPrimary.priority})` },
                { progress: 85, text: 'Votes collected, majority achieved!' },
                { progress: 100, text: `${newPrimary.name} elected PRIMARY!` }
            ];

            let stepIndex = 0;
            const stepInterval = setInterval(() => {
                if (stepIndex < steps.length) {
                    progressBar.style.width = `${steps[stepIndex].progress}%`;
                    electionStatus.textContent = steps[stepIndex].text;
                    stepIndex++;
                } else {
                    clearInterval(stepInterval);
                    
                    newPrimary.role = 'primary';
                    const region = getRegionInfo(newPrimary.region);
                    log(`${shard.name}: ${newPrimary.name} elected PRIMARY (${region.name}, p:${newPrimary.priority})`, 'success');
                    updateStats('election');
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        state.isElecting[shard.id] = false;
                        renderCluster();
                        updateClusterStatus();
                        updateConnectionString();
                        progressBar.style.width = '0%';
                    }, 800);
                }
            }, 400);
        }

        // ============ OPLOG ============
        function createOplogEntry(op, ns, document, update = null) {
            const ts = generateTimestamp();
            const entry = {
                ts: ts,
                t: state.electionTerm,
                op: op,
                ns: ns,
                wall: new Date().toISOString()
            };

            if (op === 'i') entry.o = document;
            else if (op === 'u') { entry.o = update; entry.o2 = { _id: document._id }; }
            else if (op === 'd') entry.o = { _id: document._id };

            return entry;
        }

        function addToOplog(node, entry) {
            node.oplog.unshift(entry);
            node.oplogSize += 100;
            node.lastApplied = entry.ts;
            if (node.oplog.length > 10) node.oplog.pop();
        }

        // ============ VISUAL WRITE FLOW ============
        function showWriteFlowPanel(operation, targetShard = null, isSharded = true) {
            const panel = document.getElementById('write-flow-panel');
            const wcLabel = document.getElementById('flow-wc');
            const stepsContainer = document.getElementById('write-flow-steps');
            const resultEl = document.getElementById('write-flow-result');
            
            wcLabel.textContent = `w:${state.writeConcern}`;
            resultEl.className = 'write-flow-result';
            resultEl.style.display = 'none';
            
            let nodes, primary, secondaries, totalVotingMembers, majorityNeeded, wcRequired, targetName;
            
            if (isSharded && targetShard) {
                // Sharded cluster mode
                nodes = targetShard.nodes;
                targetName = targetShard.name;
            } else {
                // Replica set mode
                nodes = state.nodes;
                targetName = 'rs0';
            }
            
            primary = nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            secondaries = nodes.filter(n => n.role === 'secondary' && n.status === 'healthy');
            totalVotingMembers = nodes.length;
            majorityNeeded = getMajorityRequired(nodes);
            wcRequired = state.writeConcern === 'majority' ? majorityNeeded 
                         : state.writeConcern === '1' ? 1 
                         : totalVotingMembers;
            
            // Determine step 4 content based on write concern
            let step4Label, step4Detail;
            if (state.writeConcern === '1') {
                step4Label = 'Background Replication';
                step4Detail = `${secondaries.length} secondaries (fire-and-forget, not waited)`;
            } else if (state.writeConcern === 'majority') {
                step4Label = 'Replicate to Secondaries';
                step4Detail = `Need ${majorityNeeded - 1} more acks (majority = ${majorityNeeded} total)`;
            } else {
                step4Label = 'Replicate to ALL Secondaries';
                step4Detail = `Need all ${secondaries.length} secondaries to ack`;
            }
            
            const step1Label = isSharded 
                ? `Client â†’ mongos â†’ ${targetName}`
                : `Client â†’ ${targetName}`;
            
            stepsContainer.innerHTML = `
                <div class="write-flow-step" id="step-1">
                    <span class="step-icon">ðŸ“</span>
                    <div class="step-content">
                        <div class="step-label">${step1Label}</div>
                        <div class="step-detail">Operation: ${operation.toUpperCase()}</div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-2">
                    <span class="step-icon">ðŸ‘‘</span>
                    <div class="step-content">
                        <div class="step-label">Write to Primary</div>
                        <div class="step-detail">Target: ${primary ? primary.name : 'N/A'}</div>
                        <div class="step-nodes">
                            ${primary ? `<span class="step-node-badge primary">${primary.name} âœ“</span>` : '<span class="step-node-badge">No primary</span>'}
                        </div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-3">
                    <span class="step-icon">ðŸ“‹</span>
                    <div class="step-content">
                        <div class="step-label">Write to Oplog</div>
                        <div class="step-detail">local.oplog.rs on primary</div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-4">
                    <span class="step-icon">${state.writeConcern === '1' ? 'ðŸ’¨' : 'ðŸ”„'}</span>
                    <div class="step-content">
                        <div class="step-label">${step4Label}</div>
                        <div class="step-detail">${step4Detail}</div>
                        <div class="step-nodes" id="replication-nodes">
                            ${secondaries.map(s => `<span class="step-node-badge pending" id="badge-${s.id}">${s.name}</span>`).join('')}
                        </div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-5">
                    <span class="step-icon">âœ…</span>
                    <div class="step-content">
                        <div class="step-label">Wait for Acknowledgment</div>
                        <div class="step-detail">w:${state.writeConcern} = ${state.writeConcern === 'majority' ? majorityNeeded + ' nodes (n/2+1 where n=' + totalVotingMembers + ')' : state.writeConcern === '1' ? 'primary only (instant)' : 'all ' + totalVotingMembers + ' nodes'}</div>
                        <div class="step-nodes" id="ack-count">
                            <span class="step-node-badge">0 / ${wcRequired}</span>
                        </div>
                    </div>
                </div>
            `;
            
            panel.classList.add('visible');
        }

        function updateFlowStep(stepNum, active = false, complete = false) {
            const step = document.getElementById(`step-${stepNum}`);
            if (step) {
                step.classList.remove('active', 'complete');
                if (active) step.classList.add('active');
                if (complete) step.classList.add('complete');
            }
        }

        function updateReplicationBadge(nodeId, acked = false) {
            const badge = document.getElementById(`badge-${nodeId}`);
            if (badge) {
                badge.classList.remove('pending');
                badge.classList.add('acked');
                badge.textContent = badge.textContent.split(' ')[0] + ' âœ“';
            }
        }

        function updateAckCount(count, required) {
            const ackEl = document.getElementById('ack-count');
            if (ackEl) {
                const isComplete = count >= required;
                let statusText = '';
                let badgeClass = 'pending';
                
                if (isComplete) {
                    badgeClass = 'majority-reached';
                    if (state.writeConcern === '1') {
                        statusText = 'âœ“ PRIMARY ACK';
                    } else if (state.writeConcern === 'majority') {
                        statusText = 'âœ“ MAJORITY!';
                    } else {
                        statusText = 'âœ“ ALL NODES!';
                    }
                }
                
                ackEl.innerHTML = `
                    <span class="step-node-badge ${badgeClass}">
                        ${count} / ${required} ${statusText}
                    </span>
                `;
            }
        }

        function showWriteResult(success, message) {
            const resultEl = document.getElementById('write-flow-result');
            resultEl.textContent = message;
            resultEl.className = `write-flow-result ${success ? 'success' : 'failed'}`;
            resultEl.style.display = 'block';
            
            setTimeout(() => {
                document.getElementById('write-flow-panel').classList.remove('visible');
            }, animDelay(2500));
        }

        async function animateParticle(fromEl, toEl, type, duration = 400) {
            await checkPause(); // Wait if paused
            const scaledDuration = duration * ANIM_SPEED;
            return new Promise(resolve => {
                const overlay = document.getElementById('replication-overlay');
                const particle = document.createElement('div');
                particle.className = `flow-particle ${type}`;
                overlay.appendChild(particle);

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                
                const startX = fromRect.left + fromRect.width / 2;
                const startY = fromRect.top + fromRect.height / 2;
                const endX = toRect.left + toRect.width / 2;
                const endY = toRect.top + toRect.height / 2;

                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;

                let startTime = null;
                let pausedTime = 0;
                let lastPauseCheck = performance.now();

                function animate(currentTime) {
                    // Handle pause during animation
                    if (isPaused) {
                        pausedTime += currentTime - lastPauseCheck;
                    }
                    lastPauseCheck = currentTime;
                    
                    if (startTime === null) startTime = currentTime;
                    const elapsed = currentTime - startTime - pausedTime;
                    const progress = Math.min(elapsed / scaledDuration, 1);
                    
                    // Easing
                    const eased = 1 - Math.pow(1 - progress, 3);

                    particle.style.left = `${startX + (endX - startX) * eased}px`;
                    particle.style.top = `${startY + (endY - startY) * eased}px`;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                        resolve();
                    }
                }

                requestAnimationFrame(animate);
            });
        }

        function highlightNode(nodeId, type) {
            const nodeEl = document.getElementById(`node-${nodeId}`);
            if (nodeEl) {
                nodeEl.classList.add(type);
                setTimeout(() => nodeEl.classList.remove(type), 1500);
            }
        }

        // ============ SIMULATE OPERATIONS (SHARDED) ============
        async function simulateShardedWrite(operation) {
            // Select target shard based on user selection or random
            let targetShard;
            if (state.targetShard === 'auto') {
                targetShard = state.shards[Math.floor(Math.random() * state.shards.length)];
            } else {
                targetShard = state.shards.find(s => s.id === state.targetShard);
                if (!targetShard) {
                    log(`${operation.toUpperCase()} FAILED: Shard ${state.targetShard} not found`, 'error');
                    return;
                }
            }
            
            const primary = targetShard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            
            if (!primary) { 
                const reason = !hasMajority(targetShard) ? ' (no majority - shard is read-only)' : '';
                log(`${operation.toUpperCase()} FAILED: No primary on ${targetShard.name}${reason}`, 'error');
                updateStats('failed');
                return; 
            }

            // Select mongos based on request region
            let activeMongos;
            if (state.requestRegion === 'auto') {
                activeMongos = state.mongos.find(m => state.regionStatus[m.region] === 'healthy');
            } else {
                activeMongos = state.mongos.find(m => m.region === state.requestRegion && state.regionStatus[m.region] === 'healthy');
                if (!activeMongos) {
                    log(`${operation.toUpperCase()} FAILED: No mongos in ${state.regions.find(r => r.id === state.requestRegion)?.name || state.requestRegion}`, 'error');
                    return;
                }
            }
            
            if (!activeMongos) {
                log(`${operation.toUpperCase()} FAILED: No mongos available`, 'error');
                return;
            }
            
            // Determine if this is a cross-region write
            const mongosRegion = state.regions.find(r => r.id === activeMongos.region);
            const primaryRegion = state.regions.find(r => r.id === primary.region);
            const isCrossRegion = activeMongos.region !== primary.region;

            const secondaries = targetShard.nodes.filter(n => n.role === 'secondary' && n.status === 'healthy');
            const majorityNeeded = getMajorityRequired(targetShard);
            const wcRequired = state.writeConcern === 'majority' ? majorityNeeded : 
                              state.writeConcern === '1' ? 1 : targetShard.nodes.length;

            // w:all check
            if (state.writeConcern === 'all') {
                const downNodes = targetShard.nodes.filter(n => n.status !== 'healthy');
                if (downNodes.length > 0) {
                    const downNames = downNodes.map(n => n.name.split('-').slice(-2).join('-')).join(', ');
                    log(`${operation.toUpperCase()} TIMEOUT: w:all requires all ${targetShard.nodes.length} nodes on ${targetShard.name}`, 'error');
                    log(`â³ Waiting indefinitely for: ${downNames}`, 'error');
                    log(`ðŸ’¡ Reduce write concern or restore nodes to proceed`, 'warning');
                    showWriteFlowPanel(operation, targetShard, true);
                    showWriteResult(false, `âœ— TIMEOUT: w:all needs all ${targetShard.nodes.length} nodes`);
                    return;
                }
            }

            // Show write flow panel
            showWriteFlowPanel(operation, targetShard, true);

            // Log with cross-region indicator
            const routeInfo = isCrossRegion 
                ? `ðŸŒ CROSS-REGION: ${mongosRegion.name} â†’ ${primaryRegion.name}` 
                : `âœ“ LOCAL: ${mongosRegion.name}`;
            log(`${operation.toUpperCase()} â†’ ${targetShard.name} via ${activeMongos.id}`, 'info');
            log(`   ${routeInfo}`, isCrossRegion ? 'warning' : 'info');
            
            // Step 1: Client to mongos
            updateFlowStep(1, true);
            await sleep(150);
            updateFlowStep(1, false, true);
            
            // Step 2: Write to primary
            updateFlowStep(2, true);
            
            // Animate: mongos â†’ primary
            const mongosEl = document.getElementById(`mongos-${activeMongos.id}`);
            const primaryEl = document.getElementById(`node-${primary.id}`);
            
            if (mongosEl && primaryEl) {
                await animateParticle(mongosEl, primaryEl, 'write', 350);
            }
            
            if (primaryEl) {
                primaryEl.classList.add('receiving');
                setTimeout(() => primaryEl.classList.remove('receiving'), 500);
            }
            primary.oplogCount++;
            renderCluster();
            updateFlowStep(2, false, true);
            
            // Step 3: Write to oplog
            updateFlowStep(3, true);
            await sleep(100);
            updateFlowStep(3, false, true);
            
            let ackCount = 1;
            updateAckCount(ackCount, wcRequired);
            
            // Step 4: Replication
            updateFlowStep(4, true);
            
            // w:1 - done
            if (state.writeConcern === '1') {
                log(`${operation.toUpperCase()} acknowledged (w:1 = primary only)`, 'success');
                updateStats('write', 5);
                updateFlowStep(4, false, true);
                updateFlowStep(5, false, true);
                showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:1)`);
                
                // Background replication
                secondaries.forEach((sec, i) => {
                    setTimeout(async () => {
                        if (sec.status === 'healthy') {
                            sec.oplogCount++;
                            const secEl = document.getElementById(`node-${sec.id}`);
                            if (primaryEl && secEl) {
                                animateParticle(primaryEl, secEl, 'replication', 300);
                            }
                            if (secEl) {
                                setTimeout(() => {
                                    secEl.classList.add('receiving');
                                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                                }, animDelay(400));
                            }
                            renderCluster();
                        }
                    }, animDelay(150 + i * 200));
                });
                return;
            }
            
            // Replicate and count acks
            let majorityReached = false;
            for (let i = 0; i < secondaries.length; i++) {
                const sec = secondaries[i];
                
                if (sec.status !== 'healthy') continue;
                
                // Animate replication particle
                const secEl = document.getElementById(`node-${sec.id}`);
                if (primaryEl && secEl) {
                    await animateParticle(primaryEl, secEl, 'replication', 250);
                }
                
                sec.oplogCount++;
                if (secEl) {
                    secEl.classList.add('receiving');
                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                }
                renderCluster();
                ackCount++;
                updateReplicationBadge(sec.id, true);
                updateAckCount(ackCount, wcRequired);
                
                if (ackCount >= wcRequired && !majorityReached) {
                    majorityReached = true;
                    updateFlowStep(4, false, true);
                    updateFlowStep(5, false, true);
                    if (secEl) {
                        secEl.classList.add('acknowledged');
                        setTimeout(() => secEl.classList.remove('acknowledged'), animDelay(2000));
                    }
                    const wcName = state.writeConcern === 'majority' ? 'majority' : 'all';
                    log(`${operation.toUpperCase()} acknowledged (w:${wcName} = ${wcRequired} acks)`, 'success');
                    updateStats('write', 10 + ackCount * 5);
                    showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:${wcName})`);
                }
                
                await sleep(150);
            }
        }
        
        async function simulateInsert() {
            if (state.isSharded) {
                await simulateShardedWrite('insert');
            } else {
                await simulateRSWrite('insert');
            }
        }

        async function simulateUpdate() {
            if (state.isSharded) {
                await simulateShardedWrite('update');
            } else {
                await simulateRSWrite('update');
            }
        }

        async function simulateRead() {
            if (state.isSharded) {
                await simulateShardedRead();
            } else {
                await simulateRSRead();
            }
        }

        // ============ REPLICA SET OPERATIONS ============
        async function simulateRSWrite(operation) {
            const primary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            if (!primary) {
                const reason = !hasMajority(state.nodes) ? ' (no majority - cluster is read-only)' : '';
                log(`${operation.toUpperCase()} FAILED: No primary${reason}`, 'error');
                updateStats('failed');
                return;
            }

            const secondaries = state.nodes.filter(n => n.role === 'secondary' && n.status === 'healthy');
            const majorityNeeded = getMajorityRequired(state.nodes);
            const totalNodes = state.nodes.length;
            const wcRequired = state.writeConcern === 'majority' ? majorityNeeded : 
                              state.writeConcern === '1' ? 1 : totalNodes;

            // w:all check
            if (state.writeConcern === 'all') {
                const downNodes = state.nodes.filter(n => n.status !== 'healthy');
                if (downNodes.length > 0) {
                    const downNames = downNodes.map(n => n.name).join(', ');
                    log(`${operation.toUpperCase()} TIMEOUT: w:all requires all ${totalNodes} nodes`, 'error');
                    log(`â³ Waiting indefinitely for: ${downNames}`, 'error');
                    log(`ðŸ’¡ Reduce write concern or restore nodes to proceed`, 'warning');
                    showWriteFlowPanel(operation, null, false);
                    showWriteResult(false, `âœ— TIMEOUT: w:all needs all ${totalNodes} nodes`);
                    return;
                }
            }

            // Show write flow panel
            showWriteFlowPanel(operation, null, false);
            
            log(`${operation.toUpperCase()} â†’ ${primary.name}`, 'info');
            
            // Step 1: Client to RS
            updateFlowStep(1, true);
            await sleep(200);
            updateFlowStep(1, false, true);
            
            // Step 2: Write to primary with particle animation
            updateFlowStep(2, true);
            const primaryEl = document.getElementById(`node-${primary.id}`);
            
            // Animate particle from info panel (representing client) to primary
            const clientEl = document.getElementById('info-panel');
            if (clientEl && primaryEl) {
                await animateParticle(clientEl, primaryEl, 'write', 350);
            }
            
            if (primaryEl) {
                primaryEl.classList.add('receiving');
                setTimeout(() => primaryEl.classList.remove('receiving'), animDelay(800));
            }
            primary.oplogCount++;
            renderReplicaSet();
            updateFlowStep(2, false, true);
            
            // Step 3: Write to oplog
            updateFlowStep(3, true);
            await sleep(200);
            updateFlowStep(3, false, true);
            
            let ackCount = 1;
            updateAckCount(ackCount, wcRequired);
            
            // Step 4: Replication
            updateFlowStep(4, true);
            
            if (state.writeConcern === '1') {
                const latency = isCrossRegion ? getLatency(activeMongos.region, primary.region) : 5;
                log(`${operation.toUpperCase()} acknowledged (w:1 = primary only)`, 'success');
                updateStats('write', latency);
                updateFlowStep(4, false, true);
                updateFlowStep(5, false, true);
                showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:1) [${latency}ms]`);
                
                // Background replication (fire-and-forget)
                secondaries.forEach((sec, i) => {
                    setTimeout(async () => {
                        if (sec.status === 'healthy') {
                            sec.oplogCount++;
                            const secEl = document.getElementById(`node-${sec.id}`);
                            if (primaryEl && secEl) {
                                animateParticle(primaryEl, secEl, 'replication', 400);
                            }
                            if (secEl) {
                                setTimeout(() => {
                                    secEl.classList.add('receiving');
                                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                                }, animDelay(400));
                            }
                            renderReplicaSet();
                        }
                    }, animDelay(150 + i * 200));
                });
                return;
            }
            
            let majorityReached = false;
            for (let i = 0; i < secondaries.length; i++) {
                const sec = secondaries[i];
                
                if (sec.status !== 'healthy') continue;
                
                // Animate replication particle
                const secEl = document.getElementById(`node-${sec.id}`);
                if (primaryEl && secEl) {
                    await animateParticle(primaryEl, secEl, 'replication', 250);
                }
                
                sec.oplogCount++;
                if (secEl) {
                    secEl.classList.add('receiving');
                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                }
                renderReplicaSet();
                ackCount++;
                updateReplicationBadge(sec.id, true);
                updateAckCount(ackCount, wcRequired);
                
                if (ackCount >= wcRequired && !majorityReached) {
                    majorityReached = true;
                    const latency = 10 + ackCount * 5;
                    updateFlowStep(4, false, true);
                    updateFlowStep(5, false, true);
                    if (secEl) {
                        secEl.classList.add('acknowledged');
                        setTimeout(() => secEl.classList.remove('acknowledged'), animDelay(2000));
                    }
                    const wcName = state.writeConcern === 'majority' ? 'majority' : 'all';
                    log(`${operation.toUpperCase()} acknowledged (w:${wcName} = ${wcRequired} acks)`, 'success');
                    updateStats('write', latency);
                    showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:${wcName}) [${latency}ms]`);
                }
                
                await sleep(150);
            }
        }

        async function simulateRSRead() {
            const readPref = state.readPreference;
            const healthyNodes = state.nodes.filter(n => n.status === 'healthy');
            
            if (healthyNodes.length === 0) {
                log(`READ FAILED: No healthy nodes`, 'error');
                return;
            }

            let targetNode = null;
            const primary = healthyNodes.find(n => n.role === 'primary');
            const secondaries = healthyNodes.filter(n => n.role === 'secondary');

            switch (readPref) {
                case 'primary':
                    targetNode = primary;
                    if (!targetNode) {
                        log(`READ FAILED: No primary (readPreference: primary)`, 'error');
                        return;
                    }
                    break;
                case 'primaryPreferred':
                    targetNode = primary || secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondary':
                    if (secondaries.length === 0) {
                        log(`READ FAILED: No secondaries (readPreference: secondary)`, 'error');
                        return;
                    }
                    targetNode = secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondaryPreferred':
                    targetNode = secondaries.length > 0 ? 
                        secondaries[Math.floor(Math.random() * secondaries.length)] : primary;
                    break;
                case 'nearest':
                    targetNode = healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
                    break;
                default:
                    targetNode = healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
            }

            if (!targetNode) {
                log(`READ FAILED: No eligible node for ${readPref}`, 'error');
                return;
            }

            const region = getRegionInfo(targetNode.region);
            log(`READ (${readPref}) â†’ ${targetNode.name} (${region.name})`, 'info');
            
            // Show read flow panel
            showReadFlowPanel(readPref, targetNode, healthyNodes);
            
            const nodeEl = document.getElementById(`node-${targetNode.id}`);
            const clientEl = document.getElementById('info-panel');
            
            // Animate request: client â†’ node
            if (clientEl && nodeEl) {
                await animateParticle(clientEl, nodeEl, 'read', 300);
            }
            
            if (nodeEl) {
                nodeEl.classList.add('reading');
                setTimeout(() => nodeEl.classList.remove('reading'), animDelay(1000));
            }
            
            await sleep(200);
            
            // Animate response: node â†’ client
            if (nodeEl && clientEl) {
                await animateParticle(nodeEl, clientEl, 'read', 400);
            }
            
            log(`READ â† ${targetNode.name} complete`, 'success');
            updateStats('read', 15);
            
            // Hide read flow panel after delay
            setTimeout(() => {
                document.getElementById('read-flow-panel').classList.remove('visible');
            }, animDelay(2000));
        }
        
        function showReadFlowPanel(readPref, targetNode, allNodes) {
            const panel = document.getElementById('read-flow-panel');
            const prefEl = document.getElementById('flow-read-pref');
            const nodesEl = document.getElementById('read-flow-nodes');
            const selectionEl = document.getElementById('read-flow-selection');
            const resultEl = document.getElementById('read-flow-result');
            
            if (prefEl) prefEl.textContent = readPref;
            if (resultEl) resultEl.style.display = 'none';
            
            // Show available nodes
            if (nodesEl) {
                nodesEl.innerHTML = allNodes.map(n => {
                    const isTarget = n.id === targetNode.id;
                    const roleIcon = n.role === 'primary' ? 'ðŸ‘‘' : 'ðŸ“š';
                    const statusClass = isTarget ? 'target' : 'eligible';
                    return `<span class="read-node-badge ${statusClass}">${roleIcon} ${n.name}${isTarget ? ' â† TARGET' : ''}</span>`;
                }).join('');
            }
            
            // Show selection details
            if (selectionEl) {
                const region = getRegionInfo(targetNode.region);
                selectionEl.innerHTML = `
                    <div class="selection-detail">
                        <span class="selection-label">Reading from:</span>
                        <span class="selection-value">${targetNode.name}</span>
                    </div>
                    <div class="selection-detail">
                        <span class="selection-label">Role:</span>
                        <span class="selection-value ${targetNode.role}">${targetNode.role.toUpperCase()}</span>
                    </div>
                    <div class="selection-detail">
                        <span class="selection-label">Region:</span>
                        <span class="selection-value">${region?.icon || ''} ${region?.name || 'Unknown'}</span>
                    </div>
                `;
            }
            
            panel.classList.add('visible');
        }

        // ============ SHARDED OPERATIONS ============
        async function simulateShardedRead() {
            const readPref = state.readPreference;
            
            // Select target shard based on user selection or random
            let targetShard;
            if (state.targetShard === 'auto') {
                targetShard = state.shards[Math.floor(Math.random() * state.shards.length)];
            } else {
                targetShard = state.shards.find(s => s.id === state.targetShard);
                if (!targetShard) {
                    log(`READ FAILED: Shard ${state.targetShard} not found`, 'error');
                    return;
                }
            }
            
            // Select mongos based on request region
            let activeMongos;
            if (state.requestRegion === 'auto') {
                activeMongos = state.mongos.find(m => state.regionStatus[m.region] === 'healthy');
            } else {
                activeMongos = state.mongos.find(m => m.region === state.requestRegion && state.regionStatus[m.region] === 'healthy');
                if (!activeMongos) {
                    log(`READ FAILED: No mongos in ${state.regions.find(r => r.id === state.requestRegion)?.name || state.requestRegion}`, 'error');
                    return;
                }
            }
            
            if (!activeMongos) {
                log('READ FAILED: No mongos available', 'error');
                return;
            }

            const healthyNodes = targetShard.nodes.filter(n => n.status === 'healthy');
            
            if (healthyNodes.length === 0) {
                log(`READ FAILED: No healthy nodes on ${targetShard.name}`, 'error');
                return;
            }

            let targetNode = null;
            const primary = healthyNodes.find(n => n.role === 'primary');
            const secondaries = healthyNodes.filter(n => n.role === 'secondary');

            switch (readPref) {
                case 'primary':
                    targetNode = primary;
                    if (!targetNode) {
                        log(`READ FAILED: No primary (readPreference: primary)`, 'error');
                        return;
                    }
                    break;
                case 'primaryPreferred':
                    targetNode = primary || secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondary':
                    if (secondaries.length === 0) {
                        log(`READ FAILED: No secondaries (readPreference: secondary)`, 'error');
                        return;
                    }
                    targetNode = secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondaryPreferred':
                    targetNode = secondaries.length > 0 ? 
                        secondaries[Math.floor(Math.random() * secondaries.length)] : primary;
                    break;
                case 'nearest':
                    const sameRegionNodes = healthyNodes.filter(n => n.region === activeMongos.region);
                    targetNode = sameRegionNodes.length > 0 ?
                        sameRegionNodes[Math.floor(Math.random() * sameRegionNodes.length)] :
                        healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
                    break;
                default:
                    targetNode = healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
            }

            const nodeRegion = getRegionInfo(targetNode.region);
            const mongosRegion = getRegionInfo(activeMongos.region);
            const isCrossRegion = activeMongos.region !== targetNode.region;
            
            // Log with cross-region indicator
            const routeInfo = isCrossRegion 
                ? `ðŸŒ CROSS-REGION: ${mongosRegion?.name} â†’ ${nodeRegion?.name}` 
                : `âœ“ LOCAL: ${mongosRegion?.name}`;
            log(`READ (${readPref}) â†’ ${targetShard.name}/${targetNode.name}`, 'info');
            log(`   ${routeInfo}`, isCrossRegion ? 'warning' : 'info');
            
            // Show read flow panel
            showReadFlowPanel(readPref, targetNode, healthyNodes);
            
            const mongosEl = document.getElementById(`mongos-${activeMongos.id}`);
            const nodeEl = document.getElementById(`node-${targetNode.id}`);
            
            if (mongosEl && nodeEl) {
                await animateParticle(mongosEl, nodeEl, 'read', 350);
            }
            
            if (nodeEl) {
                nodeEl.classList.add('reading');
                setTimeout(() => nodeEl.classList.remove('reading'), animDelay(1000));
            }
            
            await sleep(200);
            
            if (nodeEl && mongosEl) {
                await animateParticle(nodeEl, mongosEl, 'read', 400);
            }
            
            const readLatency = isCrossRegion ? getLatency(activeMongos.region, targetNode.region) + 10 : 10;
            log(`READ â† ${targetShard.name}/${targetNode.name} complete [${readLatency}ms]`, 'success');
            updateStats('read', readLatency);
            
            // Hide read flow panel after delay
            setTimeout(() => {
                document.getElementById('read-flow-panel').classList.remove('visible');
            }, animDelay(2000));
        }

        function resetCluster() {
            loadConfig(state.currentConfig);
        }

        // ============ RENDERING (REPLICA SET) ============
        function renderReplicaSet() {
            const container = document.getElementById('rs-container');
            if (!container) return;
            
            // Group nodes by region
            const regionGroups = {};
            state.nodes.forEach(n => {
                if (!regionGroups[n.region]) regionGroups[n.region] = [];
                regionGroups[n.region].push(n);
            });
            
            container.innerHTML = Object.entries(regionGroups).map(([regionId, nodes]) => {
                const region = getRegionInfo(regionId);
                const isDown = state.regionStatus[regionId] === 'down';
                const regionClass = regionId.replace('region-', 'region-');
                return `
                    <div class="rs-region-group ${regionClass} ${isDown ? 'down' : ''}">
                        <div class="rs-region-header">
                            <span class="rs-region-icon">${region.icon}</span>
                            <span class="rs-region-name">${region.name}</span>
                            <span class="rs-region-latency">${region.latency || '~1ms'}</span>
                        </div>
                        <div class="rs-nodes">
                            ${nodes.map(n => renderRSNodeCard(n)).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderRSNodeCard(node) {
            const isReadReplica = node.isReadReplica || (node.votes === 0 && node.priority === 0);
            const roleClass = node.status === 'down' ? 'down' : 
                             node.status === 'recovering' ? 'recovering' :
                             node.status === 'syncing' ? 'syncing' :
                             isReadReplica ? 'read-replica' :
                             node.priority === 0 ? 'priority-zero' : node.role;
            const roleLabel = node.status === 'down' ? 'DOWN' : 
                             node.status === 'recovering' ? 'SYNC' :
                             node.status === 'syncing' ? 'ðŸ”„' :
                             isReadReplica ? 'R/O' :
                             node.priority === 0 ? 'P:0' : node.role.toUpperCase();
            const icon = node.role === 'primary' ? 'ðŸ‘‘' : 
                        isReadReplica ? 'ðŸ“–' : 
                        node.priority === 0 ? 'ðŸ›¡ï¸' : 'ðŸ“š';
            
            const priorityColor = isReadReplica ? '#ff6b6b' :
                                 node.priority === 0 ? 'rgba(255,255,255,0.3)' : 
                                 node.priority >= 3 ? 'var(--mongo-green)' :
                                 node.priority >= 2 ? '#00b4d8' : 'rgba(255,255,255,0.5)';
            
            const votesBadge = node.votes === 0 ? '<span style="color: #ff6b6b; margin-left: 4px; font-size: 0.65rem;">v:0</span>' : '';

            return `
                <div class="node-card ${roleClass}" id="node-${node.id}" onclick="toggleRSNode('${node.id}')">
                    <div class="node-header">
                        <span class="node-icon">${icon}</span>
                        <span class="node-name">${node.name}</span>
                        <span class="node-role-badge">${roleLabel}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.7rem;">
                        <span class="node-oplog">oplog: ${node.oplogCount}</span>
                        <span style="color: ${priorityColor}; font-weight: 600;">p:${node.priority}${votesBadge}</span>
                    </div>
                </div>
            `;
        }

        // ============ NODE CONTROL (REPLICA SET) ============
        function toggleRSNode(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            if (node.status === 'down') {
                node.status = 'recovering';
                log(`${node.name} recovering...`, 'warning');
                renderReplicaSet();
                
                setTimeout(() => {
                    node.status = 'syncing';
                    log(`${node.name} syncing oplog...`, 'info');
                    renderReplicaSet();
                    
                    const syncTime = 3000 + Math.random() * 2000;
                    setTimeout(() => {
                        node.status = 'healthy';
                        log(`${node.name} is healthy (priority ${node.priority})`, 'success');
                        renderReplicaSet();
                        updateClusterStatus();
                        
                        if (!state.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(state.nodes)) {
                            triggerRSElection();
                        }
                    }, syncTime);
                }, 1500);
            } else {
                const wasPrimary = node.role === 'primary';
                node.status = 'down';
                node.role = 'secondary';
                node.oplog = [];
                log(`${node.name} is DOWN`, 'error');
                renderReplicaSet();
                updateClusterStatus();
                
                // Check if current primary lost majority
                const currentPrimary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                if (currentPrimary && !hasMajority(state.nodes)) {
                    log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                    currentPrimary.role = 'secondary';
                    renderReplicaSet();
                    updateClusterStatus();
                }
                
                // Only trigger election if we have majority AND lost the primary
                if (wasPrimary) {
                    if (hasMajority(state.nodes)) {
                        triggerRSElection();
                    } else {
                        const healthyVoters = getHealthyVoters(state.nodes);
                        const majorityRequired = getMajorityRequired(state.nodes);
                        log(`âš ï¸ NO MAJORITY: ${healthyVoters.length} voters < ${majorityRequired} required. Cluster is READ-ONLY!`, 'error');
                    }
                }
            }
        }

        function triggerRSElection() {
            if (state.isElecting['rs']) return;
            state.isElecting['rs'] = true;
            
            const majorityRequired = getMajorityRequired(state.nodes);
            const healthyNodes = getHealthyNodes(state.nodes);
            const eligibleCandidates = healthyNodes.filter(n => n.priority > 0);
            
            const modal = document.getElementById('election-modal');
            const progressBar = document.getElementById('election-progress');
            const electionStatus = document.getElementById('election-status');
            const electionText = document.getElementById('election-text');
            const modalTitle = modal.querySelector('.modal-title');
            const modalIcon = modal.querySelector('.modal-icon');
            
            modal.classList.add('visible');
            
            const healthyVoters = getHealthyVoters(state.nodes);
            if (healthyVoters.length < majorityRequired) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                const hasNonVoting = state.nodes.some(n => n.votes === 0);
                const nonVotingNote = hasNonVoting ? '<br><span style="font-size: 0.75rem; color: #ff6b6b;">Read-only nodes (v:0) cannot vote!</span>' : '';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">rs0: No majority!</strong><br><br>
                    Healthy voters: <strong>${healthyVoters.length}</strong><br>
                    Majority required: <strong>${majorityRequired}</strong>${nonVotingNote}<br><br>
                    <span style="font-size: 0.8rem;">âš ï¸ Replica set is READ-ONLY</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = 'var(--node-down)';
                electionStatus.textContent = 'rs0: Writes blocked';
                
                log(`rs0 election FAILED: no majority (${healthyVoters.length} voters / ${majorityRequired} needed)`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting['rs'] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 4000);
                return;
            }
            
            if (eligibleCandidates.length === 0) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">rs0: No eligible candidates!</strong><br><br>
                    Only Priority 0 nodes available<br><br>
                    <span style="font-size: 0.8rem;">â³ Priority 0 nodes cannot become primary</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = '#00b4d8';
                electionStatus.textContent = 'P:0 nodes are DR-only';
                
                log(`rs0 election FAILED: only P:0 nodes available`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting['rs'] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 3000);
                return;
            }
            
            const sortedCandidates = eligibleCandidates.sort((a, b) => b.priority - a.priority);
            const newPrimary = sortedCandidates[0];
            
            electionText.textContent = `rs0: Initiating failover...`;
            
            const steps = [
                { progress: 20, text: 'Detecting primary failure...' },
                { progress: 40, text: `Checking quorum: ${healthyNodes.length}/${majorityRequired} âœ“` },
                { progress: 60, text: `Highest priority: ${newPrimary.name} (p:${newPrimary.priority})` },
                { progress: 85, text: 'Votes collected, majority achieved!' },
                { progress: 100, text: `${newPrimary.name} elected PRIMARY!` }
            ];

            let stepIndex = 0;
            const stepInterval = setInterval(() => {
                if (stepIndex < steps.length) {
                    progressBar.style.width = `${steps[stepIndex].progress}%`;
                    electionStatus.textContent = steps[stepIndex].text;
                    stepIndex++;
                } else {
                    clearInterval(stepInterval);
                    
                    newPrimary.role = 'primary';
                    const region = getRegionInfo(newPrimary.region);
                    log(`rs0: ${newPrimary.name} elected PRIMARY (${region.name}, p:${newPrimary.priority})`, 'success');
                    updateStats('election');
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        state.isElecting['rs'] = false;
                        progressBar.style.width = '0%';
                        modalIcon.textContent = 'ðŸ—³ï¸';
                        modalTitle.textContent = 'Election in Progress';
                        renderReplicaSet();
                        updateClusterStatus();
                        updateConnectionString();
                    }, 1500);
                }
            }, 500);
        }

        function killRSPrimary() {
            const primary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            if (!primary) {
                log('No healthy primary to kill', 'warning');
                return;
            }
            log(`Killing rs0 primary: ${primary.name}`, 'warning');
            toggleRSNode(primary.id);
        }

        // ============ RENDERING (SHARDED) ============
        function renderCluster() {
            renderMongos();
            renderConfigServers();
            renderShards();
        }
        
        function renderMongos() {
            const container = document.getElementById('mongos-container');
            if (!container) return;
            
            container.innerHTML = state.mongos.map(m => {
                const region = getRegionInfo(m.region);
                const isDown = state.regionStatus[m.region] === 'down';
                return `
                    <div class="mongos-node ${isDown ? 'down' : ''}" id="mongos-${m.id}">
                        <span class="mongos-icon">ðŸ”€</span>
                        <div class="mongos-info">
                            <div>${m.id}</div>
                            <div class="mongos-region">${region.icon} ${region.name}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderConfigServers() {
            const container = document.getElementById('config-container');
            if (!container) return;
            
            container.innerHTML = state.configServers.map(c => {
                const region = getRegionInfo(c.region);
                const isDown = c.status === 'down';
                const isPrimary = c.role === 'primary' && c.status === 'healthy';
                return `
                    <div class="config-node ${isDown ? 'down' : ''} ${isPrimary ? 'primary' : ''}">
                        <span class="config-icon">âš™ï¸</span>
                        <div class="config-info">
                            <div>${c.name}</div>
                            <div class="config-region">${region.icon} ${region.name}</div>
                        </div>
                        <span class="config-role">${isDown ? 'DOWN' : (isPrimary ? 'PRIMARY' : 'SEC')}</span>
                    </div>
                `;
            }).join('');
        }
        
        function renderShards() {
            const container = document.getElementById('shards-container');
            if (!container) return;
            
            container.innerHTML = state.shards.map(shard => {
                const healthyCount = getHealthyNodes(shard).length;
                const primary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                const statusClass = healthyCount === shard.nodes.length && primary ? 'healthy' : 
                                   primary && hasMajority(shard) ? 'degraded' : 'critical';
                const statusText = healthyCount === shard.nodes.length && primary ? 'âœ“ Healthy' :
                                  primary ? `${healthyCount}/${shard.nodes.length}` : 'âš ï¸ No Primary';

                // Group nodes by region
                const regionGroups = {};
                shard.nodes.forEach(n => {
                    if (!regionGroups[n.region]) regionGroups[n.region] = [];
                    regionGroups[n.region].push(n);
                });

                return `
                    <div class="shard-panel">
                        <div class="shard-header">
                            <div class="shard-icon">ðŸ“¦</div>
                            <div class="shard-title">${shard.name}</div>
                            <span class="shard-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="shard-body">
                            ${Object.entries(regionGroups).map(([regionId, nodes]) => {
                                const region = getRegionInfo(regionId);
                                const isDown = state.regionStatus[regionId] === 'down';
                                return `
                                    <div class="region-row ${regionId.replace('region-', 'region-')} ${isDown ? 'down' : ''}">
                                        <div class="region-label">
                                            <div class="region-name">${region.icon} ${region.name}</div>
                                            <div class="region-latency">${region.latency || '~1ms'}</div>
                                        </div>
                                        <div class="region-nodes">
                                            ${nodes.map(n => renderShardNodeCard(n, shard.id)).join('')}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderShardNodeCard(node, shardId) {
            const roleClass = node.status === 'down' ? 'down' : 
                             node.status === 'recovering' ? 'recovering' :
                             node.status === 'syncing' ? 'syncing' :
                             node.priority === 0 ? 'priority-zero' : node.role;
            const roleLabel = node.status === 'down' ? 'DOWN' : 
                             node.status === 'recovering' ? 'SYNC' :
                             node.status === 'syncing' ? 'ðŸ”„' :
                             node.priority === 0 ? 'P:0' : node.role.toUpperCase();
            const icon = node.role === 'primary' ? 'ðŸ‘‘' : node.priority === 0 ? 'ðŸ›¡ï¸' : 'ðŸ“š';
            
            const priorityColor = node.priority === 0 ? 'rgba(255,255,255,0.3)' : 
                                 node.priority >= 3 ? 'var(--mongo-green)' :
                                 node.priority >= 2 ? '#00b4d8' : 'rgba(255,255,255,0.5)';

            return `
                <div class="node-card ${roleClass}" id="node-${node.id}" onclick="toggleNode('${shardId}', '${node.id}')">
                    <div class="node-header">
                        <span class="node-icon">${icon}</span>
                        <span class="node-name">${node.name.split('-').slice(-2).join('-')}</span>
                        <span class="node-role-badge">${roleLabel}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.7rem;">
                        <span class="node-oplog">oplog: ${node.oplogCount}</span>
                        <span style="color: ${priorityColor}; font-weight: 600;">p:${node.priority}</span>
                    </div>
                </div>
            `;
        }

        function updateClusterStatus() {
            const clusterStatus = document.getElementById('cluster-status');
            const statusText = document.getElementById('status-text');
            clusterStatus.classList.remove('healthy', 'degraded', 'critical');

            if (state.isSharded) {
                const allHealthy = state.shards.every(s => getHealthyNodes(s).length === s.nodes.length && s.nodes.some(n => n.role === 'primary' && n.status === 'healthy'));
                const anyPrimary = state.shards.every(s => s.nodes.some(n => n.role === 'primary' && n.status === 'healthy'));
                const anyMajority = state.shards.every(s => hasMajority(s));
                
                if (allHealthy) {
                    clusterStatus.classList.add('healthy');
                    statusText.textContent = 'Healthy';
                } else if (anyPrimary && anyMajority) {
                    clusterStatus.classList.add('degraded');
                    statusText.textContent = 'Degraded';
                } else {
                    clusterStatus.classList.add('critical');
                    statusText.textContent = anyMajority ? 'No Primary' : 'No Majority';
                }
            } else {
                const healthyCount = getHealthyNodes(state.nodes).length;
                const hasPrimary = state.nodes.some(n => n.role === 'primary' && n.status === 'healthy');
                const hasMaj = hasMajority(state.nodes);
                
                if (healthyCount === state.nodes.length && hasPrimary) {
                    clusterStatus.classList.add('healthy');
                    statusText.textContent = 'Healthy';
                } else if (hasPrimary && hasMaj) {
                    clusterStatus.classList.add('degraded');
                    statusText.textContent = 'Degraded';
                } else {
                    clusterStatus.classList.add('critical');
                    statusText.textContent = hasMaj ? 'No Primary' : 'No Majority';
                }
            }
        }

        function log(message, type = 'info') {
            const eventLog = document.getElementById('event-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            entry.innerHTML = `<div class="log-time">${time}</div><div class="log-msg">${message}</div>`;
            eventLog.insertBefore(entry, eventLog.firstChild);
            while (eventLog.children.length > 15) eventLog.removeChild(eventLog.lastChild);
        }

        // ============ EVENT HANDLERS ============
        function setupTopologyToggle() {
            document.querySelectorAll('.topology-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    
                    // Update toggle buttons
                    document.querySelectorAll('.topology-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    
                    // Show/hide cluster options based on type
                    document.querySelectorAll('.cluster-option').forEach(opt => {
                        if (opt.dataset.type === type) {
                            opt.style.display = '';
                        } else {
                            opt.style.display = 'none';
                        }
                    });
                    
                    // Select first visible option
                    const firstVisible = document.querySelector(`.cluster-option[data-type="${type}"]`);
                    if (firstVisible) {
                        document.querySelectorAll('.cluster-option').forEach(o => o.classList.remove('selected'));
                        firstVisible.classList.add('selected');
                        loadConfig(firstVisible.dataset.config);
                    }
                });
            });
        }

        function setupClusterSelector() {
            document.querySelectorAll('.cluster-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    // Only select visible options of the same type
                    const type = opt.dataset.type;
                    document.querySelectorAll(`.cluster-option[data-type="${type}"]`).forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    loadConfig(opt.dataset.config);
                });
            });
        }

        function setupWriteConcernHandlers() {
            document.querySelectorAll('.wc-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    document.querySelectorAll('.wc-pill').forEach(p => p.classList.remove('selected'));
                    pill.classList.add('selected');
                    state.writeConcern = pill.dataset.value;
                    log(`Write concern: w:${state.writeConcern}`, 'info');
                });
            });
        }

        function setupReadPreferenceHandler() {
            const select = document.getElementById('read-preference');
            select.addEventListener('change', () => {
                state.readPreference = select.value;
                log(`Read preference: ${state.readPreference}`, 'info');
            });
        }

        function populateShardedDropdowns() {
            // Populate Target Shard dropdown
            const shardSelect = document.getElementById('target-shard');
            shardSelect.innerHTML = '<option value="auto" selected>Auto (random)</option>';
            state.shards.forEach(shard => {
                const opt = document.createElement('option');
                opt.value = shard.id;
                opt.textContent = shard.name;
                shardSelect.appendChild(opt);
            });
            
            // Populate Request Region dropdown
            const regionSelect = document.getElementById('request-region');
            regionSelect.innerHTML = '<option value="auto" selected>Auto (any available)</option>';
            state.regions.forEach(region => {
                const opt = document.createElement('option');
                opt.value = region.id;
                opt.textContent = `${region.icon} ${region.name}`;
                regionSelect.appendChild(opt);
            });
            
            // Reset selections
            state.targetShard = 'auto';
            state.requestRegion = 'auto';
            shardSelect.value = 'auto';
            regionSelect.value = 'auto';
        }

        function setupShardedDropdownHandlers() {
            const shardSelect = document.getElementById('target-shard');
            shardSelect.addEventListener('change', () => {
                state.targetShard = shardSelect.value;
                const label = state.targetShard === 'auto' ? 'Auto (random)' : state.shards.find(s => s.id === state.targetShard)?.name;
                log(`Target shard: ${label}`, 'info');
            });
            
            const regionSelect = document.getElementById('request-region');
            regionSelect.addEventListener('change', () => {
                state.requestRegion = regionSelect.value;
                const region = state.regions.find(r => r.id === state.requestRegion);
                const label = state.requestRegion === 'auto' ? 'Auto (any available)' : `${region?.icon} ${region?.name}`;
                log(`Request region: ${label}`, 'info');
            });
        }

        // ============ STATISTICS ============
        function updateStats(type, latency = 0) {
            if (type === 'write') state.stats.writes++;
            else if (type === 'read') state.stats.reads++;
            else if (type === 'failed') state.stats.failed++;
            else if (type === 'election') state.stats.elections++;
            
            if (latency > 0) {
                state.stats.latencies.push(latency);
                if (state.stats.latencies.length > 50) state.stats.latencies.shift();
                state.stats.avgLatency = Math.round(
                    state.stats.latencies.reduce((a, b) => a + b, 0) / state.stats.latencies.length
                );
            }
            
            renderStats();
        }

        function renderStats() {
            document.getElementById('stat-writes').textContent = state.stats.writes;
            document.getElementById('stat-reads').textContent = state.stats.reads;
            const failedEl = document.getElementById('stat-failed');
            failedEl.textContent = state.stats.failed;
            failedEl.className = state.stats.failed > 0 ? 'stat-value error' : 'stat-value';
            document.getElementById('stat-elections').textContent = state.stats.elections;
            document.getElementById('stat-avg-latency').innerHTML = 
                `${state.stats.avgLatency}<span style="font-size: 0.8rem;">ms</span>`;
        }

        function resetStats() {
            state.stats = { writes: 0, reads: 0, failed: 0, elections: 0, latencies: [], avgLatency: 0 };
            renderStats();
        }

        // ============ STANDBY CLUSTER FUNCTIONS ============
        // Track by POSITION (left/right), not by role
        const standbyState = {
            leftRegionDown: false,
            rightRegionDown: false,
            activePosition: 'left', // which position (left or right) is currently active
            failoverInProgress: false,
            isSplit: false // whether clusters have been split (independent mode)
        };

        function setElementDisplay(id, display) {
            const el = document.getElementById(id);
            if (el) el.style.display = display;
        }

        function updateRegionComponents(activePos) {
            console.log('updateRegionComponents called with:', activePos);
            
            // Blob storage is ALWAYS visible in both regions (contains oplog + cluster link state)
            setElementDisplay('left-cloud-storage', '');
            setElementDisplay('right-cloud-storage', '');
            
            // When left is ACTIVE
            if (activePos === 'left') {
                console.log('Setting left as ACTIVE, right as STANDBY');
                // Left (ACTIVE): show shippers, hide injector pipeline
                setElementDisplay('left-blob-output', '');      // Shows "push oplog â†’" 
                setElementDisplay('left-blob-input', 'none');   // Hide "â† receives oplog"
                setElementDisplay('left-storage-pull', 'none');
                setElementDisplay('left-coordinator', 'none');
                setElementDisplay('left-injectors', 'none');
                setElementDisplay('left-injector-push', 'none');
                setElementDisplay('left-cluster-pull', '');
                setElementDisplay('left-shippers', '');
                
                // Right (STANDBY): show injector pipeline, hide shippers
                setElementDisplay('right-blob-output', 'none');
                setElementDisplay('right-blob-input', '');      // Shows "â† receives oplog"
                setElementDisplay('right-storage-pull', '');
                setElementDisplay('right-coordinator', '');
                setElementDisplay('right-injectors', '');
                setElementDisplay('right-injector-push', '');
                setElementDisplay('right-cluster-pull', 'none');
                setElementDisplay('right-shippers', 'none');
            } else {
                console.log('Setting right as ACTIVE, left as STANDBY');
                // Left (STANDBY): show injector pipeline, hide shippers
                setElementDisplay('left-blob-output', 'none');
                setElementDisplay('left-blob-input', '');       // Shows "â† receives oplog"
                setElementDisplay('left-storage-pull', '');
                setElementDisplay('left-coordinator', '');
                setElementDisplay('left-injectors', '');
                setElementDisplay('left-injector-push', '');
                setElementDisplay('left-cluster-pull', 'none');
                setElementDisplay('left-shippers', 'none');
                
                // Right (ACTIVE): show shippers, hide injector pipeline
                setElementDisplay('right-blob-output', '');     // Shows "push oplog â†’"
                setElementDisplay('right-blob-input', 'none');
                setElementDisplay('right-storage-pull', 'none');
                setElementDisplay('right-coordinator', 'none');
                setElementDisplay('right-injectors', 'none');
                setElementDisplay('right-injector-push', 'none');
                setElementDisplay('right-cluster-pull', '');
                setElementDisplay('right-shippers', '');
            }
        }

        function getActiveRegionEl() {
            return standbyState.activePosition === 'left' 
                ? document.querySelector('.active-region')
                : document.querySelector('.standby-region-box');
        }

        function getStandbyRegionEl() {
            return standbyState.activePosition === 'left'
                ? document.querySelector('.standby-region-box')
                : document.querySelector('.active-region');
        }

        function isCurrentActiveDown() {
            return standbyState.activePosition === 'left' 
                ? standbyState.leftRegionDown 
                : standbyState.rightRegionDown;
        }

        function isCurrentStandbyDown() {
            return standbyState.activePosition === 'left'
                ? standbyState.rightRegionDown
                : standbyState.leftRegionDown;
        }

        function killRegion(position) {
            if (standbyState.failoverInProgress) return;
            
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            const crossFlowEl = document.getElementById('cross-region-flow');
            
            if (position === 'left') {
                standbyState.leftRegionDown = true;
                leftRegionEl.classList.add('region-down');
                document.getElementById('kill-left-btn').style.display = 'none';
                document.getElementById('restore-left-btn').style.display = '';
                
                const isActive = standbyState.activePosition === 'left';
                document.getElementById('left-region-status').textContent = 'âœ– Down';
                document.getElementById('left-region-status').className = 'status-value down';
                
                logStandbyEvent(`ðŸ’¥ Left region (${isActive ? 'Active' : 'Standby'}) failure detected!`, 'error');
            } else {
                standbyState.rightRegionDown = true;
                rightRegionEl.classList.add('region-down');
                document.getElementById('kill-right-btn').style.display = 'none';
                document.getElementById('restore-right-btn').style.display = '';
                
                const isActive = standbyState.activePosition === 'right';
                document.getElementById('right-region-status').textContent = 'âœ– Down';
                document.getElementById('right-region-status').className = 'status-value down';
                
                logStandbyEvent(`ðŸ’¥ Right region (${isActive ? 'Active' : 'Standby'}) failure detected!`, 'error');
            }
            
            // Pause replication if either region is down
            crossFlowEl.classList.add('paused');
            document.getElementById('replication-status').textContent = 'â¸ Paused';
            document.getElementById('replication-status').className = 'status-value paused';
            logStandbyEvent('âš ï¸ Replication paused', 'warning');
            
            updateFailoverButtonState();
        }

        function restoreRegion(position) {
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            const crossFlowEl = document.getElementById('cross-region-flow');
            
            if (position === 'left') {
                standbyState.leftRegionDown = false;
                leftRegionEl.classList.remove('region-down');
                document.getElementById('kill-left-btn').style.display = '';
                document.getElementById('restore-left-btn').style.display = 'none';
                
                const isActive = standbyState.activePosition === 'left';
                document.getElementById('left-region-status').textContent = isActive ? 'â— Active' : 'â— Standby';
                document.getElementById('left-region-status').className = 'status-value healthy';
                
                logStandbyEvent(`ðŸ”§ Left region restored (${isActive ? 'Active' : 'Standby'})`, 'success');
            } else {
                standbyState.rightRegionDown = false;
                rightRegionEl.classList.remove('region-down');
                document.getElementById('kill-right-btn').style.display = '';
                document.getElementById('restore-right-btn').style.display = 'none';
                
                const isActive = standbyState.activePosition === 'right';
                document.getElementById('right-region-status').textContent = isActive ? 'â— Active' : 'â— Standby';
                document.getElementById('right-region-status').className = 'status-value healthy';
                
                logStandbyEvent(`ðŸ”§ Right region restored (${isActive ? 'Active' : 'Standby'})`, 'success');
            }
            
            // Resume replication if both regions are up
            if (!standbyState.leftRegionDown && !standbyState.rightRegionDown) {
                crossFlowEl.classList.remove('paused');
                document.getElementById('replication-status').textContent = 'âŸ³ Syncing';
                document.getElementById('replication-status').className = 'status-value syncing';
                logStandbyEvent('âœ… Replication resumed', 'success');
            }
            
            updateFailoverButtonState();
        }

        function resetStandbyRegions() {
            const wasSplit = standbyState.isSplit;
            
            standbyState.leftRegionDown = false;
            standbyState.rightRegionDown = false;
            standbyState.activePosition = 'left';
            standbyState.failoverInProgress = false;
            standbyState.isSplit = false;
            
            // Clear the event log first
            document.getElementById('event-log').innerHTML = '';
            
            // Remove split mode classes
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            if (leftRegionEl) leftRegionEl.classList.remove('split-mode');
            if (rightRegionEl) rightRegionEl.classList.remove('split-mode');
            
            // Remove independent class from clusters
            document.querySelectorAll('.cluster-box.independent').forEach(el => {
                el.classList.remove('independent');
            });
            
            // Reset cross-region flow
            const crossFlowEl = document.getElementById('cross-region-flow');
            crossFlowEl.classList.remove('paused');
            document.querySelector('.cross-region-label').innerHTML = 'CROSS-REGION<br/>OPLOG SYNC';
            document.getElementById('flow-desc').innerHTML = 'push oplog to<br/>standby blob store';
            document.getElementById('arrow-direction').textContent = 'â†’â†’â†’';
            
            // Reset node states
            resetNodeStates();
            
            // Reset the entire UI
            resetStandbyUI();
            
            if (wasSplit) {
                logStandbyEvent('ðŸ”„ Standby cluster recreated from scratch', 'info');
                logStandbyEvent('âœ… Active-Standby architecture restored', 'success');
            } else {
                logStandbyEvent('ðŸ”„ All regions and nodes reset to initial state', 'info');
            }
        }

        function updateFailoverButtonState() {
            const failoverBtn = document.getElementById('failover-btn');
            const switchoverBtn = document.getElementById('switchover-btn');
            const splitoverBtn = document.getElementById('splitover-btn');
            const switchoverHint = document.getElementById('switchover-hint');
            const failoverHint = document.getElementById('failover-hint');
            
            // If in split mode, disable all failover operations
            if (standbyState.isSplit) {
                failoverBtn.disabled = true;
                switchoverBtn.disabled = true;
                splitoverBtn.disabled = true;
                failoverHint.textContent = 'Failover: Not available in split mode';
                failoverHint.style.color = 'rgba(255, 107, 107, 0.8)';
                return;
            }
            
            const bothHealthy = !standbyState.leftRegionDown && !standbyState.rightRegionDown;
            const bothDown = standbyState.leftRegionDown && standbyState.rightRegionDown;
            const oneDown = (standbyState.leftRegionDown || standbyState.rightRegionDown) && !bothDown;
            
            // Switchover: only available when BOTH regions are healthy
            if (bothHealthy && !standbyState.failoverInProgress) {
                switchoverBtn.disabled = false;
                switchoverHint.textContent = 'Switch Active Region: Both regions healthy âœ“';
                switchoverHint.style.color = 'rgba(0, 237, 100, 0.8)';
            } else {
                switchoverBtn.disabled = true;
                if (oneDown || bothDown) {
                    switchoverHint.textContent = 'Switch Active Region: Requires both regions healthy';
                    switchoverHint.style.color = 'rgba(255, 107, 107, 0.8)';
                } else {
                    switchoverHint.textContent = 'Switch Active Region: Operation in progress...';
                    switchoverHint.style.color = 'rgba(255, 200, 0, 0.8)';
                }
            }
            
            // Failover: available ONLY when one region is down (emergency promotion)
            if (oneDown && !standbyState.failoverInProgress) {
                failoverBtn.disabled = false;
                failoverHint.textContent = 'Failover: Ready to promote standby âš¡';
                failoverHint.style.color = 'rgba(255, 200, 0, 1)';
            } else {
                failoverBtn.disabled = true;
                if (bothHealthy) {
                    failoverHint.textContent = 'Failover: Requires one region to be down';
                    failoverHint.style.color = 'rgba(255, 200, 0, 0.6)';
                } else if (bothDown) {
                    failoverHint.textContent = 'Failover: Both regions down!';
                    failoverHint.style.color = 'rgba(255, 107, 107, 0.8)';
                } else {
                    failoverHint.textContent = 'Failover: Operation in progress...';
                    failoverHint.style.color = 'rgba(255, 200, 0, 0.8)';
                }
            }
            
            // Splitover: available anytime EXCEPT when both regions are down
            if (!bothDown && !standbyState.failoverInProgress) {
                splitoverBtn.disabled = false;
            } else {
                splitoverBtn.disabled = true;
            }
            
            // Update setup standby button visibility
            updateSetupStandbyButton();
        }

        async function initiateFailover() {
            if (standbyState.failoverInProgress) return;
            if (standbyState.isSplit) {
                logStandbyEvent('âš ï¸ Cannot failover: clusters are split', 'warning');
                return;
            }
            
            const bothDown = standbyState.leftRegionDown && standbyState.rightRegionDown;
            const oneDown = (standbyState.leftRegionDown || standbyState.rightRegionDown) && !bothDown;
            
            if (!oneDown) {
                logStandbyEvent('âš ï¸ Failover requires exactly one region to be down', 'warning');
                logStandbyEvent('ðŸ’¡ Use Switch Active Region when both regions are healthy', 'info');
                return;
            }
            
            if (isCurrentStandbyDown()) {
                logStandbyEvent('âš ï¸ Cannot failover: standby region is down', 'warning');
                logStandbyEvent('ðŸ’¡ Use Split Clusters for emergency scenarios', 'info');
                return;
            }
            
            const currentActivePos = standbyState.activePosition;
            const newActivePos = currentActivePos === 'left' ? 'right' : 'left';
            
            standbyState.failoverInProgress = true;
            const modal = document.getElementById('failover-modal');
            const progressBar = document.getElementById('failover-progress-bar');
            const steps = document.querySelectorAll('.failover-step');
            
            // Emergency failover - active region is down
            document.getElementById('failover-modal-text').textContent = 
                `ðŸš¨ Emergency failover: ${currentActivePos} â†’ ${newActivePos}...`;
            
            modal.classList.add('visible');
            document.getElementById('failover-btn').disabled = true;
            document.getElementById('switchover-btn').disabled = true;
            document.getElementById('splitover-btn').disabled = true;
            
            logStandbyEvent('ðŸš¨ Initiating emergency failover (active region is down)...', 'error');
            logStandbyEvent(`Switching active from ${currentActivePos.toUpperCase()} to ${newActivePos.toUpperCase()}`, 'info');
            
            const stepDurations = [800, 1000, 1200, 800, 600];
            let progress = 0;
            
            for (let i = 0; i < steps.length; i++) {
                steps[i].classList.add('active');
                steps[i].querySelector('.failover-step-icon').textContent = 'â³';
                
                await new Promise(resolve => setTimeout(resolve, stepDurations[i]));
                
                steps[i].classList.remove('active');
                steps[i].classList.add('complete');
                steps[i].querySelector('.failover-step-icon').textContent = 'âœ“';
                
                progress += 20;
                progressBar.style.width = progress + '%';
                
                logStandbyEvent(`âœ“ Step ${i + 1}: ${steps[i].textContent.trim()}`, 'success');
            }
            
            // Complete failover
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Get the region elements (left is always .active-region, right is always .standby-region-box)
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            
            const leftHeader = leftRegionEl.querySelector('.region-header');
            const rightHeader = rightRegionEl.querySelector('.region-header');
            
            // Update based on new active position
            if (newActivePos === 'right') {
                // Left becomes standby, right becomes active
                leftHeader.classList.remove('active');
                leftHeader.classList.add('standby');
                leftHeader.querySelector('.region-name').textContent = 'STANDBY REGION';
                leftHeader.querySelector('.region-icon').textContent = 'ðŸŸ¢';
                leftHeader.querySelector('.region-status').textContent = standbyState.leftRegionDown ? 'âœ– Down' : 'â—‹ Standby';
                
                rightHeader.classList.remove('standby');
                rightHeader.classList.add('active');
                rightHeader.querySelector('.region-name').textContent = 'ACTIVE REGION';
                rightHeader.querySelector('.region-icon').textContent = 'ðŸ”µ';
                rightHeader.querySelector('.region-status').textContent = 'â— Primary (promoted)';
                
                // Update cluster labels
                leftRegionEl.querySelector('.cluster-label').textContent = 'STANDBY CLUSTER';
                let leftSublabel = leftRegionEl.querySelector('.cluster-sublabel');
                if (!leftSublabel) {
                    leftSublabel = document.createElement('div');
                    leftSublabel.className = 'cluster-sublabel';
                    leftRegionEl.querySelector('.cluster-label').after(leftSublabel);
                }
                leftSublabel.textContent = '(All Secondaries)';
                
                rightRegionEl.querySelector('.cluster-label').textContent = 'ACTIVE CLUSTER';
                const rightSublabel = rightRegionEl.querySelector('.cluster-sublabel');
                if (rightSublabel) rightSublabel.remove();
                
                // Update nodes
                updateNodesAfterFailover(leftRegionEl, 'standby');
                updateNodesAfterFailover(rightRegionEl, 'active');
                
                // Sync node states to match visual - left becomes standby (all secondaries)
                syncNodeStatesToRole('left', 'standby');
                syncNodeStatesToRole('right', 'active');
                
                // Update arrows - now flows from right to left (active right pushes to standby left)
                document.getElementById('arrow-direction').textContent = 'â†â†â†';
                document.getElementById('flow-desc').innerHTML = 'push oplog to<br/>standby blob store';
                
            } else {
                // Right becomes standby, left becomes active
                rightHeader.classList.remove('active');
                rightHeader.classList.add('standby');
                rightHeader.querySelector('.region-name').textContent = 'STANDBY REGION';
                rightHeader.querySelector('.region-icon').textContent = 'ðŸŸ¢';
                rightHeader.querySelector('.region-status').textContent = standbyState.rightRegionDown ? 'âœ– Down' : 'â—‹ Standby';
                
                leftHeader.classList.remove('standby');
                leftHeader.classList.add('active');
                leftHeader.querySelector('.region-name').textContent = 'ACTIVE REGION';
                leftHeader.querySelector('.region-icon').textContent = 'ðŸ”µ';
                leftHeader.querySelector('.region-status').textContent = 'â— Primary (promoted)';
                
                // Update cluster labels
                rightRegionEl.querySelector('.cluster-label').textContent = 'STANDBY CLUSTER';
                let rightSublabel = rightRegionEl.querySelector('.cluster-sublabel');
                if (!rightSublabel) {
                    rightSublabel = document.createElement('div');
                    rightSublabel.className = 'cluster-sublabel';
                    rightRegionEl.querySelector('.cluster-label').after(rightSublabel);
                }
                rightSublabel.textContent = '(All Secondaries)';
                
                leftRegionEl.querySelector('.cluster-label').textContent = 'ACTIVE CLUSTER';
                const leftSublabel = leftRegionEl.querySelector('.cluster-sublabel');
                if (leftSublabel) leftSublabel.remove();
                
                // Update nodes
                updateNodesAfterFailover(rightRegionEl, 'standby');
                updateNodesAfterFailover(leftRegionEl, 'active');
                
                // Sync node states to match visual - right becomes standby (all secondaries)
                syncNodeStatesToRole('right', 'standby');
                syncNodeStatesToRole('left', 'active');
                
                // Update arrows - now flows from left to right (active left pushes to standby right)
                document.getElementById('arrow-direction').textContent = 'â†’â†’â†’';
                document.getElementById('flow-desc').innerHTML = 'push oplog to<br/>standby blob store';
            }
            
            // Update flow direction class
            const crossFlowEl = document.getElementById('cross-region-flow');
            crossFlowEl.classList.remove('reversed');
            if (newActivePos === 'right') {
                crossFlowEl.classList.add('reversed');
            }
            
            leftRegionEl.classList.add('failover-in-progress');
            rightRegionEl.classList.add('failover-in-progress');
            
            // Update the active position
            standbyState.activePosition = newActivePos;
            
            // Update region components visibility (blob, shippers, injectors)
            updateRegionComponents(newActivePos);
            
            // Update status panel
            const leftIsNowActive = newActivePos === 'left';
            if (!standbyState.leftRegionDown) {
                document.getElementById('left-region-status').textContent = leftIsNowActive ? 'â— Active' : 'â— Standby';
                document.getElementById('left-region-status').className = 'status-value healthy';
            }
            if (!standbyState.rightRegionDown) {
                document.getElementById('right-region-status').textContent = leftIsNowActive ? 'â— Standby' : 'â— Active';
                document.getElementById('right-region-status').className = 'status-value healthy';
            }
            
            // Update replication status
            if (standbyState.leftRegionDown || standbyState.rightRegionDown) {
                crossFlowEl.classList.add('paused');
                document.getElementById('replication-status').textContent = 'â¸ Paused';
                document.getElementById('replication-status').className = 'status-value paused';
            } else {
                crossFlowEl.classList.remove('paused');
                document.getElementById('replication-status').textContent = 'âŸ³ Syncing';
                document.getElementById('replication-status').className = 'status-value syncing';
            }
            
            modal.classList.remove('visible');
            standbyState.failoverInProgress = false;
            
            // Reset step icons for next time
            steps.forEach(step => {
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
            });
            progressBar.style.width = '0%';
            
            logStandbyEvent(`âœ… Failover complete! ${newActivePos.toUpperCase()} is now Active`, 'success');
            if (isCurrentStandbyDown()) {
                logStandbyEvent('âš ï¸ New standby region is currently down', 'warning');
            }
            logStandbyEvent('ðŸ“ Update your connection strings to point to the new active region', 'info');
            
            updateFailoverButtonState();
        }

        // ============ SWITCHOVER (Planned) ============
        async function initiateSwitchover() {
            if (standbyState.failoverInProgress) return;
            if (standbyState.isSplit) {
                logStandbyEvent('âš ï¸ Cannot switchover: clusters are split', 'warning');
                return;
            }
            if (standbyState.leftRegionDown || standbyState.rightRegionDown) {
                logStandbyEvent('âš ï¸ Cannot switchover: both regions must be healthy', 'warning');
                return;
            }
            
            const currentActivePos = standbyState.activePosition;
            const newActivePos = currentActivePos === 'left' ? 'right' : 'left';
            
            standbyState.failoverInProgress = true;
            const modal = document.getElementById('failover-modal');
            const progressBar = document.getElementById('failover-progress-bar');
            const steps = document.querySelectorAll('.failover-step');
            
            // Update modal for switchover
            document.querySelector('#failover-modal h3').textContent = 'ðŸ”„ Switching Active Region';
            document.getElementById('failover-modal-text').textContent = 
                `Performing planned switchover: ${currentActivePos} â†’ ${newActivePos}...`;
            
            // Update step text for switchover
            const stepTexts = [
                'Lock active cluster (stop new writes)',
                'Wait for in-flight writes to complete',
                'Sync remaining oplogs to standby',
                'Verify data consistency',
                'Swap roles & update connection strings'
            ];
            steps.forEach((step, i) => {
                step.querySelector('span:last-child').textContent = stepTexts[i];
            });
            
            modal.classList.add('visible');
            document.getElementById('switchover-btn').disabled = true;
            document.getElementById('failover-btn').disabled = true;
            document.getElementById('splitover-btn').disabled = true;
            
            logStandbyEvent('ðŸ”„ Initiating planned switchover...', 'info');
            logStandbyEvent('ðŸ”’ Locking active cluster for writes', 'info');
            
            const stepDurations = [1000, 800, 1200, 1000, 800];
            let progress = 0;
            
            for (let i = 0; i < steps.length; i++) {
                steps[i].classList.add('active');
                steps[i].querySelector('.failover-step-icon').textContent = 'â³';
                
                await new Promise(resolve => setTimeout(resolve, stepDurations[i]));
                
                steps[i].classList.remove('active');
                steps[i].classList.add('complete');
                steps[i].querySelector('.failover-step-icon').textContent = 'âœ“';
                
                progress += 20;
                progressBar.style.width = progress + '%';
                
                logStandbyEvent(`âœ“ ${stepTexts[i]}`, 'success');
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Perform the actual role swap (same as failover)
            performRoleSwap(currentActivePos, newActivePos);
            
            modal.classList.remove('visible');
            standbyState.failoverInProgress = false;
            
            // Reset steps
            steps.forEach((step, i) => {
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
                // Reset to failover step text
                const failoverSteps = ['Stop writes to active cluster', 'Drain oplog queue', 
                    'Apply remaining oplogs to standby', 'Promote standby to active', 'Update DNS / connection strings'];
                step.querySelector('span:last-child').textContent = failoverSteps[i];
            });
            progressBar.style.width = '0%';
            document.querySelector('#failover-modal h3').textContent = 'ðŸ”„ Manual Failover in Progress';
            
            logStandbyEvent(`âœ… Switch complete! ${newActivePos.toUpperCase()} is now Active`, 'success');
            logStandbyEvent('ðŸ”“ Both clusters synchronized and operational', 'success');
            
            updateFailoverButtonState();
        }

        // ============ SPLITOVER (Emergency Split) ============
        async function initiateSplitover() {
            if (standbyState.failoverInProgress) return;
            if (standbyState.isSplit) {
                logStandbyEvent('âš ï¸ Clusters are already split', 'warning');
                return;
            }
            
            standbyState.failoverInProgress = true;
            
            // Setup modal
            const modal = document.getElementById('failover-modal');
            const progressBar = document.getElementById('failover-progress-bar');
            const steps = document.querySelectorAll('.failover-step');
            
            // Update modal for split clusters
            document.querySelector('#failover-modal h3').textContent = 'âœ‚ï¸ Splitting Clusters';
            document.getElementById('failover-modal-text').textContent = 
                'âš ï¸ WARNING: This will make both clusters independent!';
            
            // Update step text for split (5 steps)
            const stepTexts = [
                'Stop cross-region replication',
                'Disconnect cluster link',
                'Promote standby to independent',
                'Update cluster configurations',
                'Finalize split operation'
            ];
            
            steps.forEach((step, i) => {
                if (i < 5) {
                    step.style.display = '';
                    step.querySelector('span:last-child').textContent = stepTexts[i];
                } else {
                    step.style.display = 'none'; // Hide 6th step
                }
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
            });
            
            progressBar.style.width = '0%';
            modal.classList.add('visible');
            
            // Disable all operation buttons
            document.getElementById('splitover-btn').disabled = true;
            document.getElementById('switchover-btn').disabled = true;
            document.getElementById('failover-btn').disabled = true;
            
            // Step 1: Stop cross-region replication
            steps[0].classList.add('active');
            logStandbyEvent('âœ‚ï¸ Step 1/5: Stopping cross-region replication...', 'warning');
            logStandbyEvent('âš ï¸ WARNING: This will make both clusters independent!', 'error');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Visual feedback - pause cross region flow
            const crossFlowEl = document.getElementById('cross-region-flow');
            crossFlowEl.classList.add('paused');
            
            steps[0].classList.remove('active');
            steps[0].classList.add('complete');
            steps[0].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '20%';
            logStandbyEvent('âœ“ Cross-region replication stopped', 'success');
            
            // Step 2: Disconnect cluster link
            steps[1].classList.add('active');
            logStandbyEvent('ðŸ”Œ Step 2/5: Disconnecting cluster link...', 'warning');
            await new Promise(resolve => setTimeout(resolve, 700));
            
            // Hide shippers/injectors on both sides
            setElementDisplay('left-shippers', 'none');
            setElementDisplay('left-cluster-pull', 'none');
            setElementDisplay('right-shippers', 'none');
            setElementDisplay('right-cluster-pull', 'none');
            setElementDisplay('left-coordinator', 'none');
            setElementDisplay('left-injectors', 'none');
            setElementDisplay('left-injector-push', 'none');
            setElementDisplay('left-storage-pull', 'none');
            setElementDisplay('left-blob-input', 'none');
            setElementDisplay('left-blob-output', 'none');
            setElementDisplay('right-coordinator', 'none');
            setElementDisplay('right-injectors', 'none');
            setElementDisplay('right-injector-push', 'none');
            setElementDisplay('right-storage-pull', 'none');
            setElementDisplay('right-blob-input', 'none');
            setElementDisplay('right-blob-output', 'none');
            
            steps[1].classList.remove('active');
            steps[1].classList.add('complete');
            steps[1].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '40%';
            logStandbyEvent('âœ“ Cluster link disconnected', 'success');
            
            // Step 3: Promote standby to independent
            steps[2].classList.add('active');
            logStandbyEvent('â¬†ï¸ Step 3/5: Promoting standby to independent cluster...', 'info');
            await new Promise(resolve => setTimeout(resolve, 900));
            
            // Mark as split
            standbyState.isSplit = true;
            
            // Update both clusters to show as independent/active
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            
            // Add split mode class
            leftRegionEl.classList.add('split-mode');
            rightRegionEl.classList.add('split-mode');
            
            // Both become active clusters
            const leftHeader = leftRegionEl.querySelector('.region-header');
            const rightHeader = rightRegionEl.querySelector('.region-header');
            
            leftHeader.classList.remove('standby');
            leftHeader.classList.add('active');
            leftHeader.querySelector('.region-name').textContent = 'INDEPENDENT CLUSTER';
            leftHeader.querySelector('.region-status').textContent = 'â— Active (Split)';
            leftHeader.querySelector('.region-icon').textContent = 'ðŸ”´';
            
            rightHeader.classList.remove('standby');
            rightHeader.classList.add('active');
            rightHeader.querySelector('.region-name').textContent = 'INDEPENDENT CLUSTER';
            rightHeader.querySelector('.region-status').textContent = 'â— Active (Split)';
            rightHeader.querySelector('.region-icon').textContent = 'ðŸ”´';
            
            // Update cluster boxes
            const leftCluster = leftRegionEl.querySelector('.cluster-box');
            const rightCluster = rightRegionEl.querySelector('.cluster-box');
            
            leftCluster.classList.remove('standby-cluster');
            leftCluster.classList.add('active-cluster', 'independent');
            leftCluster.querySelector('.cluster-label').textContent = 'INDEPENDENT CLUSTER';
            
            rightCluster.classList.remove('standby-cluster');
            rightCluster.classList.add('active-cluster', 'independent');
            rightCluster.querySelector('.cluster-label').textContent = 'INDEPENDENT CLUSTER';
            
            // Remove sublabels
            const sublabels = document.querySelectorAll('.cluster-sublabel');
            sublabels.forEach(s => s.remove());
            
            // Both clusters get primaries
            updateNodesAfterFailover(leftRegionEl, 'active');
            updateNodesAfterFailover(rightRegionEl, 'active');
            
            steps[2].classList.remove('active');
            steps[2].classList.add('complete');
            steps[2].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '60%';
            logStandbyEvent('âœ“ Standby promoted to independent cluster', 'success');
            
            // Step 4: Update cluster configurations
            steps[3].classList.add('active');
            logStandbyEvent('âš™ï¸ Step 4/5: Updating cluster configurations...', 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Update status panel
            document.getElementById('left-region-status').textContent = 'â— Independent';
            document.getElementById('left-region-status').className = 'status-value';
            document.getElementById('left-region-status').style.color = '#e63946';
            
            document.getElementById('right-region-status').textContent = 'â— Independent';
            document.getElementById('right-region-status').className = 'status-value';
            document.getElementById('right-region-status').style.color = '#e63946';
            
            document.getElementById('replication-status').textContent = 'âœ– Severed';
            document.getElementById('replication-status').className = 'status-value';
            document.getElementById('replication-status').style.color = '#e63946';
            
            steps[3].classList.remove('active');
            steps[3].classList.add('complete');
            steps[3].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '80%';
            logStandbyEvent('âœ“ Cluster configurations updated', 'success');
            
            // Step 5: Finalize split operation
            steps[4].classList.add('active');
            logStandbyEvent('ðŸ Step 5/5: Finalizing split operation...', 'info');
            await new Promise(resolve => setTimeout(resolve, 600));
            
            // Update cross-region label
            document.querySelector('.cross-region-label').innerHTML = 'CONNECTION<br/>SEVERED';
            document.getElementById('flow-desc').innerHTML = 'âœ‚ï¸ No replication';
            document.getElementById('arrow-direction').textContent = 'âœ–âœ–âœ–';
            
            steps[4].classList.remove('active');
            steps[4].classList.add('complete');
            steps[4].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '100%';
            logStandbyEvent('âœ“ Split operation finalized', 'success');
            
            // Brief pause to show 100% completion
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Hide modal and reset
            modal.classList.remove('visible');
            
            // Reset modal for future use
            const defaultStepTexts = [
                'Stop writes to active cluster',
                'Drain oplog queue',
                'Apply remaining oplogs to standby',
                'Promote standby to active',
                'Update DNS / connection strings',
                'Reconfigure DNS settings'
            ];
            steps.forEach((step, i) => {
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
                if (i < defaultStepTexts.length) {
                    step.querySelector('span:last-child').textContent = defaultStepTexts[i];
                }
                if (i === 5) {
                    step.style.display = 'none';
                }
            });
            progressBar.style.width = '0%';
            document.querySelector('#failover-modal h3').textContent = 'ðŸ”„ Manual Failover in Progress';
            
            standbyState.failoverInProgress = false;
            
            logStandbyEvent('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
            logStandbyEvent('âœ‚ï¸ CLUSTERS ARE NOW SPLIT AND INDEPENDENT', 'error');
            logStandbyEvent('âš ï¸ Both clusters accepting writes independently', 'warning');
            logStandbyEvent('âš ï¸ DATA DIVERGENCE will occur!', 'error');
            logStandbyEvent('ðŸ“ Use "Setup Standby" to re-establish replication', 'info');
            logStandbyEvent('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
            
            updateFailoverButtonState();
            updateSetupStandbyButton();
        }

        // ============ SETUP STANDBY (Re-establish relationship) ============
        async function setupStandby() {
            if (!standbyState.isSplit) {
                logStandbyEvent('âš ï¸ Clusters are not split', 'warning');
                return;
            }
            
            // Check both regions are healthy (not down)
            if (standbyState.leftRegionDown || standbyState.rightRegionDown) {
                logStandbyEvent('âš ï¸ Cannot setup standby: both regions must be healthy', 'warning');
                return;
            }
            
            standbyState.failoverInProgress = true;
            
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            
            // Setup modal
            const modal = document.getElementById('failover-modal');
            const progressBar = document.getElementById('failover-progress-bar');
            const steps = document.querySelectorAll('.failover-step');
            
            // Update modal for setup standby
            document.querySelector('#failover-modal h3').textContent = 'ðŸ”— Setting Up Standby Cluster';
            document.getElementById('failover-modal-text').textContent = 
                'Re-establishing Active-Standby relationship...';
            
            // Update step text for setup standby (6 steps)
            const stepTexts = [
                'Create standby cluster nodes',
                'Sync data from existing cluster',
                'Convert to standby mode',
                'Restore oplog streaming',
                'Enable shippers & injectors',
                'Reconfigure DNS settings'
            ];
            
            // Show 6th step and update all step texts
            steps.forEach((step, i) => {
                step.style.display = ''; // Show all steps including 6th
                if (i < stepTexts.length) {
                    step.querySelector('span:last-child').textContent = stepTexts[i];
                }
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
            });
            
            progressBar.style.width = '0%';
            modal.classList.add('visible');
            
            // Disable all operation buttons
            document.getElementById('setup-standby-btn').disabled = true;
            document.getElementById('switchover-btn').disabled = true;
            document.getElementById('failover-btn').disabled = true;
            document.getElementById('splitover-btn').disabled = true;
            
            // Step 1: Creating standby cluster
            steps[0].classList.add('active');
            logStandbyEvent('ðŸ”§ Step 1/6: Creating standby cluster...', 'info');
            logStandbyEvent('   â†’ Provisioning nodes in right region', 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Remove split mode visuals
            leftRegionEl.classList.remove('split-mode');
            rightRegionEl.classList.remove('split-mode');
            document.querySelectorAll('.cluster-box.independent').forEach(el => {
                el.classList.remove('independent');
            });
            
            steps[0].classList.remove('active');
            steps[0].classList.add('complete');
            steps[0].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '17%';
            logStandbyEvent('âœ“ Standby cluster nodes provisioned', 'success');
            
            // Step 2: Syncing data from existing cluster
            steps[1].classList.add('active');
            logStandbyEvent('ðŸ“¦ Step 2/6: Syncing data from existing cluster...', 'info');
            logStandbyEvent('   â†’ Creating initial snapshot from left cluster', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            logStandbyEvent('   â†’ Transferring data to right cluster...', 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            steps[1].classList.remove('active');
            steps[1].classList.add('complete');
            steps[1].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '34%';
            logStandbyEvent('âœ“ Initial data sync complete', 'success');
            
            // Step 3: Converting right cluster to standby mode
            steps[2].classList.add('active');
            logStandbyEvent('ðŸ”„ Step 3/6: Converting right cluster to standby mode...', 'info');
            logStandbyEvent('   â†’ Stopping writes on right cluster', 'info');
            await new Promise(resolve => setTimeout(resolve, 600));
            logStandbyEvent('   â†’ Demoting primaries to secondaries', 'info');
            
            // Reset to initial state - left active, right standby
            standbyState.isSplit = false;
            standbyState.activePosition = 'left';
            
            // Update headers
            const leftHeader = leftRegionEl.querySelector('.region-header');
            const rightHeader = rightRegionEl.querySelector('.region-header');
            
            leftHeader.classList.add('active');
            leftHeader.classList.remove('standby');
            leftHeader.querySelector('.region-name').textContent = 'ACTIVE REGION';
            leftHeader.querySelector('.region-status').textContent = 'â— Primary';
            leftHeader.querySelector('.region-icon').textContent = 'ðŸ”µ';
            
            rightHeader.classList.add('standby');
            rightHeader.classList.remove('active');
            rightHeader.querySelector('.region-name').textContent = 'STANDBY REGION';
            rightHeader.querySelector('.region-status').textContent = 'â—‹ Standby';
            rightHeader.querySelector('.region-icon').textContent = 'ðŸŸ¢';
            
            // Update cluster boxes
            const leftCluster = leftRegionEl.querySelector('.cluster-box');
            const rightCluster = rightRegionEl.querySelector('.cluster-box');
            
            leftCluster.classList.add('active-cluster');
            leftCluster.classList.remove('standby-cluster');
            leftCluster.querySelector('.cluster-label').textContent = 'ACTIVE CLUSTER';
            
            rightCluster.classList.add('standby-cluster');
            rightCluster.classList.remove('active-cluster');
            rightCluster.querySelector('.cluster-label').textContent = 'STANDBY CLUSTER';
            
            // Add sublabel to standby
            let rightSublabel = rightCluster.querySelector('.cluster-sublabel');
            if (!rightSublabel) {
                rightSublabel = document.createElement('div');
                rightSublabel.className = 'cluster-sublabel';
                rightCluster.querySelector('.cluster-label').after(rightSublabel);
            }
            rightSublabel.textContent = '(All Secondaries)';
            
            // Remove sublabel from active
            const leftSublabel = leftCluster.querySelector('.cluster-sublabel');
            if (leftSublabel) leftSublabel.remove();
            
            // Update nodes
            updateNodesAfterFailover(leftRegionEl, 'active');
            updateNodesAfterFailover(rightRegionEl, 'standby');
            
            // Reset node states
            syncNodeStatesToRole('left', 'active');
            syncNodeStatesToRole('right', 'standby');
            
            await new Promise(resolve => setTimeout(resolve, 600));
            
            steps[2].classList.remove('active');
            steps[2].classList.add('complete');
            steps[2].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '50%';
            logStandbyEvent('âœ“ Right cluster converted to standby mode', 'success');
            
            // Step 4: Restoring oplog streaming
            steps[3].classList.add('active');
            logStandbyEvent('ðŸ“¡ Step 4/6: Restoring oplog streaming...', 'info');
            logStandbyEvent('   â†’ Configuring cluster link between regions', 'info');
            await new Promise(resolve => setTimeout(resolve, 700));
            
            // Restore cross-region flow
            const crossFlowEl = document.getElementById('cross-region-flow');
            crossFlowEl.classList.remove('paused');
            document.querySelector('.cross-region-label').innerHTML = 'CROSS-REGION<br/>OPLOG SYNC';
            document.getElementById('flow-desc').innerHTML = 'push oplog to<br/>standby blob store';
            document.getElementById('arrow-direction').textContent = 'â†’â†’â†’';
            
            logStandbyEvent('   â†’ Oplog streaming from left â†’ right blob store', 'info');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            steps[3].classList.remove('active');
            steps[3].classList.add('complete');
            steps[3].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '67%';
            logStandbyEvent('âœ“ Oplog streaming established', 'success');
            
            // Step 5: Re-enabling shippers, injectors, and cross-region flow
            steps[4].classList.add('active');
            logStandbyEvent('âš™ï¸ Step 5/6: Re-enabling shippers, injectors, and cross-region flow...', 'info');
            logStandbyEvent('   â†’ Starting shippers on active cluster', 'info');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Restore region components
            updateRegionComponents('left');
            
            logStandbyEvent('   â†’ Starting injectors on standby cluster', 'info');
            await new Promise(resolve => setTimeout(resolve, 500));
            logStandbyEvent('   â†’ Enabling cross-region replication flow', 'info');
            await new Promise(resolve => setTimeout(resolve, 400));
            
            steps[4].classList.remove('active');
            steps[4].classList.add('complete');
            steps[4].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '84%';
            logStandbyEvent('âœ“ All cluster link components active', 'success');
            
            // Step 6: Reconfigure DNS settings
            steps[5].classList.add('active');
            document.getElementById('failover-modal-text').textContent = 
                'Finalizing DNS configuration...';
            logStandbyEvent('ðŸŒ Step 6/6: Reconfiguring DNS settings...', 'info');
            logStandbyEvent('   â†’ Updating connection string endpoints', 'info');
            await new Promise(resolve => setTimeout(resolve, 500));
            logStandbyEvent('   â†’ Setting TTL for DNS records', 'info');
            await new Promise(resolve => setTimeout(resolve, 400));
            logStandbyEvent('   â†’ Verifying DNS propagation', 'info');
            await new Promise(resolve => setTimeout(resolve, 600));
            
            steps[5].classList.remove('active');
            steps[5].classList.add('complete');
            steps[5].querySelector('.failover-step-icon').textContent = 'âœ“';
            progressBar.style.width = '100%';
            logStandbyEvent('âœ“ DNS configuration complete', 'success');
            
            // Update status panel
            document.getElementById('left-region-status').textContent = 'â— Active';
            document.getElementById('left-region-status').className = 'status-value healthy';
            document.getElementById('left-region-status').style.color = '';
            
            document.getElementById('right-region-status').textContent = 'â— Standby';
            document.getElementById('right-region-status').className = 'status-value healthy';
            document.getElementById('right-region-status').style.color = '';
            
            document.getElementById('replication-status').textContent = 'âŸ³ Syncing';
            document.getElementById('replication-status').className = 'status-value syncing';
            document.getElementById('replication-status').style.color = '';
            
            // Brief pause to show 100% completion
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Hide modal and reset
            modal.classList.remove('visible');
            
            // Reset modal for future use
            const defaultStepTexts = [
                'Stop writes to active cluster',
                'Drain oplog queue',
                'Apply remaining oplogs to standby',
                'Promote standby to active',
                'Update DNS / connection strings',
                'Reconfigure DNS settings'
            ];
            steps.forEach((step, i) => {
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
                if (i < defaultStepTexts.length) {
                    step.querySelector('span:last-child').textContent = defaultStepTexts[i];
                }
                // Hide the 6th step by default (only used for setup standby)
                if (i === 5) {
                    step.style.display = 'none';
                }
            });
            progressBar.style.width = '0%';
            document.querySelector('#failover-modal h3').textContent = 'ðŸ”„ Manual Failover in Progress';
            
            standbyState.failoverInProgress = false;
            
            logStandbyEvent('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
            logStandbyEvent('âœ… STANDBY SETUP COMPLETE!', 'success');
            logStandbyEvent('ðŸ”µ Left Region = ACTIVE (Primary)', 'info');
            logStandbyEvent('ðŸŸ¢ Right Region = STANDBY (All Secondaries)', 'info');
            logStandbyEvent('ðŸ“¡ Oplog streaming: Active â†’ Standby', 'info');
            logStandbyEvent('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
            
            updateFailoverButtonState();
            updateSetupStandbyButton();
        }

        function updateSetupStandbyButton() {
            const setupBtn = document.getElementById('setup-standby-btn');
            const splitoverHint = document.getElementById('splitover-hint');
            
            if (standbyState.isSplit) {
                // Show setup standby button, hide splitover
                setupBtn.style.display = '';
                document.getElementById('splitover-btn').style.display = 'none';
                
                // Check if both regions are healthy
                const bothHealthy = !standbyState.leftRegionDown && !standbyState.rightRegionDown;
                setupBtn.disabled = !bothHealthy || standbyState.failoverInProgress;
                
                if (bothHealthy) {
                    splitoverHint.textContent = 'Setup Standby: Re-establish replication âœ“';
                    splitoverHint.style.color = 'rgba(0, 237, 100, 0.8)';
                } else {
                    splitoverHint.textContent = 'Setup Standby: Requires both regions healthy';
                    splitoverHint.style.color = 'rgba(255, 107, 107, 0.8)';
                }
            } else {
                // Show splitover button, hide setup standby
                setupBtn.style.display = 'none';
                document.getElementById('splitover-btn').style.display = '';
                splitoverHint.textContent = 'Split Clusters: Both become independent';
                splitoverHint.style.color = '';
            }
        }

        // Helper function to perform the actual role swap
        function performRoleSwap(currentActivePos, newActivePos) {
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            
            const leftHeader = leftRegionEl.querySelector('.region-header');
            const rightHeader = rightRegionEl.querySelector('.region-header');
            
            if (newActivePos === 'right') {
                // Left becomes standby, right becomes active
                leftHeader.classList.remove('active');
                leftHeader.classList.add('standby');
                leftHeader.querySelector('.region-name').textContent = 'STANDBY REGION';
                leftHeader.querySelector('.region-icon').textContent = 'ðŸŸ¢';
                leftHeader.querySelector('.region-status').textContent = standbyState.leftRegionDown ? 'âœ– Down' : 'â—‹ Standby';
                
                rightHeader.classList.remove('standby');
                rightHeader.classList.add('active');
                rightHeader.querySelector('.region-name').textContent = 'ACTIVE REGION';
                rightHeader.querySelector('.region-icon').textContent = 'ðŸ”µ';
                rightHeader.querySelector('.region-status').textContent = 'â— Primary';
                
                // Update cluster labels
                leftRegionEl.querySelector('.cluster-label').textContent = 'STANDBY CLUSTER';
                let leftSublabel = leftRegionEl.querySelector('.cluster-sublabel');
                if (!leftSublabel) {
                    leftSublabel = document.createElement('div');
                    leftSublabel.className = 'cluster-sublabel';
                    leftRegionEl.querySelector('.cluster-label').after(leftSublabel);
                }
                leftSublabel.textContent = '(All Secondaries)';
                
                rightRegionEl.querySelector('.cluster-label').textContent = 'ACTIVE CLUSTER';
                const rightSublabel = rightRegionEl.querySelector('.cluster-sublabel');
                if (rightSublabel) rightSublabel.remove();
                
                // Update nodes
                updateNodesAfterFailover(leftRegionEl, 'standby');
                updateNodesAfterFailover(rightRegionEl, 'active');
                
                // Update arrows
                document.getElementById('arrow-direction').textContent = 'â†â†â†';
            } else {
                // Right becomes standby, left becomes active
                rightHeader.classList.remove('active');
                rightHeader.classList.add('standby');
                rightHeader.querySelector('.region-name').textContent = 'STANDBY REGION';
                rightHeader.querySelector('.region-icon').textContent = 'ðŸŸ¢';
                rightHeader.querySelector('.region-status').textContent = standbyState.rightRegionDown ? 'âœ– Down' : 'â—‹ Standby';
                
                leftHeader.classList.remove('standby');
                leftHeader.classList.add('active');
                leftHeader.querySelector('.region-name').textContent = 'ACTIVE REGION';
                leftHeader.querySelector('.region-icon').textContent = 'ðŸ”µ';
                leftHeader.querySelector('.region-status').textContent = 'â— Primary';
                
                // Update cluster labels
                rightRegionEl.querySelector('.cluster-label').textContent = 'STANDBY CLUSTER';
                let rightSublabel = rightRegionEl.querySelector('.cluster-sublabel');
                if (!rightSublabel) {
                    rightSublabel = document.createElement('div');
                    rightSublabel.className = 'cluster-sublabel';
                    rightRegionEl.querySelector('.cluster-label').after(rightSublabel);
                }
                rightSublabel.textContent = '(All Secondaries)';
                
                leftRegionEl.querySelector('.cluster-label').textContent = 'ACTIVE CLUSTER';
                const leftSublabel = leftRegionEl.querySelector('.cluster-sublabel');
                if (leftSublabel) leftSublabel.remove();
                
                // Update nodes
                updateNodesAfterFailover(rightRegionEl, 'standby');
                updateNodesAfterFailover(leftRegionEl, 'active');
                
                // Update arrows
                document.getElementById('arrow-direction').textContent = 'â†’â†’â†’';
            }
            
            // Update flow direction
            const crossFlowEl = document.getElementById('cross-region-flow');
            crossFlowEl.classList.remove('reversed');
            if (newActivePos === 'right') {
                crossFlowEl.classList.add('reversed');
            }
            
            // Update region components
            updateRegionComponents(newActivePos);
            
            // Update active position
            standbyState.activePosition = newActivePos;
            
            // Update status panel
            const leftIsNowActive = newActivePos === 'left';
            if (!standbyState.leftRegionDown) {
                document.getElementById('left-region-status').textContent = leftIsNowActive ? 'â— Active' : 'â— Standby';
                document.getElementById('left-region-status').className = 'status-value healthy';
                document.getElementById('left-region-status').style.color = '';
            }
            if (!standbyState.rightRegionDown) {
                document.getElementById('right-region-status').textContent = leftIsNowActive ? 'â— Standby' : 'â— Active';
                document.getElementById('right-region-status').className = 'status-value healthy';
                document.getElementById('right-region-status').style.color = '';
            }
            
            // Sync node states
            syncNodeStatesToRole(newActivePos === 'left' ? 'right' : 'left', 'standby');
            syncNodeStatesToRole(newActivePos, 'active');
        }
        
        function updateNodesAfterFailover(regionEl, newRole) {
            const nodes = regionEl.querySelectorAll('.shard-nodes .mini-node');
            const clusterBox = regionEl.querySelector('.cluster-box');
            
            if (newRole === 'active') {
                // Active region: brighter nodes, first node of each shard becomes Primary
                if (clusterBox) {
                    clusterBox.classList.remove('standby-cluster');
                    clusterBox.classList.add('active-cluster');
                }
                nodes.forEach(node => {
                    node.classList.remove('standby-node'); // Remove dim styling
                });
                const shardBoxes = regionEl.querySelectorAll('.shard-box');
                shardBoxes.forEach(shard => {
                    const shardNodes = shard.querySelectorAll('.mini-node');
                    shardNodes.forEach((node, idx) => {
                        if (idx === 0) {
                            node.classList.remove('secondary');
                            node.classList.add('primary');
                            node.querySelector('.node-letter').textContent = 'P';
                            node.title = 'Click to fail/recover';
                        }
                    });
                });
            } else {
                // Standby region: dimmer nodes, all become Secondary
                if (clusterBox) {
                    clusterBox.classList.remove('active-cluster');
                    clusterBox.classList.add('standby-cluster');
                }
                nodes.forEach(node => {
                    node.classList.add('standby-node'); // Add dim styling
                    node.classList.remove('primary');
                    node.classList.add('secondary');
                    node.querySelector('.node-letter').textContent = 'S';
                    node.title = 'Click to fail/recover';
                });
            }
        }

        // ============ NODE STATE MANAGEMENT ============
        // Track node states: { 'left-s0-n0': { status: 'healthy', role: 'primary' }, ... }
        const nodeStates = {
            left: {
                0: [{ status: 'healthy', role: 'primary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }],
                1: [{ status: 'healthy', role: 'primary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }]
            },
            right: {
                0: [{ status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }],
                1: [{ status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }]
            }
        };

        let standbyWriteConcern = 'majority';
        let standbyReadPreference = 'secondaryPreferred';

        function initStandbyWcPills() {
            document.querySelectorAll('#standby-wc-pills .wc-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    document.querySelectorAll('#standby-wc-pills .wc-pill').forEach(p => p.classList.remove('selected'));
                    pill.classList.add('selected');
                    standbyWriteConcern = pill.dataset.value;
                    logStandbyEvent(`Write concern: w:${standbyWriteConcern}`, 'info');
                });
            });

            document.getElementById('standby-read-pref').addEventListener('change', (e) => {
                standbyReadPreference = e.target.value;
                logStandbyEvent(`Read preference: ${standbyReadPreference}`, 'info');
            });
        }

        function toggleStandbyNode(region, shardIdx, nodeIdx) {
            const nodeState = nodeStates[region][shardIdx][nodeIdx];
            const nodeEl = document.getElementById(`${region}-s${shardIdx}-n${nodeIdx}`);
            const activePos = standbyState.activePosition;
            const isActiveRegion = region === activePos;
            
            if (nodeState.status === 'healthy') {
                // Fail the node
                nodeState.status = 'down';
                nodeEl.classList.add('down');
                nodeEl.classList.remove('primary', 'secondary');
                nodeEl.querySelector('.node-letter').textContent = 'âœ–';
                
                const wasRole = nodeState.role;
                const clusterLabel = isActiveRegion ? 'Active' : 'Standby';
                logStandbyEvent(`ðŸ’¥ ${clusterLabel} cluster: Node s${shardIdx}-n${nodeIdx} (${wasRole}) failed!`, 'error');
                
                // If primary failed, trigger election
                if (wasRole === 'primary') {
                    triggerStandbyElection(region, shardIdx);
                }
            } else if (nodeState.status === 'down') {
                // Recover the node
                nodeState.status = 'recovering';
                nodeEl.classList.remove('down');
                nodeEl.classList.add('recovering');
                nodeEl.querySelector('.node-letter').textContent = '...';
                
                const clusterLabel = isActiveRegion ? 'Active' : 'Standby';
                logStandbyEvent(`ðŸ”„ ${clusterLabel} cluster: Node s${shardIdx}-n${nodeIdx} recovering...`, 'info');
                
                setTimeout(() => {
                    nodeState.status = 'healthy';
                    nodeEl.classList.remove('recovering');
                    
                    // Rejoin as secondary
                    nodeState.role = 'secondary';
                    nodeEl.classList.add('secondary');
                    nodeEl.querySelector('.node-letter').textContent = 'S';
                    
                    logStandbyEvent(`âœ… ${clusterLabel} cluster: Node s${shardIdx}-n${nodeIdx} recovered as Secondary`, 'success');
                }, 2000);
            }
            // If recovering, do nothing (wait for it to finish)
        }

        function triggerStandbyElection(region, shardIdx) {
            const activePos = standbyState.activePosition;
            const clusterLabel = region === activePos ? 'Active' : 'Standby';
            
            logStandbyEvent(`ðŸ—³ï¸ ${clusterLabel} cluster: Election started for shard ${shardIdx}...`, 'warning');
            
            // Find a healthy secondary to promote
            const shardNodes = nodeStates[region][shardIdx];
            let newPrimaryIdx = -1;
            
            for (let i = 0; i < shardNodes.length; i++) {
                if (shardNodes[i].status === 'healthy' && shardNodes[i].role === 'secondary') {
                    newPrimaryIdx = i;
                    break;
                }
            }
            
            setTimeout(() => {
                if (newPrimaryIdx >= 0) {
                    // Promote the secondary
                    shardNodes[newPrimaryIdx].role = 'primary';
                    const nodeEl = document.getElementById(`${region}-s${shardIdx}-n${newPrimaryIdx}`);
                    nodeEl.classList.remove('secondary');
                    nodeEl.classList.add('primary');
                    nodeEl.querySelector('.node-letter').textContent = 'P';
                    
                    logStandbyEvent(`âœ… ${clusterLabel} cluster: Node s${shardIdx}-n${newPrimaryIdx} elected as new Primary!`, 'success');
                } else {
                    // No healthy secondary available - no majority
                    logStandbyEvent(`âŒ ${clusterLabel} cluster: Election failed for shard ${shardIdx} - no majority available!`, 'error');
                }
            }, 1500);
        }

        function getActiveClusterPosition() {
            return standbyState.activePosition;
        }

        function getStandbyHealthyPrimary(region, shardIdx) {
            const shardNodes = nodeStates[region][shardIdx];
            for (let i = 0; i < shardNodes.length; i++) {
                if (shardNodes[i].status === 'healthy' && shardNodes[i].role === 'primary') {
                    return { idx: i, el: document.getElementById(`${region}-s${shardIdx}-n${i}`) };
                }
            }
            return null;
        }

        function getStandbyHealthySecondaries(region, shardIdx) {
            const shardNodes = nodeStates[region][shardIdx];
            const secondaries = [];
            for (let i = 0; i < shardNodes.length; i++) {
                if (shardNodes[i].status === 'healthy' && shardNodes[i].role === 'secondary') {
                    secondaries.push({ idx: i, el: document.getElementById(`${region}-s${shardIdx}-n${i}`) });
                }
            }
            return secondaries;
        }

        function getStandbyHealthyNodes(region, shardIdx) {
            const shardNodes = nodeStates[region][shardIdx];
            const healthy = [];
            for (let i = 0; i < shardNodes.length; i++) {
                if (shardNodes[i].status === 'healthy') {
                    healthy.push({ idx: i, el: document.getElementById(`${region}-s${shardIdx}-n${i}`), role: shardNodes[i].role });
                }
            }
            return healthy;
        }

        async function standbyInsert() {
            await performStandbyWrite('insert');
        }

        async function standbyUpdate() {
            await performStandbyWrite('update');
        }

        async function performStandbyWrite(opType) {
            const activePos = getActiveClusterPosition();
            
            // Check if active region is down
            if ((activePos === 'left' && standbyState.leftRegionDown) || 
                (activePos === 'right' && standbyState.rightRegionDown)) {
                logStandbyEvent(`âŒ Write failed: Active region is down`, 'error');
                return;
            }
            
            const shardIdx = Math.floor(Math.random() * 2); // Pick random shard
            
            // Check for primary
            const primary = getStandbyHealthyPrimary(activePos, shardIdx);
            if (!primary) {
                logStandbyEvent(`âŒ Write failed: No primary available for shard ${shardIdx}`, 'error');
                return;
            }
            
            // Determine required acknowledgments
            const healthyNodes = getStandbyHealthyNodes(activePos, shardIdx);
            const totalNodes = 3; // Each shard has 3 nodes
            const majority = Math.floor(totalNodes / 2) + 1; // 2
            let requiredAcks = 1;
            
            if (standbyWriteConcern === 'majority') {
                requiredAcks = majority;
            } else if (standbyWriteConcern === 'all') {
                requiredAcks = totalNodes;
            }
            
            // For w:all, check if all nodes are healthy BEFORE attempting write
            if (standbyWriteConcern === 'all' && healthyNodes.length < totalNodes) {
                const downCount = totalNodes - healthyNodes.length;
                logStandbyEvent(`âŒ Write failed: w:all requires all ${totalNodes} nodes`, 'error');
                logStandbyEvent(`   â†’ ${downCount} node(s) in shard ${shardIdx} are down`, 'error');
                logStandbyEvent(`   â†’ Cannot satisfy write concern {w: "all"}`, 'warning');
                
                // Flash primary red to indicate failure
                primary.el.classList.add('write-failed');
                setTimeout(() => primary.el.classList.remove('write-failed'), 500);
                return;
            }
            
            // For w:majority, check if we have enough nodes
            if (standbyWriteConcern === 'majority' && healthyNodes.length < majority) {
                logStandbyEvent(`âŒ Write failed: w:majority requires ${majority} nodes`, 'error');
                logStandbyEvent(`   â†’ Only ${healthyNodes.length} healthy node(s) in shard ${shardIdx}`, 'error');
                
                // Flash primary red to indicate failure
                primary.el.classList.add('write-failed');
                setTimeout(() => primary.el.classList.remove('write-failed'), 500);
                return;
            }
            
            // Flash the primary
            primary.el.classList.add('write-target');
            logStandbyEvent(`âœï¸ ${opType === 'insert' ? 'Insert' : 'Update'} â†’ Primary (shard ${shardIdx})`, 'info');
            
            await new Promise(r => setTimeout(r, 300));
            primary.el.classList.remove('write-target');
            
            // Replicate to secondaries
            const secondaries = getStandbyHealthySecondaries(activePos, shardIdx);
            let ackCount = 1; // Primary already acked
            
            for (const sec of secondaries) {
                if (ackCount >= requiredAcks) {
                    break;
                }
                await new Promise(r => setTimeout(r, 200));
                sec.el.classList.add('replicating');
                ackCount++;
                
                setTimeout(() => sec.el.classList.remove('replicating'), 300);
            }
            
            await new Promise(r => setTimeout(r, 200));
            
            if (ackCount >= requiredAcks) {
                logStandbyEvent(`âœ… Write acknowledged (w:${standbyWriteConcern}, ${ackCount}/${requiredAcks} acks)`, 'success');
            } else {
                logStandbyEvent(`âš ï¸ Write may not be durable (only ${ackCount}/${requiredAcks} acks)`, 'warning');
            }
        }

        async function standbyRead() {
            const activePos = getActiveClusterPosition();
            
            // Check if active region is down
            if ((activePos === 'left' && standbyState.leftRegionDown) || 
                (activePos === 'right' && standbyState.rightRegionDown)) {
                logStandbyEvent(`âŒ Read failed: Active region is down`, 'error');
                return;
            }
            
            const shardIdx = Math.floor(Math.random() * 2);
            
            let targetNode = null;
            let targetDesc = '';
            
            switch (standbyReadPreference) {
                case 'primary':
                    targetNode = getStandbyHealthyPrimary(activePos, shardIdx);
                    targetDesc = 'Primary';
                    if (!targetNode) {
                        logStandbyEvent(`âŒ Read failed: No primary available`, 'error');
                        return;
                    }
                    break;
                    
                case 'primaryPreferred':
                    targetNode = getStandbyHealthyPrimary(activePos, shardIdx);
                    targetDesc = 'Primary';
                    if (!targetNode) {
                        const secs = getStandbyHealthySecondaries(activePos, shardIdx);
                        if (secs.length > 0) {
                            targetNode = secs[0];
                            targetDesc = 'Secondary (primary unavailable)';
                        }
                    }
                    break;
                    
                case 'secondary':
                    const secs = getStandbyHealthySecondaries(activePos, shardIdx);
                    if (secs.length > 0) {
                        targetNode = secs[Math.floor(Math.random() * secs.length)];
                        targetDesc = 'Secondary';
                    } else {
                        logStandbyEvent(`âŒ Read failed: No secondary available`, 'error');
                        return;
                    }
                    break;
                    
                case 'secondaryPreferred':
                    const secsP = getStandbyHealthySecondaries(activePos, shardIdx);
                    if (secsP.length > 0) {
                        targetNode = secsP[Math.floor(Math.random() * secsP.length)];
                        targetDesc = 'Secondary';
                    } else {
                        targetNode = getStandbyHealthyPrimary(activePos, shardIdx);
                        targetDesc = 'Primary (no secondary available)';
                    }
                    break;
                    
                case 'nearest':
                    const allHealthy = getStandbyHealthyNodes(activePos, shardIdx);
                    if (allHealthy.length > 0) {
                        targetNode = allHealthy[Math.floor(Math.random() * allHealthy.length)];
                        targetDesc = targetNode.role === 'primary' ? 'Primary (nearest)' : 'Secondary (nearest)';
                    }
                    break;
            }
            
            if (!targetNode) {
                logStandbyEvent(`âŒ Read failed: No available node`, 'error');
                return;
            }
            
            targetNode.el.classList.add('read-target');
            logStandbyEvent(`ðŸ“– Read from ${targetDesc} (shard ${shardIdx})`, 'info');
            
            await new Promise(r => setTimeout(r, 400));
            targetNode.el.classList.remove('read-target');
            
            logStandbyEvent(`âœ… Read complete`, 'success');
        }

        function resetNodeStates() {
            // Reset based on current active position
            const activePos = standbyState.activePosition;
            const standbyPos = activePos === 'left' ? 'right' : 'left';
            
            // Active region: primary on first node of each shard
            nodeStates[activePos] = {
                0: [{ status: 'healthy', role: 'primary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }],
                1: [{ status: 'healthy', role: 'primary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }]
            };
            // Standby region: all secondaries
            nodeStates[standbyPos] = {
                0: [{ status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }],
                1: [{ status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }, { status: 'healthy', role: 'secondary' }]
            };
            
            // Reset visual states
            ['left', 'right'].forEach(region => {
                [0, 1].forEach(shardIdx => {
                    [0, 1, 2].forEach(nodeIdx => {
                        const nodeEl = document.getElementById(`${region}-s${shardIdx}-n${nodeIdx}`);
                        if (nodeEl) {
                            nodeEl.classList.remove('down', 'recovering', 'write-target', 'read-target', 'replicating');
                            const isActive = region === activePos;
                            if (isActive && nodeIdx === 0) {
                                nodeEl.classList.remove('secondary');
                                nodeEl.classList.add('primary');
                                nodeEl.querySelector('.node-letter').textContent = 'P';
                            } else {
                                nodeEl.classList.remove('primary');
                                nodeEl.classList.add('secondary');
                                nodeEl.querySelector('.node-letter').textContent = 'S';
                            }
                        }
                    });
                });
            });
        }

        function syncNodeStatesToRole(region, role) {
            // Preserve health status but update roles
            [0, 1].forEach(shardIdx => {
                nodeStates[region][shardIdx].forEach((node, nodeIdx) => {
                    if (node.status === 'healthy') {
                        if (role === 'active' && nodeIdx === 0) {
                            node.role = 'primary';
                        } else {
                            node.role = 'secondary';
                        }
                    }
                });
            });
        }

        function logStandbyEvent(message, type = 'info') {
            const eventLog = document.getElementById('event-log');
            if (!eventLog) return;
            
            const entry = document.createElement('div');
            entry.className = `event-entry ${type}`;
            entry.innerHTML = `<span class="event-time">${new Date().toLocaleTimeString()}</span> ${message}`;
            eventLog.insertBefore(entry, eventLog.firstChild);
            
            while (eventLog.children.length > 15) eventLog.removeChild(eventLog.lastChild);
        }

        function resetStandbyUI() {
            const leftRegionEl = document.querySelector('.active-region');
            const rightRegionEl = document.querySelector('.standby-region-box');
            const crossFlowEl = document.getElementById('cross-region-flow');
            
            if (!leftRegionEl || !rightRegionEl) return;
            
            // Reset region visual states
            leftRegionEl.classList.remove('region-down', 'failover-in-progress');
            rightRegionEl.classList.remove('region-down', 'failover-in-progress');
            crossFlowEl.classList.remove('paused', 'reversed');
            
            // Reset arrow direction to default (left to right)
            document.getElementById('arrow-direction').textContent = 'â†’â†’â†’';
            document.getElementById('flow-desc').innerHTML = 'push oplog to<br/>standby blob store';
            
            // Reset region headers - left is active, right is standby
            const leftHeader = leftRegionEl.querySelector('.region-header');
            const rightHeader = rightRegionEl.querySelector('.region-header');
            
            leftHeader.classList.add('active');
            leftHeader.classList.remove('standby');
            leftHeader.querySelector('.region-name').textContent = 'ACTIVE REGION';
            leftHeader.querySelector('.region-status').textContent = 'â— Primary';
            leftHeader.querySelector('.region-icon').textContent = 'ðŸ”µ';
            
            rightHeader.classList.add('standby');
            rightHeader.classList.remove('active');
            rightHeader.querySelector('.region-name').textContent = 'STANDBY REGION';
            rightHeader.querySelector('.region-status').textContent = 'â—‹ Standby';
            rightHeader.querySelector('.region-icon').textContent = 'ðŸŸ¢';
            
            // Reset cluster labels
            leftRegionEl.querySelector('.cluster-label').textContent = 'ACTIVE CLUSTER';
            rightRegionEl.querySelector('.cluster-label').textContent = 'STANDBY CLUSTER';
            
            // Remove any sublabels from left (active) cluster, ensure right (standby) has one
            const leftSublabel = leftRegionEl.querySelector('.cluster-sublabel');
            if (leftSublabel) leftSublabel.remove();
            
            let rightSublabel = rightRegionEl.querySelector('.cluster-sublabel');
            if (!rightSublabel) {
                rightSublabel = document.createElement('div');
                rightSublabel.className = 'cluster-sublabel';
                rightSublabel.textContent = '(All Secondaries)';
                rightRegionEl.querySelector('.cluster-label').after(rightSublabel);
            } else {
                rightSublabel.textContent = '(All Secondaries)';
            }
            
            // Reset nodes - left (active) has P+S+S, right (standby) has all S
            updateNodesAfterFailover(leftRegionEl, 'active');
            updateNodesAfterFailover(rightRegionEl, 'standby');
            
            // Show/hide components based on active/standby role
            // Blob storage always visible in both regions
            setElementDisplay('left-cloud-storage', '');
            setElementDisplay('right-cloud-storage', '');
            
            // Left is ACTIVE: show shippers, hide injector pipeline
            setElementDisplay('left-blob-output', '');          // Shows "push oplog â†’"
            setElementDisplay('left-blob-input', 'none');
            setElementDisplay('left-storage-pull', 'none');
            setElementDisplay('left-coordinator', 'none');
            setElementDisplay('left-injectors', 'none');
            setElementDisplay('left-injector-push', 'none');
            setElementDisplay('left-cluster-pull', '');
            setElementDisplay('left-shippers', '');
            
            // Right is STANDBY: show injector pipeline, hide shippers
            setElementDisplay('right-blob-output', 'none');
            setElementDisplay('right-blob-input', '');          // Shows "â† receives oplog"
            setElementDisplay('right-storage-pull', '');
            setElementDisplay('right-coordinator', '');
            setElementDisplay('right-injectors', '');
            setElementDisplay('right-injector-push', '');
            setElementDisplay('right-cluster-pull', 'none');
            setElementDisplay('right-shippers', 'none');
            
            // Reset status panel
            document.getElementById('left-region-status').textContent = 'â— Active';
            document.getElementById('left-region-status').className = 'status-value healthy';
            document.getElementById('left-region-status').style.color = '';
            document.getElementById('right-region-status').textContent = 'â— Standby';
            document.getElementById('right-region-status').className = 'status-value healthy';
            document.getElementById('right-region-status').style.color = '';
            document.getElementById('replication-status').textContent = 'âŸ³ Syncing';
            document.getElementById('replication-status').className = 'status-value syncing';
            document.getElementById('replication-status').style.color = '';
            
            // Reset kill/restore buttons
            document.getElementById('kill-left-btn').style.display = '';
            document.getElementById('restore-left-btn').style.display = 'none';
            document.getElementById('kill-right-btn').style.display = '';
            document.getElementById('restore-right-btn').style.display = 'none';
            document.getElementById('splitover-btn').style.display = '';
            document.getElementById('setup-standby-btn').style.display = 'none';
            
            // Reset hints
            document.getElementById('splitover-hint').textContent = 'Split Clusters: Both become independent';
            document.getElementById('splitover-hint').style.color = '';
            
            // Reset failover modal steps
            const steps = document.querySelectorAll('.failover-step');
            steps.forEach(step => {
                step.classList.remove('active', 'complete');
                step.querySelector('.failover-step-icon').textContent = 'â³';
            });
            document.getElementById('failover-progress-bar').style.width = '0%';
            
            // Update button states based on current region status
            // Failover: disabled (both regions healthy)
            // Switchover: enabled (both regions healthy)
            // Splitover: enabled (not both down)
            updateFailoverButtonState();
            
            logStandbyEvent('ðŸ”„ Active-Standby cluster initialized', 'success');
            logStandbyEvent('ðŸ’¡ Left region is Active, Right region is Standby', 'info');
            logStandbyEvent('ðŸ’¡ Try killing a region or initiating a failover', 'info');
        }

        // ============ LATENCY SIMULATION ============
        function getLatency(fromRegion, toRegion) {
            const from = fromRegion || 'region-1';
            const to = toRegion || 'region-1';
            return LATENCY_MAP[from]?.[to] || LATENCY_MAP['region-1']['region-1'] || 1;
        }

        async function simulateLatency(fromRegion, toRegion) {
            const latency = getLatency(fromRegion, toRegion);
            await sleep(latency);
            return latency;
        }

        // ============ CONNECTION STRING ============
        function updateConnectionString() {
            const connEl = document.getElementById('conn-string');
            if (!connEl) return;
            
            let connString = '';
            const wc = state.writeConcern;
            const rp = state.readPreference;
            
            // Use mongodb+srv:// format (DNS SRV connection string)
            const clusterName = state.isSharded ? 'sharded-cluster' : 'rs0';
            const config = CLUSTER_CONFIGS[state.currentConfig];
            const regionCount = config?.regions?.length || 1;
            const regionSuffix = regionCount === 1 ? 'single' : regionCount === 2 ? 'multi' : 'global';
            
            connString = `mongodb+srv://<username>:<password>@${clusterName}-${regionSuffix}.mongodb.net/?retryWrites=true&w=${wc}&readPreference=${rp}`;
            
            connEl.textContent = connString;
        }

        function copyConnectionString() {
            const connEl = document.getElementById('conn-string');
            const text = connEl.textContent;
            navigator.clipboard.writeText(text).then(() => {
                connEl.classList.add('copied');
                setTimeout(() => connEl.classList.remove('copied'), 2000);
                log('Connection string copied to clipboard!', 'success');
            }).catch(() => {
                log('Failed to copy to clipboard', 'error');
            });
        }

        // ============ KEYBOARD SHORTCUTS ============
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                
                const key = e.key.toLowerCase();
                switch (key) {
                    case 'i': simulateInsert(); break;
                    case 'u': simulateUpdate(); break;
                    case 'r': simulateRead(); break;
                    case 'k': killRandomPrimary(); break;
                    case 'x': resetCluster(); break;
                    case 'd': toggleAutoDemo(); break;
                    case 't': toggleTopology(); break;
                    case 's': cycleAnimSpeed(); break;
                    case 'p': togglePause(); break;
                    case '1': selectConfig(0); break;
                    case '2': selectConfig(1); break;
                    case '3': selectConfig(2); break;
                }
            });
        }

        function toggleTopology() {
            const btns = document.querySelectorAll('.topology-btn');
            const currentIsRS = document.querySelector('.topology-btn.selected').dataset.type === 'replica-set';
            const newType = currentIsRS ? 'sharded' : 'replica-set';
            btns.forEach(b => b.classList.toggle('selected', b.dataset.type === newType));
            
            // Update visible options
            document.querySelectorAll('.cluster-option').forEach(opt => {
                const isMatch = opt.dataset.type === newType;
                opt.style.display = isMatch ? '' : 'none';
            });
            
            // Select first option of new type
            const firstOption = document.querySelector(`.cluster-option[data-type="${newType}"]`);
            if (firstOption) {
                document.querySelectorAll('.cluster-option').forEach(o => o.classList.remove('selected'));
                firstOption.classList.add('selected');
                loadConfig(firstOption.dataset.config);
            }
        }

        function selectConfig(index) {
            const currentType = document.querySelector('.topology-btn.selected').dataset.type;
            const options = Array.from(document.querySelectorAll(`.cluster-option[data-type="${currentType}"]`));
            if (options[index]) {
                document.querySelectorAll('.cluster-option').forEach(o => o.classList.remove('selected'));
                options[index].classList.add('selected');
                loadConfig(options[index].dataset.config);
            }
        }

        // ============ AUTO DEMO ============
        const DEMO_STEPS = [
            { narration: 'ðŸ‘‹ Welcome to the MongoDB High Availability Demo!', action: null, duration: 2500 },
            { narration: 'ðŸ“ First, let\'s perform a write operation...', action: () => simulateInsert(), duration: 2000 },
            { narration: 'ðŸ“– Now let\'s read from the cluster...', action: () => simulateRead(), duration: 2000 },
            { narration: 'ðŸ’¥ Simulating a PRIMARY node failure...', action: () => killRandomPrimary(), duration: 3500 },
            { narration: 'ðŸ—³ï¸ MongoDB is electing a new primary...', action: null, duration: 2500 },
            { narration: 'âœ… Cluster recovered! Let\'s try another write...', action: () => simulateInsert(), duration: 2500 },
            { narration: 'ðŸ“Š Notice how the statistics track all operations!', action: null, duration: 2500 },
            { narration: 'ðŸ”„ Resetting the cluster for more experiments...', action: () => resetCluster(), duration: 2000 },
            { narration: 'ðŸŽ‰ Demo complete! Try the keyboard shortcuts (I, U, R, K) to explore more.', action: null, duration: 3000 }
        ];

        function toggleAutoDemo() {
            if (state.demoRunning) {
                stopAutoDemo();
            } else {
                startAutoDemo();
            }
        }

        async function startAutoDemo() {
            state.demoRunning = true;
            state.demoStep = 0;
            
            const btn = document.getElementById('auto-demo-btn');
            const btnText = document.getElementById('demo-btn-text');
            btn.classList.add('running');
            btnText.textContent = 'Stop Demo';
            btn.querySelector('.demo-icon').textContent = 'â¹ï¸';
            
            const narration = document.getElementById('demo-narration');
            narration.classList.add('visible');
            
            resetStats();
            
            for (let i = 0; i < DEMO_STEPS.length && state.demoRunning; i++) {
                state.demoStep = i;
                const step = DEMO_STEPS[i];
                
                document.getElementById('narration-text').textContent = step.narration;
                document.getElementById('narration-step').textContent = `Step ${i + 1} of ${DEMO_STEPS.length}`;
                
                if (step.action) {
                    await sleep(500);
                    await step.action();
                }
                
                await sleep(step.duration);
            }
            
            stopAutoDemo();
        }

        function stopAutoDemo() {
            state.demoRunning = false;
            state.demoStep = 0;
            
            const btn = document.getElementById('auto-demo-btn');
            const btnText = document.getElementById('demo-btn-text');
            btn.classList.remove('running');
            btnText.textContent = 'Auto Demo';
            btn.querySelector('.demo-icon').textContent = 'â–¶ï¸';
            
            document.getElementById('demo-narration').classList.remove('visible');
        }

        // ============ INIT ============
        function init() {
            setupTopologyToggle();
            setupClusterSelector();
            setupWriteConcernHandlers();
            setupReadPreferenceHandler();
            setupShardedDropdownHandlers();
            setupKeyboardShortcuts();
            loadConfig('rs-single-region');
            renderStats();
            updateConnectionString();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- Animation Controls -->
    <div class="anim-controls">
        <button class="anim-btn" id="speed-btn" onclick="cycleAnimSpeed()" title="Press S to cycle">ðŸ¢ Slow</button>
        <button class="anim-btn" id="pause-btn" onclick="togglePause()" title="Press P to toggle">â¸ï¸ Pause</button>
    </div>
    
    <!-- Keyboard Shortcuts Toggle -->
    <div class="shortcuts-toggle" id="shortcuts-toggle" onclick="toggleShortcutsPanel()">
        âŒ¨ï¸ Shortcuts
    </div>
    
    <!-- Keyboard Shortcuts Help Panel -->
    <div class="shortcuts-help" id="shortcuts-help">
        <span class="shortcuts-close" onclick="toggleShortcutsPanel()">Ã—</span>
        <div class="shortcuts-title">âŒ¨ï¸ Keyboard Shortcuts</div>
        <div class="shortcut-row"><span>Insert</span><span class="shortcut-key">I</span></div>
        <div class="shortcut-row"><span>Update</span><span class="shortcut-key">U</span></div>
        <div class="shortcut-row"><span>Read</span><span class="shortcut-key">R</span></div>
        <div class="shortcut-row"><span>Kill Primary</span><span class="shortcut-key">K</span></div>
        <div class="shortcut-row"><span>Reset</span><span class="shortcut-key">X</span></div>
        <div class="shortcut-row"><span>Auto Demo</span><span class="shortcut-key">D</span></div>
        <div class="shortcut-row"><span>Toggle RS/Shard</span><span class="shortcut-key">T</span></div>
        <div class="shortcut-row"><span>Cycle Speed</span><span class="shortcut-key">S</span></div>
        <div class="shortcut-row"><span>Pause/Resume</span><span class="shortcut-key">P</span></div>
    </div>

    <!-- Demo Narration Overlay -->
    <div class="demo-narration" id="demo-narration">
        <div class="demo-narration-text" id="narration-text">Welcome to the MongoDB HA Demo!</div>
        <div class="demo-narration-step" id="narration-step">Step 1 of 8</div>
    </div>

    <!-- Feedback Footer -->
    <div class="feedback-footer">
        <div class="feedback-content">
            <span class="feedback-text">Found a bug or have feedback?</span>
            <a href="https://forms.gle/edNQUdwyfqSQCjFw5" target="_blank" class="feedback-btn">
                <span class="feedback-icon">ðŸ“</span>
                <span>Submit Feedback</span>
            </a>
        </div>
    </div>

    <style>
        .feedback-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(0, 30, 43, 0.95), rgba(0, 45, 60, 0.95));
            border-top: 1px solid rgba(0, 237, 100, 0.3);
            padding: 10px 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .feedback-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .feedback-text {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
        }

        .feedback-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, var(--mongo-green), #00c853);
            color: var(--mongo-forest);
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 237, 100, 0.3);
        }

        .feedback-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 237, 100, 0.4);
            background: linear-gradient(135deg, #00ff6a, #00ed64);
        }

        .feedback-icon {
            font-size: 1rem;
        }

        /* Adjust event log panel to account for feedback footer */
        .event-log-panel {
            margin-bottom: 50px;
        }
    </style>
</body>
</html>
