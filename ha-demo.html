<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MongoDB | High Availability Demo</title>
    <link rel="icon" href="https://www.mongodb.com/assets/images/global/favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --mongo-green: #00ED64;
            --mongo-dark-green: #00a854;
            --mongo-forest: #001E2B;
            --mongo-slate: #1C2D38;
            --node-primary: #00ED64;
            --node-secondary: #00b4d8;
            --node-down: #ef476f;
            --node-recovering: #ffd166;
            --op-insert: #00ED64;
            --op-update: #ffd166;
            --op-delete: #ef476f;
            --region-1: #00b4d8;
            --region-2: #00c853;
            --region-3: #ff9100;
            /* Legacy region vars for compatibility */
            --region-a: var(--region-1);
            --region-b: var(--region-2);
            --region-c: var(--region-3);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: linear-gradient(135deg, var(--mongo-forest) 0%, #002a3a 50%, var(--mongo-forest) 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(0, 30, 43, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 237, 100, 0.2);
            padding: 14px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 38px;
            height: 38px;
            background: var(--mongo-green);
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--mongo-forest);
            font-size: 1.2rem;
        }

        .logo-text {
            font-size: 1.3rem;
            font-weight: 600;
        }

        .logo-text span { color: var(--mongo-green); }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .cluster-status {
            display: flex;
            align-items: center;
            gap: 7px;
            font-size: 0.9rem;
            padding: 6px 14px;
            background: rgba(0, 237, 100, 0.1);
            border-radius: 18px;
            border: 1px solid rgba(0, 237, 100, 0.3);
        }

        .cluster-status.healthy { color: var(--mongo-green); }
        .cluster-status.degraded { background: rgba(255, 209, 102, 0.1); border-color: rgba(255, 209, 102, 0.3); color: var(--node-recovering); }
        .cluster-status.critical { background: rgba(239, 71, 111, 0.1); border-color: rgba(239, 71, 111, 0.3); color: var(--node-down); }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

        /* Main Layout */
        .main-layout {
            padding: 20px 28px;
            max-width: 1900px;
            margin: 0 auto;
        }

        /* Topology Toggle */
        .topology-toggle {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }
        .topology-btn {
            padding: 10px 24px;
            background: rgba(0, 30, 43, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .topology-btn:hover {
            border-color: rgba(255, 255, 255, 0.3);
            color: white;
        }
        .topology-btn.selected {
            background: rgba(0, 237, 100, 0.15);
            border-color: var(--mongo-green);
            color: var(--mongo-green);
        }

        /* Cluster Selector */
        .cluster-selector {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .cluster-option {
            flex: 1;
            min-width: 300px;
            padding: 16px 20px;
            background: rgba(0, 30, 43, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cluster-option:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .cluster-option.selected {
            border-color: var(--mongo-green);
            background: rgba(0, 237, 100, 0.05);
        }

        .cluster-option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .cluster-option-title {
            font-weight: 600;
            font-size: 1.05rem;
        }

        .cluster-option-badge {
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .cluster-option-badge.single { background: rgba(255, 255, 255, 0.1); }
        .cluster-option-badge.multi { background: rgba(0, 237, 100, 0.2); color: var(--mongo-green); }

        .cluster-option-desc {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 12px;
        }

        .cluster-option-regions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .region-chip {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .region-chip.region-a, .region-chip.region-1 { background: rgba(0, 180, 216, 0.2); color: var(--region-1); }
        .region-chip.region-b, .region-chip.region-2 { background: rgba(0, 200, 83, 0.2); color: var(--region-2); }
        .region-chip.region-c, .region-chip.region-3 { background: rgba(255, 145, 0, 0.2); color: var(--region-3); }

        /* Top Controls */
        .top-section {
            display: flex;
            gap: 14px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-card {
            background: rgba(0, 30, 43, 0.7);
            border-radius: 10px;
            border: 1px solid rgba(0, 237, 100, 0.15);
            padding: 14px 16px;
        }

        .control-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

        .action-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 7px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .action-btn.primary { background: var(--mongo-green); color: var(--mongo-forest); }
        .action-btn.primary:hover { background: var(--mongo-dark-green); }
        .action-btn.secondary { background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.2); }
        .action-btn.secondary:hover { background: rgba(255, 255, 255, 0.15); }
        .action-btn.danger { background: rgba(239, 71, 111, 0.2); color: var(--node-down); border: 1px solid rgba(239, 71, 111, 0.3); }
        .action-btn.danger:hover { background: rgba(239, 71, 111, 0.3); }
        .action-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Region Failure Buttons */
        .region-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 7px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .region-btn.region-a, .region-btn.region-1 { background: rgba(0, 180, 216, 0.2); color: var(--region-1); border: 1px solid var(--region-1); }
        .region-btn.region-b, .region-btn.region-2 { background: rgba(0, 200, 83, 0.2); color: var(--region-2); border: 1px solid var(--region-2); }
        .region-btn.region-c, .region-btn.region-3 { background: rgba(255, 145, 0, 0.2); color: var(--region-3); border: 1px solid var(--region-3); }
        .region-btn:hover { filter: brightness(1.2); }
        .region-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .wc-pills { display: flex; gap: 6px; }

        .wc-pill {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .wc-pill:hover { background: rgba(255, 255, 255, 0.1); }
        .wc-pill.selected { background: rgba(0, 237, 100, 0.15); border-color: var(--mongo-green); color: var(--mongo-green); }

        .read-pref-select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 7px;
            color: white;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .read-pref-select option { background: var(--mongo-slate); }

        /* Regions Container */
        .regions-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .region-panel {
            flex: 1;
            min-width: 360px;
            background: rgba(0, 30, 43, 0.5);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .region-panel.region-a, .region-panel.region-1 { border-color: rgba(0, 180, 216, 0.3); }
        .region-panel.region-b, .region-panel.region-2 { border-color: rgba(0, 200, 83, 0.3); }
        .region-panel.region-c, .region-panel.region-3 { border-color: rgba(255, 145, 0, 0.3); }

        .region-panel.down { opacity: 0.5; border-style: dashed; }

        .region-header {
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .region-panel.region-a .region-header, .region-panel.region-1 .region-header { background: rgba(0, 180, 216, 0.1); }
        .region-panel.region-b .region-header, .region-panel.region-2 .region-header { background: rgba(0, 200, 83, 0.1); }
        .region-panel.region-c .region-header, .region-panel.region-3 .region-header { background: rgba(255, 145, 0, 0.1); }

        .region-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1rem;
        }

        .region-icon {
            width: 30px;
            height: 30px;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .region-panel.region-a .region-icon, .region-panel.region-1 .region-icon { background: rgba(0, 180, 216, 0.2); }
        .region-panel.region-b .region-icon, .region-panel.region-2 .region-icon { background: rgba(0, 200, 83, 0.2); }
        .region-panel.region-c .region-icon, .region-panel.region-3 .region-icon { background: rgba(255, 145, 0, 0.2); }

        .region-status {
            font-size: 0.8rem;
            padding: 4px 10px;
            border-radius: 10px;
            background: rgba(0, 237, 100, 0.2);
            color: var(--mongo-green);
        }

        .region-status.down {
            background: rgba(239, 71, 111, 0.2);
            color: var(--node-down);
        }

        .region-nodes {
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Node Card */
        .node-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.3s;
        }

        .node-card.primary { border-color: var(--node-primary); box-shadow: 0 0 16px rgba(0, 237, 100, 0.15); }
        .node-card.secondary { border-color: var(--node-secondary); }
        .node-card.down { border-color: var(--node-down); opacity: 0.6; }
        .node-card.recovering { border-color: var(--node-recovering); }
        .node-card.syncing { 
            border-color: #00b4d8; 
            animation: syncPulse 1s ease-in-out infinite;
        }
        
        @keyframes syncPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 180, 216, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 180, 216, 0.6); }
        }

        .node-header {
            padding: 12px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
        }

        .node-info { display: flex; align-items: center; gap: 12px; }

        .node-icon {
            width: 38px;
            height: 38px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .node-card.primary .node-icon { background: rgba(0, 237, 100, 0.15); }
        .node-card.secondary .node-icon { background: rgba(0, 180, 216, 0.15); }
        .node-card.down .node-icon { background: rgba(239, 71, 111, 0.15); }

        .node-details h4 { font-size: 0.95rem; font-weight: 600; margin-bottom: 2px; }
        .node-details .port { font-family: 'Source Code Pro', monospace; font-size: 0.8rem; color: rgba(255, 255, 255, 0.5); }

        .node-role-badge {
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .node-card.primary .node-role-badge { background: var(--node-primary); color: var(--mongo-forest); }
        .node-card.secondary .node-role-badge { background: var(--node-secondary); color: var(--mongo-forest); }
        .node-card.down .node-role-badge { background: var(--node-down); color: white; }
        .node-card.recovering .node-role-badge { background: var(--node-recovering); color: var(--mongo-forest); }
        .node-card.syncing .node-role-badge { background: #00b4d8; color: var(--mongo-forest); }

        .node-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .node-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .node-btn.kill { background: rgba(239, 71, 111, 0.2); color: var(--node-down); }
        .node-btn.start { background: rgba(0, 237, 100, 0.2); color: var(--mongo-green); }

        /* Oplog Section */
        .oplog-section { padding: 12px 14px; }

        .oplog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .oplog-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--mongo-green);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .oplog-title code {
            background: rgba(0, 237, 100, 0.1);
            padding: 3px 8px;
            border-radius: 5px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
        }

        .oplog-stats { font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); }

        .replication-lag {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }

        .lag-bar { flex: 1; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden; }
        .lag-fill { height: 100%; background: var(--mongo-green); transition: width 0.3s; }
        .lag-fill.warning { background: var(--node-recovering); }
        .lag-fill.critical { background: var(--node-down); }
        .lag-value { font-family: 'Source Code Pro', monospace; min-width: 45px; text-align: right; }

        .oplog-entries {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            max-height: 160px;
            overflow-y: auto;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
        }

        .oplog-entries::-webkit-scrollbar { width: 5px; }
        .oplog-entries::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }

        .oplog-entry {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .oplog-entry.new { animation: flashNew 1s ease-out; }
        @keyframes flashNew { 0% { background: rgba(0, 237, 100, 0.3); } 100% { background: transparent; } }

        .oplog-entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .oplog-op { display: flex; align-items: center; gap: 6px; }

        .op-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .op-badge.insert { background: var(--op-insert); color: var(--mongo-forest); }
        .op-badge.update { background: var(--op-update); color: var(--mongo-forest); }
        .op-badge.delete { background: var(--op-delete); color: white; }
        .op-badge.noop { background: #6c757d; color: white; }

        .oplog-ns { color: var(--node-secondary); font-size: 0.7rem; }
        .oplog-ts { color: rgba(255, 255, 255, 0.3); font-size: 0.65rem; }

        .oplog-doc {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 8px;
            border-radius: 5px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .oplog-empty {
            padding: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
        }

        /* Event Log */
        .event-log-panel {
            background: rgba(0, 30, 43, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(0, 237, 100, 0.15);
            padding: 14px;
            margin-top: 20px;
        }

        .event-log-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 10px;
        }

        .event-log {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 6px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            flex-shrink: 0;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
        }

        .log-entry.info { border-color: var(--node-secondary); }
        .log-entry.success { border-color: var(--mongo-green); }
        .log-entry.warning { border-color: var(--node-recovering); }
        .log-entry.error { border-color: var(--node-down); }

        .log-time { color: rgba(255, 255, 255, 0.4); font-size: 0.7rem; margin-bottom: 3px; }
        .log-msg { color: rgba(255, 255, 255, 0.9); }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.visible { opacity: 1; visibility: visible; }

        .modal {
            background: var(--mongo-slate);
            border-radius: 20px;
            border: 1px solid rgba(0, 237, 100, 0.3);
            padding: 35px;
            max-width: 550px;
            width: 90%;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.visible .modal { transform: scale(1); }
        .modal-icon { font-size: 2.8rem; margin-bottom: 14px; }
        .modal-title { font-size: 1.3rem; font-weight: 600; margin-bottom: 10px; }
        .modal-text { color: rgba(255, 255, 255, 0.7); margin-bottom: 16px; line-height: 1.5; font-size: 1rem; }

        .election-progress {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 16px 0;
        }

        .election-progress-bar {
            height: 100%;
            background: var(--mongo-green);
            width: 0%;
            transition: width 0.3s;
        }

        #election-status { font-size: 0.95rem; color: rgba(255, 255, 255, 0.6); }

        /* Info Panel */
        .info-panel {
            background: rgba(0, 237, 100, 0.05);
            border: 1px solid rgba(0, 237, 100, 0.2);
            border-radius: 12px;
            padding: 14px 18px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .info-icon { font-size: 1.6rem; }
        .info-content { flex: 1; }
        .info-title { font-weight: 600; font-size: 1rem; margin-bottom: 4px; }
        .info-desc { font-size: 0.9rem; color: rgba(255, 255, 255, 0.7); }

        /* Replication Flow Visualization */
        .replication-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .flow-particle {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 51;
        }

        .flow-particle.write {
            background: #ff6b6b;
            box-shadow: 0 0 16px #ff6b6b, 0 0 32px #ff6b6b;
        }

        .flow-particle.replication {
            background: var(--mongo-green);
            box-shadow: 0 0 16px var(--mongo-green), 0 0 32px var(--mongo-green);
        }

        .flow-particle.ack {
            background: #ffd166;
            box-shadow: 0 0 16px #ffd166;
        }

        .flow-particle.read {
            background: #4ECDC4;
            box-shadow: 0 0 16px #4ECDC4, 0 0 32px #4ECDC4;
        }

        .node-card.reading {
            animation: readingPulse 0.4s ease-in-out 2;
        }

        @keyframes readingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        /* Node highlight states */
        .node-card.receiving {
            animation: receiveFlash 0.5s ease-out;
        }

        .node-card.acknowledged {
            position: relative;
        }

        .node-card.acknowledged::after {
            content: 'âœ“';
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: var(--mongo-green);
            color: var(--mongo-forest);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            animation: ackPop 0.3s ease-out;
            z-index: 10;
        }

        @keyframes receiveFlash {
            0% { box-shadow: 0 0 30px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: none; }
        }

        @keyframes ackPop {
            0% { transform: scale(0); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Write Flow Status Panel */
        .write-flow-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 360px;
            background: rgba(0, 30, 43, 0.95);
            border: 2px solid var(--mongo-green);
            border-radius: 14px;
            padding: 16px;
            z-index: 100;
            display: none;
            animation: slideUp 0.3s ease-out;
        }

        .write-flow-panel.visible {
            display: block;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .write-flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .write-flow-title {
            font-weight: 600;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .write-flow-wc {
            font-size: 0.85rem;
            padding: 4px 10px;
            background: rgba(0, 237, 100, 0.2);
            border-radius: 10px;
            color: var(--mongo-green);
        }

        .write-flow-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .write-flow-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0.4;
            transition: all 0.3s;
        }

        .write-flow-step.active {
            opacity: 1;
            background: rgba(0, 237, 100, 0.1);
            border-left: 3px solid var(--mongo-green);
        }

        .write-flow-step.complete {
            opacity: 1;
        }

        .write-flow-step.complete .step-icon {
            color: var(--mongo-green);
        }

        .step-icon {
            font-size: 1rem;
            width: 26px;
            text-align: center;
        }

        .step-content {
            flex: 1;
        }

        .step-label {
            font-weight: 500;
            font-size: 0.85rem;
        }

        .step-detail {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
        }

        .step-nodes {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .step-node-badge {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
        }

        .step-node-badge.primary {
            background: rgba(0, 237, 100, 0.2);
            color: var(--mongo-green);
        }

        .step-node-badge.acked {
            background: rgba(0, 237, 100, 0.3);
            color: var(--mongo-green);
        }

        .step-node-badge.pending {
            background: rgba(255, 209, 102, 0.2);
            color: var(--node-recovering);
        }

        .step-node-badge.majority-reached {
            background: rgba(0, 237, 100, 0.5);
            color: white;
            font-weight: 600;
            animation: majorityPulse 0.5s ease-out;
        }

        @keyframes majorityPulse {
            0% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .majority-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(0, 237, 100, 0.2);
            border: 1px solid var(--mongo-green);
            border-radius: 5px;
            font-size: 0.75rem;
            color: var(--mongo-green);
            margin-left: 6px;
        }

        .write-flow-result {
            margin-top: 12px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            display: none;
        }

        .write-flow-result.success {
            display: block;
            background: rgba(0, 237, 100, 0.15);
            color: var(--mongo-green);
            border: 1px solid var(--mongo-green);
        }

        .write-flow-result.failed {
            display: block;
            background: rgba(239, 71, 111, 0.15);
            color: var(--node-down);
            border: 1px solid var(--node-down);
        }

        /* Read Flow Status Panel */
        .read-flow-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 400px;
            background: rgba(0, 30, 43, 0.95);
            border: 2px solid #4ECDC4;
            border-radius: 14px;
            padding: 16px;
            z-index: 100;
            display: none;
            animation: slideUp 0.3s ease-out;
        }

        .read-flow-panel.visible {
            display: block;
        }

        .read-flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .read-flow-title {
            font-weight: 600;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .read-flow-pref {
            font-size: 0.85rem;
            padding: 4px 10px;
            background: rgba(78, 205, 196, 0.2);
            border-radius: 10px;
            color: #4ECDC4;
            font-family: 'Source Code Pro', monospace;
        }

        .read-flow-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .read-flow-nodes {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .read-node-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .read-node-row.eligible {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .read-node-row.selected {
            background: rgba(78, 205, 196, 0.25);
            border: 2px solid #4ECDC4;
            animation: readPulse 0.5s ease-out;
        }

        .read-node-row.not-eligible {
            opacity: 0.4;
        }

        @keyframes readPulse {
            0% { transform: scale(1.02); box-shadow: 0 0 20px rgba(78, 205, 196, 0.5); }
            100% { transform: scale(1); box-shadow: none; }
        }

        .read-node-icon {
            font-size: 1.2rem;
        }

        .read-node-info {
            flex: 1;
        }

        .read-node-name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .read-node-meta {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
        }

        .read-node-status {
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 10px;
        }

        .read-node-status.primary {
            background: rgba(255, 209, 102, 0.2);
            color: #FFD166;
        }

        .read-node-status.secondary {
            background: rgba(78, 205, 196, 0.2);
            color: #4ECDC4;
        }

        .read-node-status.down {
            background: rgba(239, 71, 111, 0.2);
            color: #EF476F;
        }

        .read-flow-selection {
            padding: 12px;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            border: 1px dashed rgba(78, 205, 196, 0.3);
        }

        .read-selection-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .read-selection-target {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .read-selection-arrow {
            font-size: 1.6rem;
            color: #4ECDC4;
            animation: arrowBounce 0.8s ease-in-out infinite;
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(6px); }
        }

        .read-selection-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(78, 205, 196, 0.2);
            border-radius: 8px;
            border: 1px solid #4ECDC4;
            font-size: 0.9rem;
        }

        .read-selection-reason {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.6);
            margin-top: 10px;
            font-style: italic;
        }

        .read-node-badge {
            display: inline-block;
            padding: 4px 10px;
            margin: 2px;
            border-radius: 12px;
            font-size: 0.8rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .read-node-badge.eligible {
            background: rgba(78, 205, 196, 0.1);
            border-color: rgba(78, 205, 196, 0.3);
        }
        .read-node-badge.target {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ECDC4;
            color: #4ECDC4;
            font-weight: 600;
        }
        
        .selection-detail {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .selection-detail:last-child { border-bottom: none; }
        .selection-label { color: rgba(255,255,255,0.5); font-size: 0.8rem; }
        .selection-value { font-weight: 600; font-size: 0.85rem; }
        .selection-value.primary { color: var(--node-primary); }
        .selection-value.secondary { color: var(--node-secondary); }

        .read-flow-result {
            margin-top: 12px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            display: none;
        }

        .read-flow-result.success {
            display: block;
            background: rgba(78, 205, 196, 0.15);
            color: #4ECDC4;
            border: 1px solid #4ECDC4;
        }

        .read-flow-result.failed {
            display: block;
            background: rgba(239, 71, 111, 0.15);
            color: var(--node-down);
            border: 1px solid var(--node-down);
        }

        /* Mongos Layer */
        .mongos-layer {
            background: rgba(0, 237, 100, 0.05);
            border: 1px solid rgba(0, 237, 100, 0.2);
            border-radius: 12px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }

        .layer-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mongos-grid {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mongos-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(0, 237, 100, 0.1);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .mongos-node:hover { background: rgba(0, 237, 100, 0.2); }
        .mongos-node.down { opacity: 0.4; border-style: dashed; }
        .mongos-icon { font-size: 1.1rem; }
        .mongos-info { font-size: 0.85rem; }
        .mongos-region { font-size: 0.7rem; color: rgba(255,255,255,0.5); }

        /* Config Servers Layer */
        .config-layer {
            background: rgba(255, 193, 7, 0.05);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 12px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }

        .config-layer .layer-title { color: #ffc107; }

        .config-grid {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .config-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .config-node.primary {
            border-color: rgba(255, 193, 7, 0.6);
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.2);
        }

        .config-node.down { opacity: 0.4; border-style: dashed; }
        .config-icon { font-size: 1.1rem; }
        .config-info { font-size: 0.85rem; }
        .config-region { font-size: 0.7rem; color: rgba(255,255,255,0.5); }
        .config-role {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,193,7,0.2);
            color: #ffc107;
        }

        /* Shards Container */
        .shards-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .shard-panel {
            flex: 1;
            min-width: 380px;
            background: rgba(0, 30, 43, 0.6);
            border-radius: 14px;
            border: 2px solid rgba(0, 237, 100, 0.3);
            overflow: hidden;
        }

        .shard-header {
            padding: 12px 16px;
            background: rgba(0, 237, 100, 0.1);
            border-bottom: 1px solid rgba(0, 237, 100, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shard-icon {
            width: 30px;
            height: 30px;
            background: rgba(0, 237, 100, 0.15);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .shard-title { font-weight: 600; font-size: 1rem; }

        .shard-status {
            margin-left: auto;
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 10px;
        }

        .shard-status.healthy { background: rgba(0, 237, 100, 0.2); color: var(--mongo-green); }
        .shard-status.degraded { background: rgba(255, 209, 102, 0.2); color: var(--node-recovering); }
        .shard-status.critical { background: rgba(239, 71, 111, 0.2); color: var(--node-down); }

        .shard-body { padding: 12px; }

        /* Replica Set Container */
        .rs-container {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
        }
        .rs-region-group {
            background: rgba(0, 30, 43, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px;
            min-width: 280px;
        }
        .rs-region-group.region-a, .rs-region-group.region-1 { border-left: 4px solid var(--region-1); }
        .rs-region-group.region-b, .rs-region-group.region-2 { border-left: 4px solid var(--region-2); }
        .rs-region-group.region-c, .rs-region-group.region-3 { border-left: 4px solid var(--region-3); }
        .rs-region-group.down { opacity: 0.5; }
        .rs-region-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .rs-region-icon { font-size: 1.2rem; }
        .rs-region-name { font-weight: 600; font-size: 1rem; }
        .rs-region-latency { 
            font-size: 0.75rem; 
            color: rgba(255,255,255,0.5);
            margin-left: auto;
            background: rgba(255,255,255,0.05);
            padding: 2px 8px;
            border-radius: 10px;
        }
        .rs-nodes { display: flex; flex-direction: column; gap: 10px; }

        /* Region Row */
        .region-row {
            display: flex;
            align-items: stretch;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border-left: 3px solid;
        }

        .region-row.region-a, .region-row.region-1 { border-color: var(--region-1); }
        .region-row.region-b, .region-row.region-2 { border-color: var(--region-2); }
        .region-row.region-c, .region-row.region-3 { border-color: var(--region-3); }
        .region-row.down { opacity: 0.5; }

        .region-label {
            min-width: 85px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px;
        }

        .region-name {
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .region-latency {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
        }

        .region-nodes {
            display: flex;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        /* Shard Node Card */
        .node-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
            min-width: 110px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .node-card:hover { transform: translateY(-2px); }
        .node-card.primary { border-color: var(--node-primary); box-shadow: 0 0 12px rgba(0, 237, 100, 0.2); }
        .node-card.secondary { border-color: var(--node-secondary); }
        .node-card.priority-zero { border-color: #9d4edd; border-style: dashed; }
        .node-card.read-replica { border-color: #ff6b6b; border-style: dashed; background: rgba(255, 107, 107, 0.05); }
        .node-card.down { border-color: var(--node-down); opacity: 0.5; }
        .node-card.recovering { border-color: var(--node-recovering); }
        .node-card.syncing { 
            border-color: #00b4d8; 
            animation: syncPulse 1s ease-in-out infinite;
        }

        @keyframes syncPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 180, 216, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 180, 216, 0.6); }
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .node-icon { font-size: 0.9rem; }
        .node-name { font-size: 0.75rem; font-weight: 600; flex: 1; }

        .node-role-badge {
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 6px;
        }

        .node-card.primary .node-role-badge { background: var(--node-primary); color: var(--mongo-forest); }
        .node-card.secondary .node-role-badge { background: var(--node-secondary); color: var(--mongo-forest); }
        .node-card.priority-zero .node-role-badge { background: #9d4edd; color: white; }
        .node-card.read-replica .node-role-badge { background: #ff6b6b; color: white; }
        .node-card.down .node-role-badge { background: var(--node-down); color: white; }
        .node-card.recovering .node-role-badge { background: var(--node-recovering); color: var(--mongo-forest); }
        .node-card.syncing .node-role-badge { background: #00b4d8; color: white; }

        .node-oplog {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            font-family: 'Source Code Pro', monospace;
        }

        .node-card.receiving {
            animation: receiveFlash 0.5s ease-out;
        }

        @keyframes receiveFlash {
            0% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: none; }
        }

        .node-card.acknowledged::after {
            content: 'âœ“';
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: var(--mongo-green);
            color: var(--mongo-forest);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            animation: ackPop 0.3s ease-out;
        }

        @keyframes ackPop {
            0% { transform: scale(0); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Statistics Dashboard */
        .stats-dashboard {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .stat-card {
            background: rgba(0, 30, 43, 0.7);
            border: 1px solid rgba(0, 237, 100, 0.15);
            border-radius: 10px;
            padding: 12px 16px;
            min-width: 120px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--mongo-green);
            font-family: 'Source Code Pro', monospace;
        }
        .stat-value.warning { color: var(--op-update); }
        .stat-value.error { color: var(--node-down); }
        .stat-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        /* Connection String Panel */
        .conn-string-panel {
            background: rgba(0, 30, 43, 0.8);
            border: 1px solid rgba(0, 237, 100, 0.2);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 15px;
        }
        .conn-string-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .conn-string-code {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 12px;
            border-radius: 6px;
            overflow-x: auto;
            white-space: nowrap;
            color: #4ECDC4;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .conn-string-code:hover {
            background: rgba(0, 0, 0, 0.5);
        }
        .conn-string-code::after {
            content: 'ðŸ“‹ Click to copy';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
            font-family: 'Space Grotesk', sans-serif;
        }
        .conn-string-code.copied::after {
            content: 'âœ“ Copied!';
            color: var(--mongo-green);
        }

        /* Keyboard Shortcuts Help */
        .shortcuts-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 30, 43, 0.95);
            border: 1px solid rgba(0, 237, 100, 0.3);
            border-radius: 12px;
            padding: 14px 18px;
            font-size: 0.75rem;
            z-index: 50;
            max-width: 200px;
            transition: all 0.3s;
            opacity: 0.7;
        }
        .shortcuts-help:hover { opacity: 1; }
        .shortcuts-title {
            font-weight: 600;
            color: var(--mongo-green);
            margin-bottom: 8px;
            font-size: 0.8rem;
        }
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            color: rgba(255,255,255,0.7);
        }
        .shortcut-key {
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
        }

        /* Auto Demo Button */
        .auto-demo-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #9d4edd 0%, #7b2cbf 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        .auto-demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.4);
        }
        .auto-demo-btn.running {
            background: linear-gradient(135deg, #ef476f 0%, #d62839 100%);
        }
        .auto-demo-btn .demo-icon {
            font-size: 1.1rem;
        }

        /* Demo Narration */
        .demo-narration {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 30, 43, 0.95);
            border: 2px solid var(--mongo-green);
            border-radius: 12px;
            padding: 16px 24px;
            max-width: 500px;
            text-align: center;
            z-index: 200;
            display: none;
            animation: narrateIn 0.3s ease-out;
        }
        .demo-narration.visible { display: block; }
        .demo-narration-text {
            font-size: 1rem;
            line-height: 1.5;
        }
        .demo-narration-step {
            font-size: 0.75rem;
            color: var(--mongo-green);
            margin-top: 8px;
        }
        @keyframes narrateIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .shards-container { flex-direction: column; }
            .shard-panel { min-width: 100%; }
            .write-flow-panel { width: 320px; right: 10px; bottom: 10px; }
            .read-flow-panel { width: 340px; left: 10px; bottom: 10px; }
            .shortcuts-help { display: none; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon">M</div>
            <div class="logo-text">MongoDB <span>HA Demo</span></div>
        </div>
        <div class="header-controls">
            <code id="header-config" style="background: rgba(0,237,100,0.1); padding: 3px 10px; border-radius: 5px; font-family: 'Source Code Pro', monospace; font-size: 0.75rem;">2 Shards Ã— 3 Nodes</code>
            <div class="cluster-status healthy" id="cluster-status">
                <span class="status-dot"></span>
                <span id="status-text">Healthy</span>
            </div>
        </div>
    </header>

    <main class="main-layout">
        <!-- Topology Type Toggle -->
        <div class="topology-toggle" id="topology-toggle">
            <button class="topology-btn selected" data-type="replica-set">ðŸ“š Replica Set</button>
            <button class="topology-btn" data-type="sharded">ðŸ“¦ Sharded Cluster</button>
        </div>

        <!-- Cluster Configuration Selector -->
        <div class="cluster-selector" id="cluster-selector">
            <!-- Replica Set Options -->
            <div class="cluster-option selected" data-config="rs-single-region" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Single Region RS</span>
                    <span class="cluster-option-badge single">3 Nodes</span>
                </div>
                <div class="cluster-option-desc">Simple 3-node replica set in Region 1. ~1ms latency. Region failure = cluster down.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 3 nodes</span>
                </div>
            </div>
            <div class="cluster-option" data-config="rs-two-region" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Two Region RS</span>
                    <span class="cluster-option-badge multi">3 Nodes</span>
                </div>
                <div class="cluster-option-desc">3-node replica set (2+1) across Region 1/2. ~10ms cross-region latency.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 nodes</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 1 node</span>
                </div>
            </div>
            <div class="cluster-option" data-config="rs-three-region" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Three Region RS</span>
                    <span class="cluster-option-badge multi">5 Nodes</span>
                </div>
                <div class="cluster-option-desc">5-node replica set (2-2-1). Region 3 = P:0 (DR). Survives any single region failure!</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 nodes</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 2 nodes</span>
                    <span class="region-chip region-3">ðŸŸ  Region 3: 1 P:0</span>
                </div>
            </div>
            <div class="cluster-option" data-config="rs-ha-misconception" data-type="replica-set">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">âš ï¸ HA Misconception</span>
                    <span class="cluster-option-badge" style="background: linear-gradient(135deg, #ff6b6b, #ee5a24);">4 Nodes</span>
                </div>
                <div class="cluster-option-desc">Common pitfall: 2+1+read-only (p:0, v:0). If Region 1 fails, no majority! Needs manual promotion.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 nodes</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 1 node + 1 read-only</span>
                </div>
            </div>
            <!-- Sharded Cluster Options (hidden by default) -->
            <div class="cluster-option" data-config="sharded-single-region" data-type="sharded" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Single Region Sharded</span>
                    <span class="cluster-option-badge single">2Ã—3 Nodes</span>
                </div>
                <div class="cluster-option-desc">2 shards Ã— 3 nodes + config servers + mongos in Region 1. No regional redundancy.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: All infrastructure</span>
                </div>
            </div>
            <div class="cluster-option" data-config="sharded-two-region" data-type="sharded" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Two Region Sharded</span>
                    <span class="cluster-option-badge multi">2Ã—3 Nodes</span>
                </div>
                <div class="cluster-option-desc">2 shards Ã— 3 nodes (2+1) + config servers across Region 1/2. ~10ms latency.</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 per shard</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 1 per shard</span>
                </div>
            </div>
            <div class="cluster-option" data-config="sharded-three-region" data-type="sharded" style="display: none;">
                <div class="cluster-option-header">
                    <span class="cluster-option-title">Three Region Sharded</span>
                    <span class="cluster-option-badge multi">2Ã—5 Nodes</span>
                </div>
                <div class="cluster-option-desc">2 shards Ã— 5 nodes (2-2-1). Region 3 = P:0 (DR only). Survives any region failure!</div>
                <div class="cluster-option-regions">
                    <span class="region-chip region-1">ðŸ”µ Region 1: 2 per shard</span>
                    <span class="region-chip region-2">ðŸŸ¢ Region 2: 2 per shard</span>
                    <span class="region-chip region-3">ðŸŸ  Region 3: 1 P:0</span>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel" id="info-panel">
            <div class="info-icon">ðŸ’¡</div>
            <div class="info-content">
                <div class="info-title">Single Region Configuration</div>
                <div class="info-desc">All 3 nodes in Virginia (~1ms latency). If the region fails, the entire cluster goes down. Majority required: 2 nodes.</div>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 16px; font-size: 0.8rem; color: rgba(255,255,255,0.5);">
            <span style="background: rgba(0,237,100,0.1); padding: 4px 12px; border-radius: 12px; border: 1px dashed rgba(0,237,100,0.3);">
                ðŸ‘† <strong>Tip:</strong> Click on any node to simulate failure/recovery
            </span>
        </div>

        <!-- Top Controls -->
        <div class="top-section">
            <div class="control-card">
                <div class="control-title">âš¡ Operations</div>
                <div class="action-buttons">
                    <button class="action-btn primary" onclick="simulateInsert()">âž• Insert</button>
                    <button class="action-btn primary" onclick="simulateUpdate()">âœï¸ Update</button>
                    <button class="action-btn secondary" onclick="simulateRead()">ðŸ“– Read</button>
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸ‡ºðŸ‡¸ Region Failure</div>
                <div class="action-buttons" id="region-buttons">
                    <!-- Dynamically populated -->
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸ“ Write Concern</div>
                <div class="wc-pills" id="wc-pills">
                    <div class="wc-pill" data-value="1" title="Primary only">w:1</div>
                    <div class="wc-pill selected" data-value="majority" title="n/2+1 nodes">w:majority</div>
                    <div class="wc-pill" data-value="all" title="All nodes">w:all</div>
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸ“š Read Preference</div>
                <select class="read-pref-select" id="read-preference">
                    <option value="primary">primary</option>
                    <option value="primaryPreferred">primaryPreferred</option>
                    <option value="secondary">secondary</option>
                    <option value="secondaryPreferred" selected>secondaryPreferred</option>
                    <option value="nearest">nearest</option>
                </select>
            </div>
            <div class="control-card sharded-only" id="target-shard-card" style="display: none;">
                <div class="control-title">ðŸ“¦ Target Shard</div>
                <select class="read-pref-select" id="target-shard">
                    <option value="auto" selected>Auto (random)</option>
                    <!-- Populated dynamically -->
                </select>
            </div>
            <div class="control-card sharded-only" id="request-region-card" style="display: none;">
                <div class="control-title">ðŸ“ Request Region</div>
                <select class="read-pref-select" id="request-region">
                    <option value="auto" selected>Auto (any available)</option>
                    <!-- Populated dynamically -->
                </select>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸŽ® Cluster</div>
                <div class="action-buttons">
                    <button class="action-btn danger" onclick="killRandomPrimary()">ðŸ’¥ Kill Primary</button>
                    <button class="action-btn secondary" onclick="resetCluster()">ðŸ”„ Reset</button>
                </div>
            </div>
            <div class="control-card">
                <div class="control-title">ðŸŽ¬ Demo</div>
                <button class="auto-demo-btn" id="auto-demo-btn" onclick="toggleAutoDemo()">
                    <span class="demo-icon">â–¶ï¸</span>
                    <span id="demo-btn-text">Auto Demo</span>
                </button>
            </div>
        </div>

        <!-- Statistics Dashboard -->
        <div class="stats-dashboard" id="stats-dashboard">
            <div class="stat-card">
                <div class="stat-value" id="stat-writes">0</div>
                <div class="stat-label">Writes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-reads">0</div>
                <div class="stat-label">Reads</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-failed">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-elections">0</div>
                <div class="stat-label">Elections</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-avg-latency">0<span style="font-size: 0.8rem;">ms</span></div>
                <div class="stat-label">Avg Latency</div>
            </div>
        </div>

        <!-- Connection String Panel -->
        <div class="conn-string-panel" id="conn-string-panel">
            <div class="conn-string-title">ðŸ”— Connection String</div>
            <div class="conn-string-code" id="conn-string" onclick="copyConnectionString()">
                mongodb+srv://&lt;username&gt;:&lt;password&gt;@rs0-single.mongodb.net/?retryWrites=true&w=majority&readPreference=secondaryPreferred
            </div>
        </div>

        <!-- Mongos Layer -->
        <div class="mongos-layer">
            <div class="layer-title">ðŸ”€ Query Routers (mongos)</div>
            <div class="mongos-grid" id="mongos-container"></div>
        </div>

        <!-- Config Servers Layer -->
        <div class="config-layer">
            <div class="layer-title">âš™ï¸ Config Servers (CSRS)</div>
            <div class="config-grid" id="config-container"></div>
        </div>

        <!-- Shards Container (Sharded Cluster) -->
        <div class="shards-container" id="shards-container">
            <!-- Dynamically populated -->
        </div>

        <!-- Replica Set Container (Non-Sharded) -->
        <div class="rs-container" id="rs-container" style="display: none;">
            <!-- Dynamically populated -->
        </div>

        <!-- Event Log -->
        <div class="event-log-panel">
            <div class="event-log-title">ðŸ“‹ Event Log</div>
            <div class="event-log" id="event-log"></div>
        </div>
    </main>

    <!-- Replication Flow Overlay -->
    <div class="replication-overlay" id="replication-overlay"></div>

    <!-- Write Flow Status Panel -->
    <div class="write-flow-panel" id="write-flow-panel">
        <div class="write-flow-header">
            <div class="write-flow-title">âœï¸ Write Operation</div>
            <div class="write-flow-wc" id="flow-wc">w:majority</div>
        </div>
        <div class="write-flow-steps" id="write-flow-steps">
            <!-- Steps populated dynamically -->
        </div>
        <div class="write-flow-result" id="write-flow-result"></div>
    </div>

    <!-- Read Flow Status Panel -->
    <div class="read-flow-panel" id="read-flow-panel">
        <div class="read-flow-header">
            <div class="read-flow-title">ðŸ“– Read Operation</div>
            <div class="read-flow-pref" id="flow-read-pref">secondaryPreferred</div>
        </div>
        <div class="read-flow-content">
            <div class="read-flow-nodes" id="read-flow-nodes">
                <!-- Available nodes populated dynamically -->
            </div>
            <div class="read-flow-selection" id="read-flow-selection">
                <!-- Selected node shown here -->
            </div>
        </div>
        <div class="read-flow-result" id="read-flow-result"></div>
    </div>

    <!-- Election Modal -->
    <div class="modal-overlay" id="election-modal">
        <div class="modal">
            <div class="modal-icon">ðŸ—³ï¸</div>
            <div class="modal-title">Election in Progress</div>
            <div class="modal-text" id="election-text">Primary node is down. Initiating automatic failover...</div>
            <div class="election-progress">
                <div class="election-progress-bar" id="election-progress"></div>
            </div>
            <div id="election-status">Detecting failure...</div>
        </div>
    </div>

    <script>
        // ============ CLUSTER CONFIGURATIONS ============
        const CLUSTER_CONFIGS = {
            // ========== REPLICA SET CONFIGURATIONS ==========
            'rs-single-region': {
                name: 'Single Region Replica Set',
                description: 'Simple 3-node replica set in Region 1 (~1ms latency). If region fails, entire cluster goes down. Majority required: 2 nodes.',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' }
                ],
                nodes: [
                    { id: 'rs-n1', name: 'mongo-1', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-n2', name: 'mongo-2', region: 'region-1', priority: 1, votes: 1 },
                    { id: 'rs-n3', name: 'mongo-3', region: 'region-1', priority: 1, votes: 1 }
                ]
            },
            'rs-two-region': {
                name: 'Two Region Replica Set',
                description: '3-node replica set (2+1) across Region 1 and Region 2. ~10ms cross-region latency.',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' }
                ],
                nodes: [
                    { id: 'rs-r1-1', name: 'mongo-r1-1', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-r1-2', name: 'mongo-r1-2', region: 'region-1', priority: 1, votes: 1 },
                    { id: 'rs-r2', name: 'mongo-r2', region: 'region-2', priority: 1, votes: 1 }
                ]
            },
            'rs-three-region': {
                name: 'Three Region Replica Set',
                description: '5-node replica set (2-2-1). Region 1 â†” Region 2 ~10ms, Region 1/2 â†” Region 3 ~70ms. Region 3 = P:0 (DR).',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' },
                    { id: 'region-3', name: 'Region 3', icon: 'ðŸŸ ', latency: '~70ms' }
                ],
                nodes: [
                    { id: 'rs-r1-1', name: 'mongo-r1-1', region: 'region-1', priority: 3, votes: 1 },
                    { id: 'rs-r1-2', name: 'mongo-r1-2', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-r2-1', name: 'mongo-r2-1', region: 'region-2', priority: 1, votes: 1 },
                    { id: 'rs-r2-2', name: 'mongo-r2-2', region: 'region-2', priority: 1, votes: 1 },
                    { id: 'rs-r3', name: 'mongo-r3', region: 'region-3', priority: 0, votes: 1 }
                ]
            },
            'rs-ha-misconception': {
                name: 'âš ï¸ HA Misconception',
                description: 'Common pitfall: 4 nodes (2+1+read-only) but read-only node has votes:0. If Region 1 fails, only 1 vote remains - no majority (need 2)! Read-only nodes do NOT help with HA.',
                isSharded: false,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' }
                ],
                nodes: [
                    { id: 'rs-r1-1', name: 'mongo-r1-1', region: 'region-1', priority: 2, votes: 1 },
                    { id: 'rs-r1-2', name: 'mongo-r1-2', region: 'region-1', priority: 1, votes: 1 },
                    { id: 'rs-r2-1', name: 'mongo-r2-1', region: 'region-2', priority: 1, votes: 1 },
                    { id: 'rs-r2-read', name: 'read-only', region: 'region-2', priority: 0, votes: 0, isReadReplica: true }
                ]
            },
            // ========== SHARDED CLUSTER CONFIGURATIONS ==========
            'sharded-single-region': {
                name: 'Single Region Sharded',
                description: 'All nodes in Region 1 (~1ms latency). 2 shards Ã— 3 nodes + config servers + mongos. If region fails, entire cluster is down.',
                isSharded: true,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' }
                ],
                mongos: [
                    { id: 'mongos-r1-1', region: 'region-1' },
                    { id: 'mongos-r1-2', region: 'region-1' },
                    { id: 'mongos-r1-3', region: 'region-1' }
                ],
                configServers: [
                    { id: 'cfg-1', name: 'config-1', region: 'region-1', priority: 2 },
                    { id: 'cfg-2', name: 'config-2', region: 'region-1', priority: 1 },
                    { id: 'cfg-3', name: 'config-3', region: 'region-1', priority: 1 }
                ],
                shards: [
                    {
                        id: 'shard0', name: 'shard0',
                        nodes: [
                            { id: 's0-n1', name: 's0-r1-1', region: 'region-1', priority: 2 },
                            { id: 's0-n2', name: 's0-r1-2', region: 'region-1', priority: 1 },
                            { id: 's0-n3', name: 's0-r1-3', region: 'region-1', priority: 1 }
                        ]
                    },
                    {
                        id: 'shard1', name: 'shard1',
                        nodes: [
                            { id: 's1-n1', name: 's1-r1-1', region: 'region-1', priority: 2 },
                            { id: 's1-n2', name: 's1-r1-2', region: 'region-1', priority: 1 },
                            { id: 's1-n3', name: 's1-r1-3', region: 'region-1', priority: 1 }
                        ]
                    }
                ]
            },
            'sharded-two-region': {
                name: 'Two Region Sharded',
                description: 'Region 1 â†” Region 2 (~10ms latency). 2 shards Ã— 3 nodes (2+1) + 3 mongos + config servers.',
                isSharded: true,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' }
                ],
                mongos: [
                    { id: 'mongos-r1-1', region: 'region-1' },
                    { id: 'mongos-r1-2', region: 'region-1' },
                    { id: 'mongos-r2', region: 'region-2' }
                ],
                configServers: [
                    { id: 'cfg-r1-1', name: 'config-r1-1', region: 'region-1', priority: 2 },
                    { id: 'cfg-r1-2', name: 'config-r1-2', region: 'region-1', priority: 1 },
                    { id: 'cfg-r2', name: 'config-r2', region: 'region-2', priority: 1 }
                ],
                shards: [
                    {
                        id: 'shard0', name: 'shard0', preferredRegion: 'region-1',
                        nodes: [
                            { id: 's0-r1-1', name: 's0-r1-1', region: 'region-1', priority: 2 },
                            { id: 's0-r1-2', name: 's0-r1-2', region: 'region-1', priority: 1 },
                            { id: 's0-r2', name: 's0-r2', region: 'region-2', priority: 1 }
                        ]
                    },
                    {
                        id: 'shard1', name: 'shard1', preferredRegion: 'region-2',
                        nodes: [
                            { id: 's1-r2-1', name: 's1-r2-1', region: 'region-2', priority: 2 },
                            { id: 's1-r2-2', name: 's1-r2-2', region: 'region-2', priority: 1 },
                            { id: 's1-r1', name: 's1-r1', region: 'region-1', priority: 1 }
                        ]
                    }
                ]
            },
            'sharded-three-region': {
                name: 'Three Region Sharded',
                description: 'Region 1 â†” Region 2 (~10ms), Region 1/2 â†” Region 3 (~70ms). 2 shards Ã— 5 nodes (2-2-1). Region 3 = Priority 0 (DR).',
                isSharded: true,
                regions: [
                    { id: 'region-1', name: 'Region 1', icon: 'ðŸ”µ', latency: '~1ms' },
                    { id: 'region-2', name: 'Region 2', icon: 'ðŸŸ¢', latency: '~10ms' },
                    { id: 'region-3', name: 'Region 3', icon: 'ðŸŸ ', latency: '~70ms' }
                ],
                mongos: [
                    { id: 'mongos-r1', region: 'region-1' },
                    { id: 'mongos-r2', region: 'region-2' },
                    { id: 'mongos-r3', region: 'region-3' }
                ],
                configServers: [
                    { id: 'cfg-r1', name: 'config-r1', region: 'region-1', priority: 2 },
                    { id: 'cfg-r2', name: 'config-r2', region: 'region-2', priority: 1 },
                    { id: 'cfg-r3', name: 'config-r3', region: 'region-3', priority: 0 }
                ],
                shards: [
                    {
                        id: 'shard0', name: 'shard0', preferredRegion: 'region-1',
                        nodes: [
                            { id: 's0-r1-1', name: 's0-r1-1', region: 'region-1', priority: 3 },
                            { id: 's0-r1-2', name: 's0-r1-2', region: 'region-1', priority: 2 },
                            { id: 's0-r2-1', name: 's0-r2-1', region: 'region-2', priority: 1 },
                            { id: 's0-r2-2', name: 's0-r2-2', region: 'region-2', priority: 1 },
                            { id: 's0-r3', name: 's0-r3', region: 'region-3', priority: 0 }
                        ]
                    },
                    {
                        id: 'shard1', name: 'shard1', preferredRegion: 'region-2',
                        nodes: [
                            { id: 's1-r2-1', name: 's1-r2-1', region: 'region-2', priority: 3 },
                            { id: 's1-r2-2', name: 's1-r2-2', region: 'region-2', priority: 2 },
                            { id: 's1-r1-1', name: 's1-r1-1', region: 'region-1', priority: 1 },
                            { id: 's1-r1-2', name: 's1-r1-2', region: 'region-1', priority: 1 },
                            { id: 's1-r3', name: 's1-r3', region: 'region-3', priority: 0 }
                        ]
                    }
                ]
            }
        };

        // ============ STATE ============
        const state = {
            currentConfig: 'rs-single-region',
            isSharded: false,
            regions: [],
            regionStatus: {},
            // Replica Set state
            nodes: [],
            // Sharded state
            mongos: [],
            configServers: [],
            shards: [],
            // Routing options (for sharded)
            targetShard: 'auto',
            requestRegion: 'auto',
            // Common
            writeConcern: 'majority',
            readPreference: 'secondaryPreferred',
            oplogCounter: 0,
            isElecting: {},
            electionTerm: 1,
            writeAcknowledged: false,
            // Statistics
            stats: {
                writes: 0,
                reads: 0,
                failed: 0,
                elections: 0,
                latencies: [],
                avgLatency: 0
            },
            // Auto Demo
            demoRunning: false,
            demoStep: 0
        };
        
        // Latency map (in ms) between regions
        const LATENCY_MAP = {
            'region-1': { 'region-1': 1, 'region-2': 10, 'region-3': 70 },
            'region-2': { 'region-1': 10, 'region-2': 1, 'region-3': 70 },
            'region-3': { 'region-1': 70, 'region-2': 70, 'region-3': 1 }
        };

        // ============ HELPERS ============
        function generateObjectId() {
            return [...Array(24)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
        }

        function generateTimestamp() {
            return { t: Math.floor(Date.now() / 1000), i: state.oplogCounter++ };
        }

        function formatTimestamp(ts) {
            return `Timestamp(${ts.t}, ${ts.i})`;
        }

        function getVotingMembers(shardOrNodes) {
            const nodes = shardOrNodes.nodes || shardOrNodes;
            return nodes.filter(n => n.votes !== 0); // votes: 0 means non-voting
        }

        function getMajorityRequired(shardOrNodes) {
            const votingNodes = getVotingMembers(shardOrNodes);
            return Math.floor(votingNodes.length / 2) + 1;
        }

        function getHealthyNodes(shardOrNodes) {
            const nodes = shardOrNodes.nodes || shardOrNodes;
            return nodes.filter(n => n.status === 'healthy' || n.status === 'syncing');
        }

        function getHealthyVoters(shardOrNodes) {
            const nodes = shardOrNodes.nodes || shardOrNodes;
            return nodes.filter(n => (n.status === 'healthy' || n.status === 'syncing') && n.votes !== 0);
        }

        function hasMajority(shardOrNodes) {
            return getHealthyVoters(shardOrNodes).length >= getMajorityRequired(shardOrNodes);
        }

        function getRegionInfo(regionId) {
            return state.regions.find(r => r.id === regionId) || { name: 'Unknown', icon: 'â“' };
        }

        function getRandomCollection() {
            return ['test.users', 'test.orders', 'test.products'][Math.floor(Math.random() * 3)];
        }
        
        // Animation speed multiplier (higher = slower animations)
        // 1.0 = original speed, 2.0 = 2x slower, 3.0 = 3x slower
        let ANIM_SPEED = 2.5;
        const ANIM_SPEEDS = [1.0, 1.5, 2.5, 4.0]; // Fast, Normal, Slow, Very Slow
        let currentSpeedIndex = 2; // Start at "Slow" (2.5x)
        
        function toggleAnimSpeed() {
            currentSpeedIndex = (currentSpeedIndex + 1) % ANIM_SPEEDS.length;
            ANIM_SPEED = ANIM_SPEEDS[currentSpeedIndex];
            const labels = ['âš¡ Fast', 'ðŸƒ Normal', 'ðŸ¢ Slow', 'ðŸ¦¥ Very Slow'];
            log(`Animation speed: ${labels[currentSpeedIndex]} (${ANIM_SPEED}x)`, 'info');
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms * ANIM_SPEED));
        }
        
        // For timeouts that should also be slowed
        function animDelay(ms) {
            return ms * ANIM_SPEED;
        }

        // ============ CLUSTER MANAGEMENT ============
        function loadConfig(configId) {
            const config = CLUSTER_CONFIGS[configId];
            state.currentConfig = configId;
            state.isSharded = config.isSharded;
            
            // Initialize regions
            state.regions = config.regions.map(r => ({ ...r, status: 'healthy' }));
            state.regionStatus = {};
            state.regions.forEach(r => state.regionStatus[r.id] = 'healthy');
            
            state.oplogCounter = 0;
            state.isElecting = {};
            state.electionTerm = 1;

            if (config.isSharded) {
                // Sharded cluster initialization
                state.nodes = [];
                state.mongos = config.mongos.map(m => ({ ...m, status: 'healthy' }));
                state.configServers = config.configServers.map((c, i) => ({
                    ...c,
                    role: i === 0 ? 'primary' : 'secondary',
                    status: 'healthy',
                    oplogCount: 0
                }));
                state.shards = config.shards.map(shard => {
                    const shardNodes = shard.nodes.map(n => {
                        const maxPriority = Math.max(...shard.nodes.filter(x => x.priority > 0).map(x => x.priority));
                        const isHighestPriority = n.priority === maxPriority && 
                            shard.nodes.filter(x => x.priority === maxPriority).indexOf(n) === 0;
                        return {
                            ...n,
                            role: isHighestPriority ? 'primary' : 'secondary',
                            status: 'healthy',
                            oplog: [],
                            oplogCount: 0
                        };
                    });
                    return { ...shard, nodes: shardNodes };
                });
                
                // Update header
                const headerConfig = document.getElementById('header-config');
                if (headerConfig) {
                    headerConfig.textContent = `${state.shards.length} Shards Ã— ${state.shards[0].nodes.length} Nodes`;
                }
                
                // Show sharded layers, hide RS container
                document.querySelector('.mongos-layer').style.display = '';
                document.querySelector('.config-layer').style.display = '';
                document.getElementById('shards-container').style.display = '';
                document.getElementById('rs-container').style.display = 'none';
                
                // Show sharded-only controls and populate dropdowns
                document.getElementById('target-shard-card').style.display = '';
                document.getElementById('request-region-card').style.display = '';
                populateShardedDropdowns();
                
                renderCluster();
                log(`Loaded: ${config.name}`, 'success');
                log(`${state.shards.length} shards Ã— ${state.shards[0].nodes.length} nodes each`, 'info');
                log(`${state.mongos.length} mongos + ${state.configServers.length} config servers`, 'info');
            } else {
                // Replica set initialization
                state.mongos = [];
                state.configServers = [];
                state.shards = [];
                
                const maxPriority = Math.max(...config.nodes.filter(x => x.priority > 0).map(x => x.priority));
                state.nodes = config.nodes.map(n => {
                    const isHighestPriority = n.priority === maxPriority && 
                        config.nodes.filter(x => x.priority === maxPriority).indexOf(n) === 0;
                    return {
                        ...n,
                        role: isHighestPriority ? 'primary' : 'secondary',
                        status: 'healthy',
                        oplog: [],
                        oplogCount: 0
                    };
                });
                
                // Update header
                const headerConfig = document.getElementById('header-config');
                if (headerConfig) {
                    headerConfig.textContent = `rs0 (${state.nodes.length} nodes)`;
                }
                
                // Hide sharded layers, show RS container
                document.querySelector('.mongos-layer').style.display = 'none';
                document.querySelector('.config-layer').style.display = 'none';
                document.getElementById('shards-container').style.display = 'none';
                document.getElementById('rs-container').style.display = '';
                
                // Hide sharded-only controls
                document.getElementById('target-shard-card').style.display = 'none';
                document.getElementById('request-region-card').style.display = 'none';
                
                renderReplicaSet();
                log(`Loaded: ${config.name}`, 'success');
                const votingCount = getVotingMembers(state.nodes).length;
                const nonVotingCount = state.nodes.length - votingCount;
                const votingInfo = nonVotingCount > 0 ? ` (${votingCount} voting, ${nonVotingCount} non-voting)` : '';
                log(`${state.nodes.length}-node replica set${votingInfo}, majority: ${getMajorityRequired(state.nodes)}`, 'info');
            }

            updateInfoPanel(config);
            renderRegionButtons();
            updateClusterStatus();
            document.getElementById('event-log').innerHTML = '';
            resetStats();
            updateConnectionString();
        }

        function updateInfoPanel(config) {
            const panel = document.getElementById('info-panel');
            const isWarning = config.name.includes('Misconception');
            panel.style.borderColor = isWarning ? 'rgba(255, 107, 107, 0.5)' : 'rgba(0, 237, 100, 0.3)';
            panel.innerHTML = `
                <div class="info-icon">${isWarning ? 'âš ï¸' : 'ðŸ’¡'}</div>
                <div class="info-content">
                    <div class="info-title" style="${isWarning ? 'color: #ff6b6b;' : ''}">${config.name}</div>
                    <div class="info-desc">${config.description} <span style="opacity: 0.7;">â€¢ ðŸ‘† Click nodes to simulate failure/recovery</span></div>
                    ${isWarning ? `
                        <div style="margin-top: 8px; padding: 8px 12px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; font-size: 0.8rem; color: #ff6b6b;">
                            <strong>âš¡ Test it:</strong> Kill Region 1 and watch the cluster lose majority despite having 2 nodes in Region 2!
                        </div>
                        <div style="margin-top: 8px; padding: 8px 12px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; font-size: 0.8rem; color: #ffc107;">
                            <strong>ðŸ“ Note:</strong> To recover, you must <u>manually</u> promote the read-only node by changing its priority and votes via rs.reconfig(). This requires human intervention!
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderRegionButtons() {
            const container = document.getElementById('region-buttons');
            container.innerHTML = state.regions.map(r => {
                const regionClass = r.id.replace('region-', 'region-');
                const isDown = state.regionStatus[r.id] === 'down';
                return `
                    <button class="region-btn ${regionClass}" onclick="toggleRegion('${r.id}')">
                        ${isDown ? 'âœ“ Restore' : 'ðŸ’¥ Kill'} ${r.name}
                    </button>
                `;
            }).join('');
        }

        // ============ REGION CONTROL ============
        function toggleRegion(regionId) {
            if (state.isSharded) {
                toggleShardedRegion(regionId);
            } else {
                toggleRSRegion(regionId);
            }
        }

        function toggleRSRegion(regionId) {
            const isDown = state.regionStatus[regionId] === 'down';
            const regionInfo = getRegionInfo(regionId);
            
            if (isDown) {
                state.regionStatus[regionId] = 'healthy';
                state.nodes.filter(n => n.region === regionId).forEach(n => {
                    n.status = 'recovering';
                });
                
                log(`${regionInfo.name} coming back online...`, 'warning');
                renderReplicaSet();
                renderRegionButtons();
                
                setTimeout(() => {
                    state.nodes.filter(n => n.region === regionId).forEach(n => {
                        n.status = 'healthy';
                    });
                    
                    if (!state.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(state.nodes)) {
                        triggerRSElection();
                    }
                    
                    log(`${regionInfo.name} restored`, 'success');
                    renderReplicaSet();
                    updateClusterStatus();
                }, 2000);
            } else {
                state.regionStatus[regionId] = 'down';
                let hadPrimary = false;
                
                state.nodes.filter(n => n.region === regionId).forEach(n => {
                    if (n.role === 'primary') hadPrimary = true;
                    n.status = 'down';
                    n.role = 'secondary';
                    n.oplog = [];
                });
                
                const currentPrimary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                if (currentPrimary && !hasMajority(state.nodes)) {
                    log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                    currentPrimary.role = 'secondary';
                }
                
                log(`âš ï¸ ${regionInfo.name} FAILED`, 'error');
                renderReplicaSet();
                renderRegionButtons();
                updateClusterStatus();
                
                // Only trigger election if we have majority AND lost the primary
                if (hadPrimary) {
                    if (hasMajority(state.nodes)) {
                        triggerRSElection();
                    } else {
                        const healthyVoters = getHealthyVoters(state.nodes);
                        const majorityRequired = getMajorityRequired(state.nodes);
                        log(`âš ï¸ NO MAJORITY: ${healthyVoters.length} voters < ${majorityRequired} required. Cluster is READ-ONLY!`, 'error');
                    }
                }
            }
        }

        function toggleShardedRegion(regionId) {
            const isDown = state.regionStatus[regionId] === 'down';
            const regionInfo = getRegionInfo(regionId);
            
            if (isDown) {
                state.regionStatus[regionId] = 'healthy';
                
                state.mongos.filter(m => m.region === regionId).forEach(m => m.status = 'healthy');
                state.configServers.filter(c => c.region === regionId).forEach(c => {
                    c.status = 'recovering';
                });
                state.shards.forEach(shard => {
                    shard.nodes.filter(n => n.region === regionId).forEach(n => {
                        n.status = 'recovering';
                    });
                });
                
                log(`${regionInfo.name} coming back online...`, 'warning');
                renderCluster();
                renderRegionButtons();
                
                setTimeout(() => {
                    state.configServers.filter(c => c.region === regionId).forEach(c => {
                        c.status = 'healthy';
                    });
                    if (!state.configServers.some(c => c.role === 'primary' && c.status === 'healthy')) {
                        const candidate = state.configServers.filter(c => c.status === 'healthy').sort((a, b) => b.priority - a.priority)[0];
                        if (candidate) {
                            candidate.role = 'primary';
                            log(`Config server ${candidate.name} elected PRIMARY`, 'success');
                        }
                    }
                    
                    state.shards.forEach(shard => {
                        shard.nodes.filter(n => n.region === regionId).forEach(n => {
                            n.status = 'healthy';
                        });
                        if (!shard.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(shard)) {
                            triggerElection(shard);
                        }
                    });
                    
                    log(`${regionInfo.name} restored`, 'success');
                    renderCluster();
                    updateClusterStatus();
                }, 2000);
            } else {
                state.regionStatus[regionId] = 'down';
                
                state.mongos.filter(m => m.region === regionId).forEach(m => m.status = 'down');
                
                state.configServers.filter(c => c.region === regionId).forEach(c => {
                    const wasPrimary = c.role === 'primary';
                    c.status = 'down';
                    c.role = 'secondary';
                    if (wasPrimary) {
                        const newPrimary = state.configServers.filter(x => x.status === 'healthy').sort((a, b) => b.priority - a.priority)[0];
                        if (newPrimary) {
                            newPrimary.role = 'primary';
                            log(`Config server ${newPrimary.name} elected PRIMARY`, 'success');
                        }
                    }
                });
                
                const affectedShards = [];
                state.shards.forEach(shard => {
                    const regionNodes = shard.nodes.filter(n => n.region === regionId);
                    const hadPrimary = regionNodes.some(n => n.role === 'primary');
                    
                    regionNodes.forEach(n => {
                        n.status = 'down';
                        n.role = 'secondary';
                        n.oplog = [];
                    });
                    
                    const currentPrimary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                    if (currentPrimary && !hasMajority(shard)) {
                        log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                        currentPrimary.role = 'secondary';
                    }
                    
                    if (hadPrimary) affectedShards.push(shard);
                });
                
                log(`âš ï¸ ${regionInfo.name} FAILED`, 'error');
                renderCluster();
                renderRegionButtons();
                updateClusterStatus();
                
                // Only trigger election for shards that have majority
                affectedShards.forEach(shard => {
                    if (hasMajority(shard)) {
                        triggerElection(shard);
                    } else {
                        const healthyVoters = getHealthyVoters(shard);
                        const majorityRequired = getMajorityRequired(shard);
                        log(`âš ï¸ ${shard.name}: NO MAJORITY (${healthyVoters.length}/${majorityRequired}). Shard is READ-ONLY!`, 'error');
                    }
                });
            }
        }

        // ============ NODE CONTROL (SHARDED) ============
        function toggleNode(shardId, nodeId) {
            const shard = state.shards.find(s => s.id === shardId);
            const node = shard.nodes.find(n => n.id === nodeId);
            
            if (node.status === 'down') {
                node.status = 'recovering';
                log(`${node.name} recovering...`, 'warning');
                renderCluster();
                
                setTimeout(() => {
                    node.status = 'syncing';
                    log(`${node.name} syncing oplog...`, 'info');
                    renderCluster();
                    
                    const syncTime = 3000 + Math.random() * 2000;
                    setTimeout(() => {
                        node.status = 'healthy';
                        log(`${node.name} is healthy (priority ${node.priority})`, 'success');
                        renderCluster();
                        updateClusterStatus();
                        
                        if (!shard.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(shard)) {
                            triggerElection(shard);
                        }
                    }, syncTime);
                }, 1500);
            } else {
                const wasPrimary = node.role === 'primary';
                node.status = 'down';
                node.role = 'secondary';
                node.oplog = [];
                log(`${node.name} is DOWN`, 'error');
                renderCluster();
                updateClusterStatus();
                
                // Check if current primary lost majority
                const currentPrimary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                if (currentPrimary && !hasMajority(shard)) {
                    log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                    currentPrimary.role = 'secondary';
                    renderCluster();
                    updateClusterStatus();
                }
                
                // Only trigger election if we have majority AND lost the primary
                if (wasPrimary) {
                    if (hasMajority(shard)) {
                        triggerElection(shard);
                    } else {
                        const healthyVoters = getHealthyVoters(shard);
                        const majorityRequired = getMajorityRequired(shard);
                        log(`âš ï¸ ${shard.name}: NO MAJORITY (${healthyVoters.length}/${majorityRequired}). Shard is READ-ONLY!`, 'error');
                    }
                }
            }
        }

        function killRandomPrimary() {
            if (state.isSharded) {
                const shardsWithPrimary = state.shards.filter(s => s.nodes.some(n => n.role === 'primary' && n.status === 'healthy'));
                if (shardsWithPrimary.length === 0) {
                    log('No healthy primary to kill', 'warning');
                    return;
                }
                const shard = shardsWithPrimary[Math.floor(Math.random() * shardsWithPrimary.length)];
                const primary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                log(`Killing ${shard.name} primary: ${primary.name}`, 'warning');
                toggleNode(shard.id, primary.id);
            } else {
                killRSPrimary();
            }
        }

        // ============ ELECTION (SHARDED) ============
        function triggerElection(shard) {
            if (state.isElecting[shard.id]) return;
            state.isElecting[shard.id] = true;
            
            const majorityRequired = getMajorityRequired(shard);
            const healthyNodes = getHealthyNodes(shard);
            const eligibleCandidates = healthyNodes.filter(n => n.priority > 0);
            
            const modal = document.getElementById('election-modal');
            const progressBar = document.getElementById('election-progress');
            const electionStatus = document.getElementById('election-status');
            const electionText = document.getElementById('election-text');
            const modalTitle = modal.querySelector('.modal-title');
            const modalIcon = modal.querySelector('.modal-icon');
            
            modal.classList.add('visible');
            
            const healthyVoters = getHealthyVoters(shard);
            if (healthyVoters.length < majorityRequired) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                const hasNonVoting = shard.nodes.some(n => n.votes === 0);
                const nonVotingNote = hasNonVoting ? '<br><span style="font-size: 0.75rem; color: #ff6b6b;">Read-only nodes (v:0) cannot vote!</span>' : '';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">${shard.name}: No majority!</strong><br><br>
                    Healthy voters: <strong>${healthyVoters.length}</strong><br>
                    Majority required: <strong>${majorityRequired}</strong>${nonVotingNote}<br><br>
                    <span style="font-size: 0.8rem;">âš ï¸ ${shard.name} is READ-ONLY</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = 'var(--node-down)';
                electionStatus.textContent = `${shard.name}: Writes blocked`;
                
                log(`${shard.name} election FAILED: no majority (${healthyVoters.length} voters / ${majorityRequired} needed)`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting[shard.id] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 4000);
                return;
            }
            
            if (eligibleCandidates.length === 0) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">${shard.name}: No eligible candidates!</strong><br><br>
                    Only Priority 0 nodes available<br><br>
                    <span style="font-size: 0.8rem;">â³ Priority 0 nodes cannot become primary</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = '#00b4d8';
                electionStatus.textContent = 'P:0 nodes are DR-only';
                
                log(`${shard.name} election FAILED: only P:0 nodes available`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting[shard.id] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 3000);
                return;
            }
            
            const sortedCandidates = eligibleCandidates.sort((a, b) => b.priority - a.priority);
            const newPrimary = sortedCandidates[0];
            
            electionText.textContent = `${shard.name}: Initiating failover...`;
            
            const steps = [
                { progress: 20, text: 'Detecting primary failure...' },
                { progress: 40, text: `Checking quorum: ${healthyNodes.length}/${majorityRequired} âœ“` },
                { progress: 60, text: `Highest priority: ${newPrimary.name} (p:${newPrimary.priority})` },
                { progress: 85, text: 'Votes collected, majority achieved!' },
                { progress: 100, text: `${newPrimary.name} elected PRIMARY!` }
            ];

            let stepIndex = 0;
            const stepInterval = setInterval(() => {
                if (stepIndex < steps.length) {
                    progressBar.style.width = `${steps[stepIndex].progress}%`;
                    electionStatus.textContent = steps[stepIndex].text;
                    stepIndex++;
                } else {
                    clearInterval(stepInterval);
                    
                    newPrimary.role = 'primary';
                    const region = getRegionInfo(newPrimary.region);
                    log(`${shard.name}: ${newPrimary.name} elected PRIMARY (${region.name}, p:${newPrimary.priority})`, 'success');
                    updateStats('election');
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        state.isElecting[shard.id] = false;
                        renderCluster();
                        updateClusterStatus();
                        updateConnectionString();
                        progressBar.style.width = '0%';
                    }, 800);
                }
            }, 400);
        }

        // ============ OPLOG ============
        function createOplogEntry(op, ns, document, update = null) {
            const ts = generateTimestamp();
            const entry = {
                ts: ts,
                t: state.electionTerm,
                op: op,
                ns: ns,
                wall: new Date().toISOString()
            };

            if (op === 'i') entry.o = document;
            else if (op === 'u') { entry.o = update; entry.o2 = { _id: document._id }; }
            else if (op === 'd') entry.o = { _id: document._id };

            return entry;
        }

        function addToOplog(node, entry) {
            node.oplog.unshift(entry);
            node.oplogSize += 100;
            node.lastApplied = entry.ts;
            if (node.oplog.length > 10) node.oplog.pop();
        }

        // ============ VISUAL WRITE FLOW ============
        function showWriteFlowPanel(operation, targetShard = null, isSharded = true) {
            const panel = document.getElementById('write-flow-panel');
            const wcLabel = document.getElementById('flow-wc');
            const stepsContainer = document.getElementById('write-flow-steps');
            const resultEl = document.getElementById('write-flow-result');
            
            wcLabel.textContent = `w:${state.writeConcern}`;
            resultEl.className = 'write-flow-result';
            resultEl.style.display = 'none';
            
            let nodes, primary, secondaries, totalVotingMembers, majorityNeeded, wcRequired, targetName;
            
            if (isSharded && targetShard) {
                // Sharded cluster mode
                nodes = targetShard.nodes;
                targetName = targetShard.name;
            } else {
                // Replica set mode
                nodes = state.nodes;
                targetName = 'rs0';
            }
            
            primary = nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            secondaries = nodes.filter(n => n.role === 'secondary' && n.status === 'healthy');
            totalVotingMembers = nodes.length;
            majorityNeeded = getMajorityRequired(nodes);
            wcRequired = state.writeConcern === 'majority' ? majorityNeeded 
                         : state.writeConcern === '1' ? 1 
                         : totalVotingMembers;
            
            // Determine step 4 content based on write concern
            let step4Label, step4Detail;
            if (state.writeConcern === '1') {
                step4Label = 'Background Replication';
                step4Detail = `${secondaries.length} secondaries (fire-and-forget, not waited)`;
            } else if (state.writeConcern === 'majority') {
                step4Label = 'Replicate to Secondaries';
                step4Detail = `Need ${majorityNeeded - 1} more acks (majority = ${majorityNeeded} total)`;
            } else {
                step4Label = 'Replicate to ALL Secondaries';
                step4Detail = `Need all ${secondaries.length} secondaries to ack`;
            }
            
            const step1Label = isSharded 
                ? `Client â†’ mongos â†’ ${targetName}`
                : `Client â†’ ${targetName}`;
            
            stepsContainer.innerHTML = `
                <div class="write-flow-step" id="step-1">
                    <span class="step-icon">ðŸ“</span>
                    <div class="step-content">
                        <div class="step-label">${step1Label}</div>
                        <div class="step-detail">Operation: ${operation.toUpperCase()}</div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-2">
                    <span class="step-icon">ðŸ‘‘</span>
                    <div class="step-content">
                        <div class="step-label">Write to Primary</div>
                        <div class="step-detail">Target: ${primary ? primary.name : 'N/A'}</div>
                        <div class="step-nodes">
                            ${primary ? `<span class="step-node-badge primary">${primary.name} âœ“</span>` : '<span class="step-node-badge">No primary</span>'}
                        </div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-3">
                    <span class="step-icon">ðŸ“‹</span>
                    <div class="step-content">
                        <div class="step-label">Write to Oplog</div>
                        <div class="step-detail">local.oplog.rs on primary</div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-4">
                    <span class="step-icon">${state.writeConcern === '1' ? 'ðŸ’¨' : 'ðŸ”„'}</span>
                    <div class="step-content">
                        <div class="step-label">${step4Label}</div>
                        <div class="step-detail">${step4Detail}</div>
                        <div class="step-nodes" id="replication-nodes">
                            ${secondaries.map(s => `<span class="step-node-badge pending" id="badge-${s.id}">${s.name}</span>`).join('')}
                        </div>
                    </div>
                </div>
                <div class="write-flow-step" id="step-5">
                    <span class="step-icon">âœ…</span>
                    <div class="step-content">
                        <div class="step-label">Wait for Acknowledgment</div>
                        <div class="step-detail">w:${state.writeConcern} = ${state.writeConcern === 'majority' ? majorityNeeded + ' nodes (n/2+1 where n=' + totalVotingMembers + ')' : state.writeConcern === '1' ? 'primary only (instant)' : 'all ' + totalVotingMembers + ' nodes'}</div>
                        <div class="step-nodes" id="ack-count">
                            <span class="step-node-badge">0 / ${wcRequired}</span>
                        </div>
                    </div>
                </div>
            `;
            
            panel.classList.add('visible');
        }

        function updateFlowStep(stepNum, active = false, complete = false) {
            const step = document.getElementById(`step-${stepNum}`);
            if (step) {
                step.classList.remove('active', 'complete');
                if (active) step.classList.add('active');
                if (complete) step.classList.add('complete');
            }
        }

        function updateReplicationBadge(nodeId, acked = false) {
            const badge = document.getElementById(`badge-${nodeId}`);
            if (badge) {
                badge.classList.remove('pending');
                badge.classList.add('acked');
                badge.textContent = badge.textContent.split(' ')[0] + ' âœ“';
            }
        }

        function updateAckCount(count, required) {
            const ackEl = document.getElementById('ack-count');
            if (ackEl) {
                const isComplete = count >= required;
                let statusText = '';
                let badgeClass = 'pending';
                
                if (isComplete) {
                    badgeClass = 'majority-reached';
                    if (state.writeConcern === '1') {
                        statusText = 'âœ“ PRIMARY ACK';
                    } else if (state.writeConcern === 'majority') {
                        statusText = 'âœ“ MAJORITY!';
                    } else {
                        statusText = 'âœ“ ALL NODES!';
                    }
                }
                
                ackEl.innerHTML = `
                    <span class="step-node-badge ${badgeClass}">
                        ${count} / ${required} ${statusText}
                    </span>
                `;
            }
        }

        function showWriteResult(success, message) {
            const resultEl = document.getElementById('write-flow-result');
            resultEl.textContent = message;
            resultEl.className = `write-flow-result ${success ? 'success' : 'failed'}`;
            resultEl.style.display = 'block';
            
            setTimeout(() => {
                document.getElementById('write-flow-panel').classList.remove('visible');
            }, animDelay(2500));
        }

        function animateParticle(fromEl, toEl, type, duration = 400) {
            const scaledDuration = duration * ANIM_SPEED;
            return new Promise(resolve => {
                const overlay = document.getElementById('replication-overlay');
                const particle = document.createElement('div');
                particle.className = `flow-particle ${type}`;
                overlay.appendChild(particle);

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                
                const startX = fromRect.left + fromRect.width / 2;
                const startY = fromRect.top + fromRect.height / 2;
                const endX = toRect.left + toRect.width / 2;
                const endY = toRect.top + toRect.height / 2;

                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;

                const startTime = performance.now();

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / scaledDuration, 1);
                    
                    // Easing
                    const eased = 1 - Math.pow(1 - progress, 3);

                    particle.style.left = `${startX + (endX - startX) * eased}px`;
                    particle.style.top = `${startY + (endY - startY) * eased}px`;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                        resolve();
                    }
                }

                requestAnimationFrame(animate);
            });
        }

        function highlightNode(nodeId, type) {
            const nodeEl = document.getElementById(`node-${nodeId}`);
            if (nodeEl) {
                nodeEl.classList.add(type);
                setTimeout(() => nodeEl.classList.remove(type), 1500);
            }
        }

        // ============ SIMULATE OPERATIONS (SHARDED) ============
        async function simulateShardedWrite(operation) {
            // Select target shard based on user selection or random
            let targetShard;
            if (state.targetShard === 'auto') {
                targetShard = state.shards[Math.floor(Math.random() * state.shards.length)];
            } else {
                targetShard = state.shards.find(s => s.id === state.targetShard);
                if (!targetShard) {
                    log(`${operation.toUpperCase()} FAILED: Shard ${state.targetShard} not found`, 'error');
                    return;
                }
            }
            
            const primary = targetShard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            
            if (!primary) { 
                const reason = !hasMajority(targetShard) ? ' (no majority - shard is read-only)' : '';
                log(`${operation.toUpperCase()} FAILED: No primary on ${targetShard.name}${reason}`, 'error');
                updateStats('failed');
                return; 
            }

            // Select mongos based on request region
            let activeMongos;
            if (state.requestRegion === 'auto') {
                activeMongos = state.mongos.find(m => state.regionStatus[m.region] === 'healthy');
            } else {
                activeMongos = state.mongos.find(m => m.region === state.requestRegion && state.regionStatus[m.region] === 'healthy');
                if (!activeMongos) {
                    log(`${operation.toUpperCase()} FAILED: No mongos in ${state.regions.find(r => r.id === state.requestRegion)?.name || state.requestRegion}`, 'error');
                    return;
                }
            }
            
            if (!activeMongos) {
                log(`${operation.toUpperCase()} FAILED: No mongos available`, 'error');
                return;
            }
            
            // Determine if this is a cross-region write
            const mongosRegion = state.regions.find(r => r.id === activeMongos.region);
            const primaryRegion = state.regions.find(r => r.id === primary.region);
            const isCrossRegion = activeMongos.region !== primary.region;

            const secondaries = targetShard.nodes.filter(n => n.role === 'secondary' && n.status === 'healthy');
            const majorityNeeded = getMajorityRequired(targetShard);
            const wcRequired = state.writeConcern === 'majority' ? majorityNeeded : 
                              state.writeConcern === '1' ? 1 : targetShard.nodes.length;

            // w:all check
            if (state.writeConcern === 'all') {
                const downNodes = targetShard.nodes.filter(n => n.status !== 'healthy');
                if (downNodes.length > 0) {
                    const downNames = downNodes.map(n => n.name.split('-').slice(-2).join('-')).join(', ');
                    log(`${operation.toUpperCase()} TIMEOUT: w:all requires all ${targetShard.nodes.length} nodes on ${targetShard.name}`, 'error');
                    log(`â³ Waiting indefinitely for: ${downNames}`, 'error');
                    log(`ðŸ’¡ Reduce write concern or restore nodes to proceed`, 'warning');
                    showWriteFlowPanel(operation, targetShard, true);
                    showWriteResult(false, `âœ— TIMEOUT: w:all needs all ${targetShard.nodes.length} nodes`);
                    return;
                }
            }

            // Show write flow panel
            showWriteFlowPanel(operation, targetShard, true);

            // Log with cross-region indicator
            const routeInfo = isCrossRegion 
                ? `ðŸŒ CROSS-REGION: ${mongosRegion.name} â†’ ${primaryRegion.name}` 
                : `âœ“ LOCAL: ${mongosRegion.name}`;
            log(`${operation.toUpperCase()} â†’ ${targetShard.name} via ${activeMongos.id}`, 'info');
            log(`   ${routeInfo}`, isCrossRegion ? 'warning' : 'info');
            
            // Step 1: Client to mongos
            updateFlowStep(1, true);
            await sleep(150);
            updateFlowStep(1, false, true);
            
            // Step 2: Write to primary
            updateFlowStep(2, true);
            
            // Animate: mongos â†’ primary
            const mongosEl = document.getElementById(`mongos-${activeMongos.id}`);
            const primaryEl = document.getElementById(`node-${primary.id}`);
            
            if (mongosEl && primaryEl) {
                await animateParticle(mongosEl, primaryEl, 'write', 350);
            }
            
            if (primaryEl) {
                primaryEl.classList.add('receiving');
                setTimeout(() => primaryEl.classList.remove('receiving'), 500);
            }
            primary.oplogCount++;
            renderCluster();
            updateFlowStep(2, false, true);
            
            // Step 3: Write to oplog
            updateFlowStep(3, true);
            await sleep(100);
            updateFlowStep(3, false, true);
            
            let ackCount = 1;
            updateAckCount(ackCount, wcRequired);
            
            // Step 4: Replication
            updateFlowStep(4, true);
            
            // w:1 - done
            if (state.writeConcern === '1') {
                log(`${operation.toUpperCase()} acknowledged (w:1 = primary only)`, 'success');
                updateStats('write', 5);
                updateFlowStep(4, false, true);
                updateFlowStep(5, false, true);
                showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:1)`);
                
                // Background replication
                secondaries.forEach((sec, i) => {
                    setTimeout(async () => {
                        if (sec.status === 'healthy') {
                            sec.oplogCount++;
                            const secEl = document.getElementById(`node-${sec.id}`);
                            if (primaryEl && secEl) {
                                animateParticle(primaryEl, secEl, 'replication', 300);
                            }
                            if (secEl) {
                                setTimeout(() => {
                                    secEl.classList.add('receiving');
                                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                                }, animDelay(400));
                            }
                            renderCluster();
                        }
                    }, animDelay(150 + i * 200));
                });
                return;
            }
            
            // Replicate and count acks
            let majorityReached = false;
            for (let i = 0; i < secondaries.length; i++) {
                const sec = secondaries[i];
                
                if (sec.status !== 'healthy') continue;
                
                // Animate replication particle
                const secEl = document.getElementById(`node-${sec.id}`);
                if (primaryEl && secEl) {
                    await animateParticle(primaryEl, secEl, 'replication', 250);
                }
                
                sec.oplogCount++;
                if (secEl) {
                    secEl.classList.add('receiving');
                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                }
                renderCluster();
                ackCount++;
                updateReplicationBadge(sec.id, true);
                updateAckCount(ackCount, wcRequired);
                
                if (ackCount >= wcRequired && !majorityReached) {
                    majorityReached = true;
                    updateFlowStep(4, false, true);
                    updateFlowStep(5, false, true);
                    if (secEl) {
                        secEl.classList.add('acknowledged');
                        setTimeout(() => secEl.classList.remove('acknowledged'), animDelay(2000));
                    }
                    const wcName = state.writeConcern === 'majority' ? 'majority' : 'all';
                    log(`${operation.toUpperCase()} acknowledged (w:${wcName} = ${wcRequired} acks)`, 'success');
                    updateStats('write', 10 + ackCount * 5);
                    showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:${wcName})`);
                }
                
                await sleep(150);
            }
        }
        
        async function simulateInsert() {
            if (state.isSharded) {
                await simulateShardedWrite('insert');
            } else {
                await simulateRSWrite('insert');
            }
        }

        async function simulateUpdate() {
            if (state.isSharded) {
                await simulateShardedWrite('update');
            } else {
                await simulateRSWrite('update');
            }
        }

        async function simulateRead() {
            if (state.isSharded) {
                await simulateShardedRead();
            } else {
                await simulateRSRead();
            }
        }

        // ============ REPLICA SET OPERATIONS ============
        async function simulateRSWrite(operation) {
            const primary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            if (!primary) {
                const reason = !hasMajority(state.nodes) ? ' (no majority - cluster is read-only)' : '';
                log(`${operation.toUpperCase()} FAILED: No primary${reason}`, 'error');
                updateStats('failed');
                return;
            }

            const secondaries = state.nodes.filter(n => n.role === 'secondary' && n.status === 'healthy');
            const majorityNeeded = getMajorityRequired(state.nodes);
            const totalNodes = state.nodes.length;
            const wcRequired = state.writeConcern === 'majority' ? majorityNeeded : 
                              state.writeConcern === '1' ? 1 : totalNodes;

            // w:all check
            if (state.writeConcern === 'all') {
                const downNodes = state.nodes.filter(n => n.status !== 'healthy');
                if (downNodes.length > 0) {
                    const downNames = downNodes.map(n => n.name).join(', ');
                    log(`${operation.toUpperCase()} TIMEOUT: w:all requires all ${totalNodes} nodes`, 'error');
                    log(`â³ Waiting indefinitely for: ${downNames}`, 'error');
                    log(`ðŸ’¡ Reduce write concern or restore nodes to proceed`, 'warning');
                    showWriteFlowPanel(operation, null, false);
                    showWriteResult(false, `âœ— TIMEOUT: w:all needs all ${totalNodes} nodes`);
                    return;
                }
            }

            // Show write flow panel
            showWriteFlowPanel(operation, null, false);
            
            log(`${operation.toUpperCase()} â†’ ${primary.name}`, 'info');
            
            // Step 1: Client to RS
            updateFlowStep(1, true);
            await sleep(200);
            updateFlowStep(1, false, true);
            
            // Step 2: Write to primary with particle animation
            updateFlowStep(2, true);
            const primaryEl = document.getElementById(`node-${primary.id}`);
            
            // Animate particle from info panel (representing client) to primary
            const clientEl = document.getElementById('info-panel');
            if (clientEl && primaryEl) {
                await animateParticle(clientEl, primaryEl, 'write', 350);
            }
            
            if (primaryEl) {
                primaryEl.classList.add('receiving');
                setTimeout(() => primaryEl.classList.remove('receiving'), animDelay(800));
            }
            primary.oplogCount++;
            renderReplicaSet();
            updateFlowStep(2, false, true);
            
            // Step 3: Write to oplog
            updateFlowStep(3, true);
            await sleep(200);
            updateFlowStep(3, false, true);
            
            let ackCount = 1;
            updateAckCount(ackCount, wcRequired);
            
            // Step 4: Replication
            updateFlowStep(4, true);
            
            if (state.writeConcern === '1') {
                const latency = isCrossRegion ? getLatency(activeMongos.region, primary.region) : 5;
                log(`${operation.toUpperCase()} acknowledged (w:1 = primary only)`, 'success');
                updateStats('write', latency);
                updateFlowStep(4, false, true);
                updateFlowStep(5, false, true);
                showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:1) [${latency}ms]`);
                
                // Background replication (fire-and-forget)
                secondaries.forEach((sec, i) => {
                    setTimeout(async () => {
                        if (sec.status === 'healthy') {
                            sec.oplogCount++;
                            const secEl = document.getElementById(`node-${sec.id}`);
                            if (primaryEl && secEl) {
                                animateParticle(primaryEl, secEl, 'replication', 400);
                            }
                            if (secEl) {
                                setTimeout(() => {
                                    secEl.classList.add('receiving');
                                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                                }, animDelay(400));
                            }
                            renderReplicaSet();
                        }
                    }, animDelay(150 + i * 200));
                });
                return;
            }
            
            let majorityReached = false;
            for (let i = 0; i < secondaries.length; i++) {
                const sec = secondaries[i];
                
                if (sec.status !== 'healthy') continue;
                
                // Animate replication particle
                const secEl = document.getElementById(`node-${sec.id}`);
                if (primaryEl && secEl) {
                    await animateParticle(primaryEl, secEl, 'replication', 250);
                }
                
                sec.oplogCount++;
                if (secEl) {
                    secEl.classList.add('receiving');
                    setTimeout(() => secEl.classList.remove('receiving'), animDelay(800));
                }
                renderReplicaSet();
                ackCount++;
                updateReplicationBadge(sec.id, true);
                updateAckCount(ackCount, wcRequired);
                
                if (ackCount >= wcRequired && !majorityReached) {
                    majorityReached = true;
                    const latency = 10 + ackCount * 5;
                    updateFlowStep(4, false, true);
                    updateFlowStep(5, false, true);
                    if (secEl) {
                        secEl.classList.add('acknowledged');
                        setTimeout(() => secEl.classList.remove('acknowledged'), animDelay(2000));
                    }
                    const wcName = state.writeConcern === 'majority' ? 'majority' : 'all';
                    log(`${operation.toUpperCase()} acknowledged (w:${wcName} = ${wcRequired} acks)`, 'success');
                    updateStats('write', latency);
                    showWriteResult(true, `âœ“ ${operation.toUpperCase()} acknowledged (w:${wcName}) [${latency}ms]`);
                }
                
                await sleep(150);
            }
        }

        async function simulateRSRead() {
            const readPref = state.readPreference;
            const healthyNodes = state.nodes.filter(n => n.status === 'healthy');
            
            if (healthyNodes.length === 0) {
                log(`READ FAILED: No healthy nodes`, 'error');
                return;
            }

            let targetNode = null;
            const primary = healthyNodes.find(n => n.role === 'primary');
            const secondaries = healthyNodes.filter(n => n.role === 'secondary');

            switch (readPref) {
                case 'primary':
                    targetNode = primary;
                    if (!targetNode) {
                        log(`READ FAILED: No primary (readPreference: primary)`, 'error');
                        return;
                    }
                    break;
                case 'primaryPreferred':
                    targetNode = primary || secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondary':
                    if (secondaries.length === 0) {
                        log(`READ FAILED: No secondaries (readPreference: secondary)`, 'error');
                        return;
                    }
                    targetNode = secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondaryPreferred':
                    targetNode = secondaries.length > 0 ? 
                        secondaries[Math.floor(Math.random() * secondaries.length)] : primary;
                    break;
                case 'nearest':
                    targetNode = healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
                    break;
                default:
                    targetNode = healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
            }

            if (!targetNode) {
                log(`READ FAILED: No eligible node for ${readPref}`, 'error');
                return;
            }

            const region = getRegionInfo(targetNode.region);
            log(`READ (${readPref}) â†’ ${targetNode.name} (${region.name})`, 'info');
            
            // Show read flow panel
            showReadFlowPanel(readPref, targetNode, healthyNodes);
            
            const nodeEl = document.getElementById(`node-${targetNode.id}`);
            const clientEl = document.getElementById('info-panel');
            
            // Animate request: client â†’ node
            if (clientEl && nodeEl) {
                await animateParticle(clientEl, nodeEl, 'read', 300);
            }
            
            if (nodeEl) {
                nodeEl.classList.add('reading');
                setTimeout(() => nodeEl.classList.remove('reading'), animDelay(1000));
            }
            
            await sleep(200);
            
            // Animate response: node â†’ client
            if (nodeEl && clientEl) {
                await animateParticle(nodeEl, clientEl, 'read', 400);
            }
            
            log(`READ â† ${targetNode.name} complete`, 'success');
            updateStats('read', 15);
            
            // Hide read flow panel after delay
            setTimeout(() => {
                document.getElementById('read-flow-panel').classList.remove('visible');
            }, animDelay(2000));
        }
        
        function showReadFlowPanel(readPref, targetNode, allNodes) {
            const panel = document.getElementById('read-flow-panel');
            const prefEl = document.getElementById('flow-read-pref');
            const nodesEl = document.getElementById('read-flow-nodes');
            const selectionEl = document.getElementById('read-flow-selection');
            const resultEl = document.getElementById('read-flow-result');
            
            if (prefEl) prefEl.textContent = readPref;
            if (resultEl) resultEl.style.display = 'none';
            
            // Show available nodes
            if (nodesEl) {
                nodesEl.innerHTML = allNodes.map(n => {
                    const isTarget = n.id === targetNode.id;
                    const roleIcon = n.role === 'primary' ? 'ðŸ‘‘' : 'ðŸ“š';
                    const statusClass = isTarget ? 'target' : 'eligible';
                    return `<span class="read-node-badge ${statusClass}">${roleIcon} ${n.name}${isTarget ? ' â† TARGET' : ''}</span>`;
                }).join('');
            }
            
            // Show selection details
            if (selectionEl) {
                const region = getRegionInfo(targetNode.region);
                selectionEl.innerHTML = `
                    <div class="selection-detail">
                        <span class="selection-label">Reading from:</span>
                        <span class="selection-value">${targetNode.name}</span>
                    </div>
                    <div class="selection-detail">
                        <span class="selection-label">Role:</span>
                        <span class="selection-value ${targetNode.role}">${targetNode.role.toUpperCase()}</span>
                    </div>
                    <div class="selection-detail">
                        <span class="selection-label">Region:</span>
                        <span class="selection-value">${region?.icon || ''} ${region?.name || 'Unknown'}</span>
                    </div>
                `;
            }
            
            panel.classList.add('visible');
        }

        // ============ SHARDED OPERATIONS ============
        async function simulateShardedRead() {
            const readPref = state.readPreference;
            
            // Select target shard based on user selection or random
            let targetShard;
            if (state.targetShard === 'auto') {
                targetShard = state.shards[Math.floor(Math.random() * state.shards.length)];
            } else {
                targetShard = state.shards.find(s => s.id === state.targetShard);
                if (!targetShard) {
                    log(`READ FAILED: Shard ${state.targetShard} not found`, 'error');
                    return;
                }
            }
            
            // Select mongos based on request region
            let activeMongos;
            if (state.requestRegion === 'auto') {
                activeMongos = state.mongos.find(m => state.regionStatus[m.region] === 'healthy');
            } else {
                activeMongos = state.mongos.find(m => m.region === state.requestRegion && state.regionStatus[m.region] === 'healthy');
                if (!activeMongos) {
                    log(`READ FAILED: No mongos in ${state.regions.find(r => r.id === state.requestRegion)?.name || state.requestRegion}`, 'error');
                    return;
                }
            }
            
            if (!activeMongos) {
                log('READ FAILED: No mongos available', 'error');
                return;
            }

            const healthyNodes = targetShard.nodes.filter(n => n.status === 'healthy');
            
            if (healthyNodes.length === 0) {
                log(`READ FAILED: No healthy nodes on ${targetShard.name}`, 'error');
                return;
            }

            let targetNode = null;
            const primary = healthyNodes.find(n => n.role === 'primary');
            const secondaries = healthyNodes.filter(n => n.role === 'secondary');

            switch (readPref) {
                case 'primary':
                    targetNode = primary;
                    if (!targetNode) {
                        log(`READ FAILED: No primary (readPreference: primary)`, 'error');
                        return;
                    }
                    break;
                case 'primaryPreferred':
                    targetNode = primary || secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondary':
                    if (secondaries.length === 0) {
                        log(`READ FAILED: No secondaries (readPreference: secondary)`, 'error');
                        return;
                    }
                    targetNode = secondaries[Math.floor(Math.random() * secondaries.length)];
                    break;
                case 'secondaryPreferred':
                    targetNode = secondaries.length > 0 ? 
                        secondaries[Math.floor(Math.random() * secondaries.length)] : primary;
                    break;
                case 'nearest':
                    const sameRegionNodes = healthyNodes.filter(n => n.region === activeMongos.region);
                    targetNode = sameRegionNodes.length > 0 ?
                        sameRegionNodes[Math.floor(Math.random() * sameRegionNodes.length)] :
                        healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
                    break;
                default:
                    targetNode = healthyNodes[Math.floor(Math.random() * healthyNodes.length)];
            }

            const nodeRegion = getRegionInfo(targetNode.region);
            const mongosRegion = getRegionInfo(activeMongos.region);
            const isCrossRegion = activeMongos.region !== targetNode.region;
            
            // Log with cross-region indicator
            const routeInfo = isCrossRegion 
                ? `ðŸŒ CROSS-REGION: ${mongosRegion?.name} â†’ ${nodeRegion?.name}` 
                : `âœ“ LOCAL: ${mongosRegion?.name}`;
            log(`READ (${readPref}) â†’ ${targetShard.name}/${targetNode.name}`, 'info');
            log(`   ${routeInfo}`, isCrossRegion ? 'warning' : 'info');
            
            // Show read flow panel
            showReadFlowPanel(readPref, targetNode, healthyNodes);
            
            const mongosEl = document.getElementById(`mongos-${activeMongos.id}`);
            const nodeEl = document.getElementById(`node-${targetNode.id}`);
            
            if (mongosEl && nodeEl) {
                await animateParticle(mongosEl, nodeEl, 'read', 350);
            }
            
            if (nodeEl) {
                nodeEl.classList.add('reading');
                setTimeout(() => nodeEl.classList.remove('reading'), animDelay(1000));
            }
            
            await sleep(200);
            
            if (nodeEl && mongosEl) {
                await animateParticle(nodeEl, mongosEl, 'read', 400);
            }
            
            const readLatency = isCrossRegion ? getLatency(activeMongos.region, targetNode.region) + 10 : 10;
            log(`READ â† ${targetShard.name}/${targetNode.name} complete [${readLatency}ms]`, 'success');
            updateStats('read', readLatency);
            
            // Hide read flow panel after delay
            setTimeout(() => {
                document.getElementById('read-flow-panel').classList.remove('visible');
            }, animDelay(2000));
        }

        function resetCluster() {
            loadConfig(state.currentConfig);
        }

        // ============ RENDERING (REPLICA SET) ============
        function renderReplicaSet() {
            const container = document.getElementById('rs-container');
            if (!container) return;
            
            // Group nodes by region
            const regionGroups = {};
            state.nodes.forEach(n => {
                if (!regionGroups[n.region]) regionGroups[n.region] = [];
                regionGroups[n.region].push(n);
            });
            
            container.innerHTML = Object.entries(regionGroups).map(([regionId, nodes]) => {
                const region = getRegionInfo(regionId);
                const isDown = state.regionStatus[regionId] === 'down';
                const regionClass = regionId.replace('region-', 'region-');
                return `
                    <div class="rs-region-group ${regionClass} ${isDown ? 'down' : ''}">
                        <div class="rs-region-header">
                            <span class="rs-region-icon">${region.icon}</span>
                            <span class="rs-region-name">${region.name}</span>
                            <span class="rs-region-latency">${region.latency || '~1ms'}</span>
                        </div>
                        <div class="rs-nodes">
                            ${nodes.map(n => renderRSNodeCard(n)).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderRSNodeCard(node) {
            const isReadReplica = node.isReadReplica || (node.votes === 0 && node.priority === 0);
            const roleClass = node.status === 'down' ? 'down' : 
                             node.status === 'recovering' ? 'recovering' :
                             node.status === 'syncing' ? 'syncing' :
                             isReadReplica ? 'read-replica' :
                             node.priority === 0 ? 'priority-zero' : node.role;
            const roleLabel = node.status === 'down' ? 'DOWN' : 
                             node.status === 'recovering' ? 'SYNC' :
                             node.status === 'syncing' ? 'ðŸ”„' :
                             isReadReplica ? 'R/O' :
                             node.priority === 0 ? 'P:0' : node.role.toUpperCase();
            const icon = node.role === 'primary' ? 'ðŸ‘‘' : 
                        isReadReplica ? 'ðŸ“–' : 
                        node.priority === 0 ? 'ðŸ›¡ï¸' : 'ðŸ“š';
            
            const priorityColor = isReadReplica ? '#ff6b6b' :
                                 node.priority === 0 ? 'rgba(255,255,255,0.3)' : 
                                 node.priority >= 3 ? 'var(--mongo-green)' :
                                 node.priority >= 2 ? '#00b4d8' : 'rgba(255,255,255,0.5)';
            
            const votesBadge = node.votes === 0 ? '<span style="color: #ff6b6b; margin-left: 4px; font-size: 0.65rem;">v:0</span>' : '';

            return `
                <div class="node-card ${roleClass}" id="node-${node.id}" onclick="toggleRSNode('${node.id}')">
                    <div class="node-header">
                        <span class="node-icon">${icon}</span>
                        <span class="node-name">${node.name}</span>
                        <span class="node-role-badge">${roleLabel}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.7rem;">
                        <span class="node-oplog">oplog: ${node.oplogCount}</span>
                        <span style="color: ${priorityColor}; font-weight: 600;">p:${node.priority}${votesBadge}</span>
                    </div>
                </div>
            `;
        }

        // ============ NODE CONTROL (REPLICA SET) ============
        function toggleRSNode(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            if (node.status === 'down') {
                node.status = 'recovering';
                log(`${node.name} recovering...`, 'warning');
                renderReplicaSet();
                
                setTimeout(() => {
                    node.status = 'syncing';
                    log(`${node.name} syncing oplog...`, 'info');
                    renderReplicaSet();
                    
                    const syncTime = 3000 + Math.random() * 2000;
                    setTimeout(() => {
                        node.status = 'healthy';
                        log(`${node.name} is healthy (priority ${node.priority})`, 'success');
                        renderReplicaSet();
                        updateClusterStatus();
                        
                        if (!state.nodes.some(n => n.role === 'primary' && n.status === 'healthy') && hasMajority(state.nodes)) {
                            triggerRSElection();
                        }
                    }, syncTime);
                }, 1500);
            } else {
                const wasPrimary = node.role === 'primary';
                node.status = 'down';
                node.role = 'secondary';
                node.oplog = [];
                log(`${node.name} is DOWN`, 'error');
                renderReplicaSet();
                updateClusterStatus();
                
                // Check if current primary lost majority
                const currentPrimary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                if (currentPrimary && !hasMajority(state.nodes)) {
                    log(`${currentPrimary.name} stepping down: lost majority`, 'warning');
                    currentPrimary.role = 'secondary';
                    renderReplicaSet();
                    updateClusterStatus();
                }
                
                // Only trigger election if we have majority AND lost the primary
                if (wasPrimary) {
                    if (hasMajority(state.nodes)) {
                        triggerRSElection();
                    } else {
                        const healthyVoters = getHealthyVoters(state.nodes);
                        const majorityRequired = getMajorityRequired(state.nodes);
                        log(`âš ï¸ NO MAJORITY: ${healthyVoters.length} voters < ${majorityRequired} required. Cluster is READ-ONLY!`, 'error');
                    }
                }
            }
        }

        function triggerRSElection() {
            if (state.isElecting['rs']) return;
            state.isElecting['rs'] = true;
            
            const majorityRequired = getMajorityRequired(state.nodes);
            const healthyNodes = getHealthyNodes(state.nodes);
            const eligibleCandidates = healthyNodes.filter(n => n.priority > 0);
            
            const modal = document.getElementById('election-modal');
            const progressBar = document.getElementById('election-progress');
            const electionStatus = document.getElementById('election-status');
            const electionText = document.getElementById('election-text');
            const modalTitle = modal.querySelector('.modal-title');
            const modalIcon = modal.querySelector('.modal-icon');
            
            modal.classList.add('visible');
            
            const healthyVoters = getHealthyVoters(state.nodes);
            if (healthyVoters.length < majorityRequired) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                const hasNonVoting = state.nodes.some(n => n.votes === 0);
                const nonVotingNote = hasNonVoting ? '<br><span style="font-size: 0.75rem; color: #ff6b6b;">Read-only nodes (v:0) cannot vote!</span>' : '';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">rs0: No majority!</strong><br><br>
                    Healthy voters: <strong>${healthyVoters.length}</strong><br>
                    Majority required: <strong>${majorityRequired}</strong>${nonVotingNote}<br><br>
                    <span style="font-size: 0.8rem;">âš ï¸ Replica set is READ-ONLY</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = 'var(--node-down)';
                electionStatus.textContent = 'rs0: Writes blocked';
                
                log(`rs0 election FAILED: no majority (${healthyVoters.length} voters / ${majorityRequired} needed)`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting['rs'] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 4000);
                return;
            }
            
            if (eligibleCandidates.length === 0) {
                modalIcon.textContent = 'âš ï¸';
                modalTitle.textContent = 'Election Failed';
                electionText.innerHTML = `
                    <strong style="color: var(--node-down);">rs0: No eligible candidates!</strong><br><br>
                    Only Priority 0 nodes available<br><br>
                    <span style="font-size: 0.8rem;">â³ Priority 0 nodes cannot become primary</span>
                `;
                progressBar.style.width = '100%';
                progressBar.style.background = '#00b4d8';
                electionStatus.textContent = 'P:0 nodes are DR-only';
                
                log(`rs0 election FAILED: only P:0 nodes available`, 'error');
                
                setTimeout(() => {
                    modal.classList.remove('visible');
                    state.isElecting['rs'] = false;
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'var(--mongo-green)';
                    modalIcon.textContent = 'ðŸ—³ï¸';
                    modalTitle.textContent = 'Election in Progress';
                }, 3000);
                return;
            }
            
            const sortedCandidates = eligibleCandidates.sort((a, b) => b.priority - a.priority);
            const newPrimary = sortedCandidates[0];
            
            electionText.textContent = `rs0: Initiating failover...`;
            
            const steps = [
                { progress: 20, text: 'Detecting primary failure...' },
                { progress: 40, text: `Checking quorum: ${healthyNodes.length}/${majorityRequired} âœ“` },
                { progress: 60, text: `Highest priority: ${newPrimary.name} (p:${newPrimary.priority})` },
                { progress: 85, text: 'Votes collected, majority achieved!' },
                { progress: 100, text: `${newPrimary.name} elected PRIMARY!` }
            ];

            let stepIndex = 0;
            const stepInterval = setInterval(() => {
                if (stepIndex < steps.length) {
                    progressBar.style.width = `${steps[stepIndex].progress}%`;
                    electionStatus.textContent = steps[stepIndex].text;
                    stepIndex++;
                } else {
                    clearInterval(stepInterval);
                    
                    newPrimary.role = 'primary';
                    const region = getRegionInfo(newPrimary.region);
                    log(`rs0: ${newPrimary.name} elected PRIMARY (${region.name}, p:${newPrimary.priority})`, 'success');
                    updateStats('election');
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        state.isElecting['rs'] = false;
                        progressBar.style.width = '0%';
                        modalIcon.textContent = 'ðŸ—³ï¸';
                        modalTitle.textContent = 'Election in Progress';
                        renderReplicaSet();
                        updateClusterStatus();
                        updateConnectionString();
                    }, 1500);
                }
            }, 500);
        }

        function killRSPrimary() {
            const primary = state.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
            if (!primary) {
                log('No healthy primary to kill', 'warning');
                return;
            }
            log(`Killing rs0 primary: ${primary.name}`, 'warning');
            toggleRSNode(primary.id);
        }

        // ============ RENDERING (SHARDED) ============
        function renderCluster() {
            renderMongos();
            renderConfigServers();
            renderShards();
        }
        
        function renderMongos() {
            const container = document.getElementById('mongos-container');
            if (!container) return;
            
            container.innerHTML = state.mongos.map(m => {
                const region = getRegionInfo(m.region);
                const isDown = state.regionStatus[m.region] === 'down';
                return `
                    <div class="mongos-node ${isDown ? 'down' : ''}" id="mongos-${m.id}">
                        <span class="mongos-icon">ðŸ”€</span>
                        <div class="mongos-info">
                            <div>${m.id}</div>
                            <div class="mongos-region">${region.icon} ${region.name}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderConfigServers() {
            const container = document.getElementById('config-container');
            if (!container) return;
            
            container.innerHTML = state.configServers.map(c => {
                const region = getRegionInfo(c.region);
                const isDown = c.status === 'down';
                const isPrimary = c.role === 'primary' && c.status === 'healthy';
                return `
                    <div class="config-node ${isDown ? 'down' : ''} ${isPrimary ? 'primary' : ''}">
                        <span class="config-icon">âš™ï¸</span>
                        <div class="config-info">
                            <div>${c.name}</div>
                            <div class="config-region">${region.icon} ${region.name}</div>
                        </div>
                        <span class="config-role">${isDown ? 'DOWN' : (isPrimary ? 'PRIMARY' : 'SEC')}</span>
                    </div>
                `;
            }).join('');
        }
        
        function renderShards() {
            const container = document.getElementById('shards-container');
            if (!container) return;
            
            container.innerHTML = state.shards.map(shard => {
                const healthyCount = getHealthyNodes(shard).length;
                const primary = shard.nodes.find(n => n.role === 'primary' && n.status === 'healthy');
                const statusClass = healthyCount === shard.nodes.length && primary ? 'healthy' : 
                                   primary && hasMajority(shard) ? 'degraded' : 'critical';
                const statusText = healthyCount === shard.nodes.length && primary ? 'âœ“ Healthy' :
                                  primary ? `${healthyCount}/${shard.nodes.length}` : 'âš ï¸ No Primary';

                // Group nodes by region
                const regionGroups = {};
                shard.nodes.forEach(n => {
                    if (!regionGroups[n.region]) regionGroups[n.region] = [];
                    regionGroups[n.region].push(n);
                });

                return `
                    <div class="shard-panel">
                        <div class="shard-header">
                            <div class="shard-icon">ðŸ“¦</div>
                            <div class="shard-title">${shard.name}</div>
                            <span class="shard-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="shard-body">
                            ${Object.entries(regionGroups).map(([regionId, nodes]) => {
                                const region = getRegionInfo(regionId);
                                const isDown = state.regionStatus[regionId] === 'down';
                                return `
                                    <div class="region-row ${regionId.replace('region-', 'region-')} ${isDown ? 'down' : ''}">
                                        <div class="region-label">
                                            <div class="region-name">${region.icon} ${region.name}</div>
                                            <div class="region-latency">${region.latency || '~1ms'}</div>
                                        </div>
                                        <div class="region-nodes">
                                            ${nodes.map(n => renderShardNodeCard(n, shard.id)).join('')}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderShardNodeCard(node, shardId) {
            const roleClass = node.status === 'down' ? 'down' : 
                             node.status === 'recovering' ? 'recovering' :
                             node.status === 'syncing' ? 'syncing' :
                             node.priority === 0 ? 'priority-zero' : node.role;
            const roleLabel = node.status === 'down' ? 'DOWN' : 
                             node.status === 'recovering' ? 'SYNC' :
                             node.status === 'syncing' ? 'ðŸ”„' :
                             node.priority === 0 ? 'P:0' : node.role.toUpperCase();
            const icon = node.role === 'primary' ? 'ðŸ‘‘' : node.priority === 0 ? 'ðŸ›¡ï¸' : 'ðŸ“š';
            
            const priorityColor = node.priority === 0 ? 'rgba(255,255,255,0.3)' : 
                                 node.priority >= 3 ? 'var(--mongo-green)' :
                                 node.priority >= 2 ? '#00b4d8' : 'rgba(255,255,255,0.5)';

            return `
                <div class="node-card ${roleClass}" id="node-${node.id}" onclick="toggleNode('${shardId}', '${node.id}')">
                    <div class="node-header">
                        <span class="node-icon">${icon}</span>
                        <span class="node-name">${node.name.split('-').slice(-2).join('-')}</span>
                        <span class="node-role-badge">${roleLabel}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.7rem;">
                        <span class="node-oplog">oplog: ${node.oplogCount}</span>
                        <span style="color: ${priorityColor}; font-weight: 600;">p:${node.priority}</span>
                    </div>
                </div>
            `;
        }

        function updateClusterStatus() {
            const clusterStatus = document.getElementById('cluster-status');
            const statusText = document.getElementById('status-text');
            clusterStatus.classList.remove('healthy', 'degraded', 'critical');

            if (state.isSharded) {
                const allHealthy = state.shards.every(s => getHealthyNodes(s).length === s.nodes.length && s.nodes.some(n => n.role === 'primary' && n.status === 'healthy'));
                const anyPrimary = state.shards.every(s => s.nodes.some(n => n.role === 'primary' && n.status === 'healthy'));
                const anyMajority = state.shards.every(s => hasMajority(s));
                
                if (allHealthy) {
                    clusterStatus.classList.add('healthy');
                    statusText.textContent = 'Healthy';
                } else if (anyPrimary && anyMajority) {
                    clusterStatus.classList.add('degraded');
                    statusText.textContent = 'Degraded';
                } else {
                    clusterStatus.classList.add('critical');
                    statusText.textContent = anyMajority ? 'No Primary' : 'No Majority';
                }
            } else {
                const healthyCount = getHealthyNodes(state.nodes).length;
                const hasPrimary = state.nodes.some(n => n.role === 'primary' && n.status === 'healthy');
                const hasMaj = hasMajority(state.nodes);
                
                if (healthyCount === state.nodes.length && hasPrimary) {
                    clusterStatus.classList.add('healthy');
                    statusText.textContent = 'Healthy';
                } else if (hasPrimary && hasMaj) {
                    clusterStatus.classList.add('degraded');
                    statusText.textContent = 'Degraded';
                } else {
                    clusterStatus.classList.add('critical');
                    statusText.textContent = hasMaj ? 'No Primary' : 'No Majority';
                }
            }
        }

        function log(message, type = 'info') {
            const eventLog = document.getElementById('event-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            entry.innerHTML = `<div class="log-time">${time}</div><div class="log-msg">${message}</div>`;
            eventLog.insertBefore(entry, eventLog.firstChild);
            while (eventLog.children.length > 15) eventLog.removeChild(eventLog.lastChild);
        }

        // ============ EVENT HANDLERS ============
        function setupTopologyToggle() {
            document.querySelectorAll('.topology-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    
                    // Update toggle buttons
                    document.querySelectorAll('.topology-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    
                    // Show/hide cluster options based on type
                    document.querySelectorAll('.cluster-option').forEach(opt => {
                        if (opt.dataset.type === type) {
                            opt.style.display = '';
                        } else {
                            opt.style.display = 'none';
                        }
                    });
                    
                    // Select first visible option
                    const firstVisible = document.querySelector(`.cluster-option[data-type="${type}"]`);
                    if (firstVisible) {
                        document.querySelectorAll('.cluster-option').forEach(o => o.classList.remove('selected'));
                        firstVisible.classList.add('selected');
                        loadConfig(firstVisible.dataset.config);
                    }
                });
            });
        }

        function setupClusterSelector() {
            document.querySelectorAll('.cluster-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    // Only select visible options of the same type
                    const type = opt.dataset.type;
                    document.querySelectorAll(`.cluster-option[data-type="${type}"]`).forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    loadConfig(opt.dataset.config);
                });
            });
        }

        function setupWriteConcernHandlers() {
            document.querySelectorAll('.wc-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    document.querySelectorAll('.wc-pill').forEach(p => p.classList.remove('selected'));
                    pill.classList.add('selected');
                    state.writeConcern = pill.dataset.value;
                    log(`Write concern: w:${state.writeConcern}`, 'info');
                });
            });
        }

        function setupReadPreferenceHandler() {
            const select = document.getElementById('read-preference');
            select.addEventListener('change', () => {
                state.readPreference = select.value;
                log(`Read preference: ${state.readPreference}`, 'info');
            });
        }

        function populateShardedDropdowns() {
            // Populate Target Shard dropdown
            const shardSelect = document.getElementById('target-shard');
            shardSelect.innerHTML = '<option value="auto" selected>Auto (random)</option>';
            state.shards.forEach(shard => {
                const opt = document.createElement('option');
                opt.value = shard.id;
                opt.textContent = shard.name;
                shardSelect.appendChild(opt);
            });
            
            // Populate Request Region dropdown
            const regionSelect = document.getElementById('request-region');
            regionSelect.innerHTML = '<option value="auto" selected>Auto (any available)</option>';
            state.regions.forEach(region => {
                const opt = document.createElement('option');
                opt.value = region.id;
                opt.textContent = `${region.icon} ${region.name}`;
                regionSelect.appendChild(opt);
            });
            
            // Reset selections
            state.targetShard = 'auto';
            state.requestRegion = 'auto';
            shardSelect.value = 'auto';
            regionSelect.value = 'auto';
        }

        function setupShardedDropdownHandlers() {
            const shardSelect = document.getElementById('target-shard');
            shardSelect.addEventListener('change', () => {
                state.targetShard = shardSelect.value;
                const label = state.targetShard === 'auto' ? 'Auto (random)' : state.shards.find(s => s.id === state.targetShard)?.name;
                log(`Target shard: ${label}`, 'info');
            });
            
            const regionSelect = document.getElementById('request-region');
            regionSelect.addEventListener('change', () => {
                state.requestRegion = regionSelect.value;
                const region = state.regions.find(r => r.id === state.requestRegion);
                const label = state.requestRegion === 'auto' ? 'Auto (any available)' : `${region?.icon} ${region?.name}`;
                log(`Request region: ${label}`, 'info');
            });
        }

        // ============ STATISTICS ============
        function updateStats(type, latency = 0) {
            if (type === 'write') state.stats.writes++;
            else if (type === 'read') state.stats.reads++;
            else if (type === 'failed') state.stats.failed++;
            else if (type === 'election') state.stats.elections++;
            
            if (latency > 0) {
                state.stats.latencies.push(latency);
                if (state.stats.latencies.length > 50) state.stats.latencies.shift();
                state.stats.avgLatency = Math.round(
                    state.stats.latencies.reduce((a, b) => a + b, 0) / state.stats.latencies.length
                );
            }
            
            renderStats();
        }

        function renderStats() {
            document.getElementById('stat-writes').textContent = state.stats.writes;
            document.getElementById('stat-reads').textContent = state.stats.reads;
            const failedEl = document.getElementById('stat-failed');
            failedEl.textContent = state.stats.failed;
            failedEl.className = state.stats.failed > 0 ? 'stat-value error' : 'stat-value';
            document.getElementById('stat-elections').textContent = state.stats.elections;
            document.getElementById('stat-avg-latency').innerHTML = 
                `${state.stats.avgLatency}<span style="font-size: 0.8rem;">ms</span>`;
        }

        function resetStats() {
            state.stats = { writes: 0, reads: 0, failed: 0, elections: 0, latencies: [], avgLatency: 0 };
            renderStats();
        }

        // ============ LATENCY SIMULATION ============
        function getLatency(fromRegion, toRegion) {
            const from = fromRegion || 'region-1';
            const to = toRegion || 'region-1';
            return LATENCY_MAP[from]?.[to] || LATENCY_MAP['region-1']['region-1'] || 1;
        }

        async function simulateLatency(fromRegion, toRegion) {
            const latency = getLatency(fromRegion, toRegion);
            await sleep(latency);
            return latency;
        }

        // ============ CONNECTION STRING ============
        function updateConnectionString() {
            const connEl = document.getElementById('conn-string');
            if (!connEl) return;
            
            let connString = '';
            const wc = state.writeConcern;
            const rp = state.readPreference;
            
            // Use mongodb+srv:// format (DNS SRV connection string)
            const clusterName = state.isSharded ? 'sharded-cluster' : 'rs0';
            const config = CLUSTER_CONFIGS[state.currentConfig];
            const regionCount = config?.regions?.length || 1;
            const regionSuffix = regionCount === 1 ? 'single' : regionCount === 2 ? 'multi' : 'global';
            
            connString = `mongodb+srv://<username>:<password>@${clusterName}-${regionSuffix}.mongodb.net/?retryWrites=true&w=${wc}&readPreference=${rp}`;
            
            connEl.textContent = connString;
        }

        function copyConnectionString() {
            const connEl = document.getElementById('conn-string');
            const text = connEl.textContent;
            navigator.clipboard.writeText(text).then(() => {
                connEl.classList.add('copied');
                setTimeout(() => connEl.classList.remove('copied'), 2000);
                log('Connection string copied to clipboard!', 'success');
            }).catch(() => {
                log('Failed to copy to clipboard', 'error');
            });
        }

        // ============ KEYBOARD SHORTCUTS ============
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                
                const key = e.key.toLowerCase();
                switch (key) {
                    case 'i': simulateInsert(); break;
                    case 'u': simulateUpdate(); break;
                    case 'r': simulateRead(); break;
                    case 'k': killRandomPrimary(); break;
                    case 'x': resetCluster(); break;
                    case 'd': toggleAutoDemo(); break;
                    case 't': toggleTopology(); break;
                    case 's': toggleAnimSpeed(); break;
                    case '1': selectConfig(0); break;
                    case '2': selectConfig(1); break;
                    case '3': selectConfig(2); break;
                }
            });
        }

        function toggleTopology() {
            const btns = document.querySelectorAll('.topology-btn');
            const currentIsRS = document.querySelector('.topology-btn.selected').dataset.type === 'replica-set';
            const newType = currentIsRS ? 'sharded' : 'replica-set';
            btns.forEach(b => b.classList.toggle('selected', b.dataset.type === newType));
            
            // Update visible options
            document.querySelectorAll('.cluster-option').forEach(opt => {
                const isMatch = opt.dataset.type === newType;
                opt.style.display = isMatch ? '' : 'none';
            });
            
            // Select first option of new type
            const firstOption = document.querySelector(`.cluster-option[data-type="${newType}"]`);
            if (firstOption) {
                document.querySelectorAll('.cluster-option').forEach(o => o.classList.remove('selected'));
                firstOption.classList.add('selected');
                loadConfig(firstOption.dataset.config);
            }
        }

        function selectConfig(index) {
            const currentType = document.querySelector('.topology-btn.selected').dataset.type;
            const options = Array.from(document.querySelectorAll(`.cluster-option[data-type="${currentType}"]`));
            if (options[index]) {
                document.querySelectorAll('.cluster-option').forEach(o => o.classList.remove('selected'));
                options[index].classList.add('selected');
                loadConfig(options[index].dataset.config);
            }
        }

        // ============ AUTO DEMO ============
        const DEMO_STEPS = [
            { narration: 'ðŸ‘‹ Welcome to the MongoDB High Availability Demo!', action: null, duration: 2500 },
            { narration: 'ðŸ“ First, let\'s perform a write operation...', action: () => simulateInsert(), duration: 2000 },
            { narration: 'ðŸ“– Now let\'s read from the cluster...', action: () => simulateRead(), duration: 2000 },
            { narration: 'ðŸ’¥ Simulating a PRIMARY node failure...', action: () => killRandomPrimary(), duration: 3500 },
            { narration: 'ðŸ—³ï¸ MongoDB is electing a new primary...', action: null, duration: 2500 },
            { narration: 'âœ… Cluster recovered! Let\'s try another write...', action: () => simulateInsert(), duration: 2500 },
            { narration: 'ðŸ“Š Notice how the statistics track all operations!', action: null, duration: 2500 },
            { narration: 'ðŸ”„ Resetting the cluster for more experiments...', action: () => resetCluster(), duration: 2000 },
            { narration: 'ðŸŽ‰ Demo complete! Try the keyboard shortcuts (I, U, R, K) to explore more.', action: null, duration: 3000 }
        ];

        function toggleAutoDemo() {
            if (state.demoRunning) {
                stopAutoDemo();
            } else {
                startAutoDemo();
            }
        }

        async function startAutoDemo() {
            state.demoRunning = true;
            state.demoStep = 0;
            
            const btn = document.getElementById('auto-demo-btn');
            const btnText = document.getElementById('demo-btn-text');
            btn.classList.add('running');
            btnText.textContent = 'Stop Demo';
            btn.querySelector('.demo-icon').textContent = 'â¹ï¸';
            
            const narration = document.getElementById('demo-narration');
            narration.classList.add('visible');
            
            resetStats();
            
            for (let i = 0; i < DEMO_STEPS.length && state.demoRunning; i++) {
                state.demoStep = i;
                const step = DEMO_STEPS[i];
                
                document.getElementById('narration-text').textContent = step.narration;
                document.getElementById('narration-step').textContent = `Step ${i + 1} of ${DEMO_STEPS.length}`;
                
                if (step.action) {
                    await sleep(500);
                    await step.action();
                }
                
                await sleep(step.duration);
            }
            
            stopAutoDemo();
        }

        function stopAutoDemo() {
            state.demoRunning = false;
            state.demoStep = 0;
            
            const btn = document.getElementById('auto-demo-btn');
            const btnText = document.getElementById('demo-btn-text');
            btn.classList.remove('running');
            btnText.textContent = 'Auto Demo';
            btn.querySelector('.demo-icon').textContent = 'â–¶ï¸';
            
            document.getElementById('demo-narration').classList.remove('visible');
        }

        // ============ INIT ============
        function init() {
            setupTopologyToggle();
            setupClusterSelector();
            setupWriteConcernHandlers();
            setupReadPreferenceHandler();
            setupShardedDropdownHandlers();
            setupKeyboardShortcuts();
            loadConfig('rs-single-region');
            renderStats();
            updateConnectionString();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- Keyboard Shortcuts Help -->
    <div class="shortcuts-help" id="shortcuts-help">
        <div class="shortcuts-title">âŒ¨ï¸ Keyboard Shortcuts</div>
        <div class="shortcut-row"><span>Insert</span><span class="shortcut-key">I</span></div>
        <div class="shortcut-row"><span>Update</span><span class="shortcut-key">U</span></div>
        <div class="shortcut-row"><span>Read</span><span class="shortcut-key">R</span></div>
        <div class="shortcut-row"><span>Kill Primary</span><span class="shortcut-key">K</span></div>
        <div class="shortcut-row"><span>Reset</span><span class="shortcut-key">X</span></div>
        <div class="shortcut-row"><span>Auto Demo</span><span class="shortcut-key">D</span></div>
        <div class="shortcut-row"><span>Toggle RS/Shard</span><span class="shortcut-key">T</span></div>
        <div class="shortcut-row"><span>Speed: Slow/Fast</span><span class="shortcut-key">S</span></div>
    </div>

    <!-- Demo Narration Overlay -->
    <div class="demo-narration" id="demo-narration">
        <div class="demo-narration-text" id="narration-text">Welcome to the MongoDB HA Demo!</div>
        <div class="demo-narration-step" id="narration-step">Step 1 of 8</div>
    </div>
</body>
</html>
