<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HNSW Visualizer</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%23001E2B'/><path d='M16 4 L18 14 L16 28 L14 14 Z' fill='%2300ED64'/><ellipse cx='16' cy='14' rx='3' ry='5' fill='%2300ED64'/></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .slider-label {
            @apply text-sm font-medium text-gray-300;
        }
        .slider-value {
            @apply text-sm font-semibold text-indigo-400;
        }
        .control-button {
            @apply w-full px-4 py-2 text-sm font-semibold text-white bg-indigo-600 rounded-lg shadow-md hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-500 transition-all duration-150 disabled:bg-gray-600 disabled:cursor-not-allowed;
        }
        canvas {
            cursor: crosshair;
            touch-action: none;
        }
        .info-box {
            @apply bg-gray-800 bg-opacity-80 backdrop-blur-sm p-4 rounded-lg shadow-lg border border-gray-700;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 antialiased">

    <div class="flex flex-col lg:flex-row min-h-screen">
        <!-- Controls Panel -->
        <div class="w-full lg:w-80 xl:w-96 p-4 lg:p-6 bg-gray-800 border-r border-gray-700 flex-shrink-0">
            <div class="space-y-6">
                <div>
                    <h1 class="text-2xl font-bold text-gray-100">HNSW Visualizer</h1>
                    <p class="mt-1 text-sm text-gray-400">An interactive guide to Hierarchical Navigable Small World graphs for Approximate Nearest Neighbor Search.</p>
                </div>

                <!-- Parameters -->
                <div class="space-y-5 pt-4 border-t border-gray-700">
                    <h2 class="text-lg font-semibold text-gray-200">Parameters</h2>
                    <div>
                        <div class="flex justify-between items-center">
                            <label for="m-slider" class="slider-label">M (Max Connections)</label>
                            <span id="m-value" class="slider-value">16</span>
                        </div>
                        <input id="m-slider" type="range" min="4" max="32" value="16" step="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <p class="text-xs text-gray-500 mt-1">Impacts graph density. Higher values create more connections, improving potential accuracy but increasing memory usage.</p>
                    </div>
                    <div>
                        <div class="flex justify-between items-center">
                            <label for="ef-construction-slider" class="slider-label">efConstruction</label>
                            <span id="ef-construction-value" class="slider-value">40</span>
                        </div>
                        <input id="ef-construction-slider" type="range" min="10" max="200" value="40" step="5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <p class="text-xs text-gray-500 mt-1">Controls graph quality at build time. Higher values lead to a more accurate graph but make indexing slower.</p>
                    </div>
                    <div>
                        <div class="flex justify-between items-center">
                            <label for="ef-slider" class="slider-label">ef (Search Exploration)</label>
                            <span id="ef-value" class="slider-value">20</span>
                        </div>
                        <input id="ef-slider" type="range" min="1" max="100" value="20" step="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        <p class="text-xs text-gray-500 mt-1">Controls the trade-off between search speed and accuracy. A higher value is more thorough and accurate, but slower.</p>
                    </div>
                </div>

                <!-- Actions -->
                <div class="space-y-3 pt-4 border-t border-gray-700">
                     <h2 class="text-lg font-semibold text-gray-200">Actions</h2>
                    <button id="randomize-btn" class="control-button">1. Generate New Points</button>
                    <button id="build-btn" class="control-button">2. Build HNSW Graph</button>
                    <p class="text-center text-xs text-gray-500">Click on the canvas to set a query point</p>
                    <button id="search-btn" class="control-button" disabled>3. Start Step-by-Step Search</button>
                    <button id="continue-btn" class="control-button hidden mt-2">Continue to Next Layer</button>
                </div>
            </div>
        </div>

        <!-- Canvas and Info -->
        <div class="flex-grow p-4 lg:p-6 flex flex-col">
            <div class="relative w-full flex-grow rounded-xl shadow-lg border border-gray-700 overflow-hidden">
                <canvas id="hnsw-canvas"></canvas>
                <div id="info-panel" class="absolute top-4 left-4 space-y-2 text-sm">
                    <div id="status-box" class="info-box">
                        <h3 class="font-bold text-gray-100">Status</h3>
                        <p id="status-text" class="leading-relaxed">Ready. Generate points to begin.</p>
                    </div>
                    <div id="search-info-box" class="info-box hidden">
                         <h3 class="font-bold text-gray-100">Search Progress</h3>
                         <p><strong>Current Layer:</strong> <span id="current-layer-text">-</span></p>
                         <p><strong>Candidates Evaluated:</strong> <span id="candidates-evaluated-text">0</span></p>
                         <p><strong>Best Distance:</strong> <span id="best-dist-text">-</span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('hnsw-canvas');
        const ctx = canvas.getContext('2d');

        // --- DOM Elements ---
        const mSlider = document.getElementById('m-slider');
        const efConstructionSlider = document.getElementById('ef-construction-slider');
        const efSlider = document.getElementById('ef-slider');
        const mValue = document.getElementById('m-value');
        const efConstructionValue = document.getElementById('ef-construction-value');
        const efValue = document.getElementById('ef-value');
        const randomizeBtn = document.getElementById('randomize-btn');
        const buildBtn = document.getElementById('build-btn');
        const searchBtn = document.getElementById('search-btn');
        const continueBtn = document.getElementById('continue-btn');
        const statusText = document.getElementById('status-text');
        const searchInfoBox = document.getElementById('search-info-box');
        const currentLayerText = document.getElementById('current-layer-text');
        const candidatesEvaluatedText = document.getElementById('candidates-evaluated-text');
        const bestDistText = document.getElementById('best-dist-text');

        // --- State ---
        let state = {
            points: [],
            graph: null,
            queryPoint: null,
            isSearching: false,
            searchCompleted: false,
            hnswResult: null,
            trueNearest: null,
            params: {
                M: parseInt(mSlider.value),
                efConstruction: parseInt(efConstructionSlider.value),
                ef: parseInt(efSlider.value),
            },
            numPoints: 200,
            numLayers: 3,
            // State for step-by-step search
            currentSearchLayer: -1,
            currentEntryPoint: null,
            totalEvaluated: 0,
        };

        // --- Utility Functions ---
        const distSq = (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Priority Queue implementation for candidate lists
        class PriorityQueue {
            constructor(comparator = (a, b) => a > b) { this._heap = []; this._comparator = comparator; }
            size() { return this._heap.length; }
            isEmpty() { return this.size() === 0; }
            peek() { return this._heap[0]; }
            push(value) { this._heap.push(value); this._siftUp(); }
            pop() { const poppedValue = this.peek(); const bottom = this.size() - 1; if (bottom > 0) { this._swap(0, bottom); } this._heap.pop(); this._siftDown(); return poppedValue; }
            _parent(i) { return ((i + 1) >>> 1) - 1; }
            _left(i) { return (i << 1) + 1; }
            _right(i) { return (i + 1) << 1; }
            _swap(i, j) { [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]]; }
            _compare(i, j) { return this._comparator(this._heap[i], this._heap[j]); }
            _siftUp() { let node = this.size() - 1; while (node > 0 && this._compare(node, this._parent(node))) { this._swap(node, this._parent(node)); node = this._parent(node); } }
            _siftDown() { let node = 0; while ((this._left(node) < this.size() && this._compare(this._left(node), node)) || (this._right(node) < this.size() && this._compare(this._right(node), node))) { let maxChild = (this._right(node) < this.size() && this._compare(this._right(node), this._left(node))) ? this._right(node) : this._left(node); this._swap(node, maxChild); node = maxChild; } }
        }

        // --- Drawing Functions ---
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            draw();
        }

        function draw() {
            if (!ctx) return;
            const rect = canvas.parentElement.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);

            if (state.graph) {
                drawGraph();
            } else {
                drawPoints();
            }
            
            if (state.searchCompleted) {
                drawFinalResult();
            }

            if (state.queryPoint) {
                drawQueryPoint(state.queryPoint);
            }
        }

        function drawPoints() {
            state.points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(156, 163, 175, 0.6)';
                ctx.fill();
            });
        }
        
        const layerColors = ['#4f46e5', '#10b981', '#f97316']; // Indigo, Green, Orange
        
        function drawGraph() {
            const { nodes, layers } = state.graph;
            const layer0 = layers[0];
            ctx.strokeStyle = 'rgba(107, 114, 128, 0.3)';
            ctx.lineWidth = 1;
            layer0.forEach(nodeIndex => {
                const node = nodes[nodeIndex];
                node.connections[0].forEach(neighborIndex => {
                    const neighbor = nodes[neighborIndex];
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(neighbor.x, neighbor.y);
                    ctx.stroke();
                });
            });
            for (let l = state.numLayers - 1; l >= 0; l--) {
                const layer = layers[l];
                const radius = 3 + l * 2;
                layer.forEach(nodeIndex => {
                    const node = nodes[nodeIndex];
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = layerColors[l];
                    ctx.fill();
                });
            }
        }

        function drawQueryPoint(p) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawSearchState(searchState) {
            const { currentPath, visited, candidates, bestNode } = searchState;
            const { nodes } = state.graph;
            visited.forEach(nodeIndex => {
                const node = nodes[nodeIndex];
                ctx.beginPath();
                ctx.arc(node.x, node.y, 5, 0, 2*Math.PI);
                ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                ctx.fill();
            });
            candidates.forEach(candidateIndex => {
                const node = nodes[candidateIndex];
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, 2*Math.PI);
                ctx.strokeStyle = 'rgba(234, 179, 8, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            ctx.strokeStyle = 'rgba(239, 68, 68, 1)';
            ctx.lineWidth = 2.5;
            if (currentPath.length > 1) {
                const startNode = nodes[currentPath[0]];
                const endNode = nodes[currentPath[1]];
                ctx.beginPath();
                ctx.moveTo(startNode.x, startNode.y);
                ctx.lineTo(endNode.x, endNode.y);
                ctx.stroke();
            }
            if(bestNode !== null) {
                const node = nodes[bestNode];
                ctx.beginPath();
                ctx.arc(node.x, node.y, 9, 0, 2*Math.PI);
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function drawFinalResult() {
            const { hnswResult, trueNearest, queryPoint, graph } = state;
            if (!hnswResult || !trueNearest || !queryPoint || !graph) return;
            const hnswNode = graph.nodes[hnswResult.index];
            const trueNode = graph.nodes[trueNearest.index];
            ctx.beginPath();
            ctx.moveTo(queryPoint.x, queryPoint.y);
            ctx.lineTo(hnswNode.x, hnswNode.y);
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 4;
            ctx.stroke();
            if (hnswResult.index !== trueNearest.index) {
                ctx.beginPath();
                ctx.moveTo(queryPoint.x, queryPoint.y);
                ctx.lineTo(trueNode.x, trueNode.y);
                ctx.strokeStyle = '#9ca3af';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(trueNode.x, trueNode.y, 10, 0, 2 * Math.PI);
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // --- Core HNSW Logic ---
        function generatePoints() {
            state.points = [];
            state.graph = null;
            state.queryPoint = null;
            state.searchCompleted = false;
            searchBtn.disabled = true;
            const rect = canvas.parentElement.getBoundingClientRect();
            const padding = 50;
            for (let i = 0; i < state.numPoints; i++) {
                state.points.push({ x: padding + Math.random() * (rect.width - padding * 2), y: padding + Math.random() * (rect.height - padding * 2), id: i });
            }
            statusText.textContent = "Points generated. Now build the graph.";
            draw();
        }

        function buildGraph() {
            if (state.points.length === 0) { statusText.textContent = "Generate points first!"; return; }
            statusText.textContent = "Building graph...";
            setButtonsDisabled(true, true);
            state.searchCompleted = false;
            setTimeout(() => {
                try {
                    const nodes = state.points.map(p => ({ ...p, connections: Array.from({ length: state.numLayers }, () => new Set()) }));
                    const layers = Array.from({ length: state.numLayers }, () => []);
                    let entryPoint = null;
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        const maxLayer = Math.floor(-Math.log(Math.random()) * (1 / Math.log(state.params.M)));
                        node.maxLayer = Math.min(maxLayer, state.numLayers - 1);
                        for (let l = 0; l <= node.maxLayer; l++) { layers[l].push(i); }
                    }
                    
                    // BUG FIX: Ensure the top layer always has an entry point.
                    if (layers[state.numLayers - 1].length === 0) {
                        const randomNodeIndex = Math.floor(Math.random() * nodes.length);
                        const nodeToPromote = nodes[randomNodeIndex];
                        for (let l = nodeToPromote.maxLayer + 1; l < state.numLayers; l++) {
                            layers[l].push(randomNodeIndex);
                        }
                        nodeToPromote.maxLayer = state.numLayers - 1;
                    }
                    entryPoint = layers[state.numLayers - 1][0];

                    for (let l = state.numLayers - 1; l >= 0; l--) {
                        const layerPointsIndices = layers[l];
                        layerPointsIndices.forEach(nodeIndex => {
                            const node = nodes[nodeIndex];
                            const neighbors = findNearestInLayer(node, nodes, layerPointsIndices, state.params.efConstruction);
                            const selectedNeighbors = neighbors.slice(0, state.params.M);
                            selectedNeighbors.forEach(neighborIndex => {
                                node.connections[l].add(neighborIndex);
                                nodes[neighborIndex].connections[l].add(nodeIndex);
                            });
                        });
                    }
                    layers[0].forEach(nodeIndex => {
                        if (nodes[nodeIndex].connections[0].size === 0) {
                            const neighbors = findNearestInLayer(nodes[nodeIndex], nodes, layers[0], state.params.M);
                            neighbors.forEach(neighborIndex => {
                               nodes[nodeIndex].connections[0].add(neighborIndex);
                               nodes[neighborIndex].connections[0].add(nodeIndex);
                            });
                        }
                    });
                    state.graph = { nodes, layers, entryPoint };
                    statusText.textContent = "Graph built. Click canvas to set query point.";
                } catch (error) {
                    console.error("Error building graph:", error);
                    statusText.textContent = "Error building graph. Check console for details.";
                } finally {
                    setButtonsDisabled(false, !state.queryPoint);
                }
            }, 10);
        }

        function findNearestInLayer(queryNode, allNodes, layerIndices, count) {
            const distances = layerIndices.map(idx => ({ index: idx, dist: distSq(queryNode, allNodes[idx]) }));
            distances.sort((a, b) => a.dist - b.dist);
            return distances.slice(1, count + 1).map(d => d.index);
        }
        
        function search() {
            if (!state.graph || !state.queryPoint || state.isSearching) return;
            
            state.isSearching = true;
            state.searchCompleted = false;
            setButtonsDisabled(true, true);
            searchInfoBox.classList.remove('hidden');
            candidatesEvaluatedText.textContent = '0';
            
            state.currentSearchLayer = state.numLayers - 1;
            state.currentEntryPoint = state.graph.entryPoint;
            state.totalEvaluated = 0;

            processNextLayer();
        }

        async function processNextLayer() {
            const { queryPoint, graph, currentEntryPoint, currentSearchLayer } = state;
            const l = currentSearchLayer;

            setButtonsDisabled(true, true);
            currentLayerText.textContent = `${l}`;
            statusText.innerHTML = `<strong>Searching Layer ${l}...</strong><br>This is the "highway" to quickly cross the graph.`;

            const searchResult = await searchLayer(queryPoint, currentEntryPoint, l);
            state.currentEntryPoint = searchResult.bestNode;
            state.totalEvaluated += searchResult.evaluatedCount;
            
            if (l > 0) {
                statusText.innerHTML = `<strong>Layer ${l} search done.</strong><br>Best node is #${state.currentEntryPoint}. This becomes the entry point for the next, denser layer.`;
                continueBtn.classList.remove('hidden');
                continueBtn.disabled = false;
            } else {
                finishSearch();
            }
        }

        function continueSearch() {
            continueBtn.classList.add('hidden');
            continueBtn.disabled = true;
            state.currentSearchLayer--;
            processNextLayer();
        }

        function finishSearch() {
            const { nodes } = state.graph;
            const q = state.queryPoint;
            state.hnswResult = { index: state.currentEntryPoint, dist: distSq(q, nodes[state.currentEntryPoint]) };
            state.trueNearest = findTrueNearest(q, nodes);
            const hnswDist = Math.sqrt(state.hnswResult.dist).toFixed(1);
            const trueDist = Math.sqrt(state.trueNearest.dist).toFixed(1);
            let resultText = `Found: #${state.hnswResult.index} (Dist: ${hnswDist}). `;
            if (state.hnswResult.index === state.trueNearest.index) {
                resultText += "This is the true nearest neighbor!";
            } else {
                resultText += `True NN: #${state.trueNearest.index} (Dist: ${trueDist}).`;
            }
            statusText.innerHTML = `<strong>Search Complete!</strong><br>${resultText}`;
            state.searchCompleted = true;
            draw();
            state.isSearching = false;
            setButtonsDisabled(false, false);
            continueBtn.classList.add('hidden');
        }
        
        function findTrueNearest(queryPoint, nodes) {
            let best = { index: -1, dist: Infinity };
            for(let i = 0; i < nodes.length; i++) {
                const d = distSq(queryPoint, nodes[i]);
                if (d < best.dist) { best = { index: i, dist: d }; }
            }
            return best;
        }

        async function searchLayer(q, entryPoint, layer) {
            const { nodes } = state.graph;
            const ef = layer === 0 ? state.params.ef : Math.max(5, state.params.ef / 2);
            let visited = new Set([entryPoint]);
            let candidates = new PriorityQueue((a, b) => a.dist < b.dist);
            let bestFound = { index: entryPoint, dist: distSq(q, nodes[entryPoint]) };
            candidates.push({ index: entryPoint, dist: bestFound.dist });
            let evaluatedCount = 0;
            while (!candidates.isEmpty()) {
                let current = candidates.pop();
                if (current.dist > bestFound.dist && layer === 0) { break; }
                const connections = Array.from(nodes[current.index].connections[layer]);
                for (const neighborIndex of connections) {
                    if (!visited.has(neighborIndex)) {
                        visited.add(neighborIndex);
                        evaluatedCount++;
                        const neighborDist = distSq(q, nodes[neighborIndex]);
                        if (neighborDist < bestFound.dist || candidates.size() < ef) {
                            candidates.push({ index: neighborIndex, dist: neighborDist });
                            if (neighborDist < bestFound.dist) {
                                bestFound = { index: neighborIndex, dist: neighborDist };
                            }
                        }
                    }
                }
                const animationState = {
                    currentPath: [bestFound.index, current.index],
                    visited: new Set(Array.from(visited).slice(-20)),
                    candidates: candidates._heap.map(c => c.index),
                    bestNode: bestFound.index
                };
                draw();
                drawSearchState(animationState);
                bestDistText.textContent = Math.sqrt(bestFound.dist).toFixed(2);
                candidatesEvaluatedText.textContent = state.totalEvaluated + evaluatedCount;
                await sleep(40);
            }
            return { bestNode: bestFound.index, evaluatedCount };
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            mSlider.addEventListener('input', e => { state.params.M = parseInt(e.target.value); mValue.textContent = e.target.value; });
            efConstructionSlider.addEventListener('input', e => { state.params.efConstruction = parseInt(e.target.value); efConstructionValue.textContent = e.target.value; });
            efSlider.addEventListener('input', e => { state.params.ef = parseInt(e.target.value); efValue.textContent = e.target.value; });
            randomizeBtn.addEventListener('click', generatePoints);
            buildBtn.addEventListener('click', buildGraph);
            searchBtn.addEventListener('click', search);
            continueBtn.addEventListener('click', continueSearch);
            canvas.addEventListener('click', e => {
                if (state.isSearching) return;
                const rect = canvas.getBoundingClientRect();
                state.queryPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                state.searchCompleted = false;
                searchBtn.disabled = !state.graph;
                if(state.graph) {
                    statusText.textContent = "Query point set. Ready to search.";
                } else {
                    statusText.textContent = "Query point set. Build the graph to enable search.";
                }
                searchInfoBox.classList.add('hidden');
                continueBtn.classList.add('hidden');
                draw();
            });
        }
        
        function setButtonsDisabled(mainControls, searchControl) {
            randomizeBtn.disabled = mainControls;
            buildBtn.disabled = mainControls;
            searchBtn.disabled = searchControl;
        }

        // --- Initialization ---
        function init() {
            setupEventListeners();
            resizeCanvas();
            generatePoints();
        }

        init();
    </script>
</body>
</html>
